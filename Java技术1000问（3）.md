###### 如何手动编译java类？
问：如何手动编译java类？
- 答：将JDK所在的路径添加到了系统的PATH环境变量中后，使用“javac -d destdir srcFile”命令就可以对Java文件编译成类文件，其中d destdir是javac命令的选项，用以指定编译生成的字节码文件的存放路径，destdir只需是本地磁盘上的一个有效路径即可；而srcFile是Java源文件所在的位置，这个位置既可以是绝对路径，也可以是相对路径。
###### 使用javac编译Java程序时怎么不需要指定目标文件的文件名呢？
问：当我们编译C程序时，不仅需要指定存放目标文件的位置，也需要指定目标文件的文件名，这里使用javac编译Java程序时怎么不需要指定目标文件的文件名呢？
- 答：使用javac编译文件只需要指定存放目标文件的位置即可，无须指定字节码文件的文件名。因为javac编译后生成的字节码文件有默认的文件名：文件名总是以源文件所定义类的类名作为主文件名的，以.class作为后缀名。这意味着如果一个源文件里定义了多个类，将编译生成多个字节码文件。事实上，指定目标文件存放位置的-d选项也是可省略的，如果省略该选项，则意味着将生成的字节码文件放在当前路径下。
###### 如何运行Java程序？
问：如何运行Java程序？
- 答：运行Java程序使用java命令，启动命令行窗口，进入HelloWorld.class所在的位置，在命令行窗口里直接输入java命令：java hello.class。hello.class是字节码文件名。
###### Java程序的入口是啥？
问：Java程序的入口是啥？
- 答：想要运行起来，类里必须包含main方法，而且main方法必须使用publicstatic void来修饰，且main方法的形参必须是字符串数组类型（String[]args是字符串数组的形式）。也就是说，main方法的写法几乎是固定的。Java解释器就从这个main方法开始解释执行，因此，main方法是Java程序的入口。
###### Java如何控制内存回收？
问：Java如何控制内存回收？
- 答：Java程序的内存分配和回收都是由JRE在后台自动进行的。JRE会负责回收那些不再使用的内存，这种机制被称为垃圾回收（Garbage Collection，也被称为GC）。通常JRE会提供一个后台线程来进行检测和控制，一般都是在CPU空闲或内存不足时自动进行垃圾回收，而程序员无法精确控制垃圾回收的时间和顺序等。
###### Java的堆内存是什么？
问：Java的堆内存是什么？
- 答：Java的堆内存是一个运行时数据区，用以保存类的实例（对象），Java虚拟机的堆内存中存储着正在运行的应用程序所建立的所有对象，这些对象不需要程序通过代码来显式地释放。一般来说，堆内存的回收由垃圾回收来负责，所有的JVM实现都有一个由垃圾回收器管理的堆内存。垃圾回收是一种动态存储管理技术，它自动地释放不再被程序引用的对象，按照特定的垃圾回收算法来实现内存资源的自动回收功能。
###### Java垃圾回收除了释放没用的对象外还能做什么？
问：Java垃圾回收除了释放没用的对象外还能做什么？
- 答：当一个对象不再被引用时，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象外，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存区，碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。
###### 基于垃圾回收机制，写Java程序应当遵循什么原则？
问：基于垃圾回收机制，写Java程序应当遵循什么原则？
- 答：当编写Java程序时，一个基本原则是：对于不再需要的对象，不要引用它们。如果保持对这些对象的引用，垃圾回收机制暂时不会回收该对象，则会导致系统可用内存越来越少；当系统可用内存越来越少时，垃圾回收执行的频率就越来越高，从而导致系统的性能下降。
###### Java回收的内存是指什么内存？
问：Java回收的内存是指什么内存？
- 答：垃圾回收机制的工作目标是回收无用对象的内存空间，这些内存空间都是JVM堆内存里的内存空间，垃圾回收只能回收内存资源，对其他物理资源，如数据库连接、磁盘I/O等资源则无能为力。
###### 为了更快地让垃圾回收机制回收那些不再使用的对象应该怎么做？
问：为了更快地让垃圾回收机制回收那些不再使用的对象应该怎么做？
- 答：为了更快地让垃圾回收机制回收那些不再使用的对象，可以将该对象的引用变量设置为null，通过这种方式暗示垃圾回收机制可以回收该对象。
###### 垃圾回收发生的不可预知性是指什么？
问：垃圾回收发生的不可预知性是指什么？
- 答：垃圾回收发生的不可预知性。由于不同JVM采用了不同的垃圾回收机制和不同的垃圾回收算法，因此它有可能是定时发生的，有可能是当CPU空闲时发生的，也有可能和原始的垃圾回收一样，等到内存消耗出现极限时发生，这和垃圾回收实现机制的选择及具体的设置都有关系。虽然程序员可以通过调用对象的finalize()方法或System.gc()等方法来建议系统进行垃圾回收，但这种调用仅仅是建议，依然不能精确控制垃圾回收机制的执行。
###### 垃圾回收的精确性是指什么？
问：垃圾回收的精确性是指什么？
- 答：垃圾回收的精确性主要包括两个方面：一是垃圾回收机制能够精确地标记活着的对象；二是垃圾回收器能够精确地定位对象之间的引用关系。前者是完全回收所有废弃对象的前提，否则就可能造成内存泄漏；而后者则是实现归并和复制等算法的必要条件，通过这种引用关系，可以保证所有对象都能被可靠地回收，所有对象都能被重新分配，从而有效地减少内存碎片的产生。
- 答：垃圾回收的精确性主要包括两个方面：一是垃圾回收机制能够精确地标记活着的对象；二是垃圾回收器能够精确地定位对象之间的引用关系。前者是完全回收所有废弃对象的前提，否则就可能造成内存泄漏；而后者则是实现归并和复制等算法的必要条件，通过这种引用关系，可以保证所有对象都能被可靠地回收，所有对象都能被重新分配，从而有效地减少内存碎片的产生。
###### 为什么Java要添加程序注释？
问：为什么Java要添加程序注释？
- 答："1. 永远不要过于相信自己的理解力！当你思路通畅，进入编程境界时，你可以很流畅地实现某个功能，但这种流畅可能是因为你当时正处于这种开发思路中。为了在再次阅读这段代码时，还能找回当初编写这段代码的思路，建议添加注释！ 2. 可读性第一，效率第二！在那些“古老”的岁月里，编程是少数人的专利，他们随心所欲地写程序，他们以追逐程序执行效率为目的。但随着软件行业的发展，人们发现仅有少数技术Geek编程满足不了日益增长的软件需求，越来越多的人加入了编程队伍，并引入了工程化的方式来管理软件开发。这个时候，软件开发变成团队协同作战，团队成员的沟通变得很重要，因此，一个人写的代码，需要被整个团队的其他人所理解；而且，随着硬件设备的飞速发展，程序的可读性取代执行效率变成了第一考虑的要素。 3. 代码即文档！很多刚刚学完学校软件工程课程的学生会以为：文档就是Wo rd文档！实际上，程序源代码是程序文档的重要组成部分，当我们想着把各种软件相关文档写规范时，不要忘了把软件里最重要的文档：源代码写规范！"
###### Java如何进行单行注释和多行注释？
问：Java如何进行单行注释和多行注释？
- 答：单行注释就是在程序中注释一行代码，在Java语言中，将双斜线（//）放在需要注释的内容之前，就可以了；多行注释是指一次性地将程序中多行代码注释掉，在Java语言中，使用“/<em>”和“</em>/”将程序中需要注释的内容包含起来，“/<em>”表示注释开始，而“</em>/”表示注释结束。
###### Java的API文档是什么?
问：Java的API文档是什么?
- 答：开发一个大型软件时，需要定义成千上万的类，而且需要很多人参与开发。每个人都会开发一些类，并在类里定义一些方法、Field提供给其他人使用，但其他人怎么知道如何使用这些类和方法呢？这时候就需要提供一份说明文档，用于说明每个类、每个方法的用途。当其他人使用一个类或一个方法时，他无须关心这个类或这个方法的具体实现，他只要知道这个类或这个方法的功能即可，然后使用这个类或方法来实现具体的目的，也就是通过调用应用程序接口（API）来编程。API文档就是用以说明这些应用程序接口的文档。对于Java语言而言，API文档通常详细说明了每个类、每个方法的功能及用法等。
###### Java的基本类型有哪些？
问：Java的基本类型有哪些？
- 答：Java的基本数据类型分为两大类：boolean类型和数值类型。而数值类型又可以分为整数类型和浮点类型，整数类型里的字符类型也可以被单独对待。因此常常把Java里的基本数据类型分为4类。
###### Java整型有哪些？
问：Java整型有哪些？
- 答："通常所说的整型，实际指的是如下4种类型。 byte：一个byte类型整数在内存里占8位，表数范围是：-128(-27)~127(27-1)。 short：一个short类型整数在内存里占16位，表数范围是：-32768(-215)~32767(215-1)。 int：一个int类型整数在内存里占32位，表数范围是：-2147483648(-231)~2147483647(231-1)。 long：一个long类型整数在内存里占64位，表数范围是：-9·223372036854775808(-263)~9223372036854775807(263-1)。"
###### 如何让系统把一个整数常量当成long类型来处理？
问：如何让系统把一个整数常量当成long类型来处理？
- 答：如果使用一个巨大的整数常量（超出了int类型的表数范围）时，Java不会自动把这个整数常量当成long类型来处理。如果希望系统把一个整数常量当成long类型来处理，应在这个整数常量后增加l或者L作为后缀。通常推荐使用L，因为字母l很容易跟数字1搞混。
###### Java中整数常量有哪几种表示方式？
问：Java中整数常量有哪几种表示方式？
- 答：Java中整数常量有4种表示方式：二进制、十进制、八进制和十六进制，其中八进制的整数常量以0开头，十六进制的整数常量以0x或者0X开头，其中10~15分别以a~f（此处的a~f不区分大小写）来表示。
###### 如何使用Unicode值来表示字符型常量？
问：如何使用Unicode值来表示字符型常量？
- 答：使用Unicode值来表示字符型常量，格式是'\uXXXX'，其中XXXX代表一个十六进制的整数。范围是'\u0000'～'\uFFFF'，一共可以表示65535个字符，其中前256个（'\u0000'～'\u00FF'）字符和ASCII码中的字符完全重合。
###### Java的字符类型和整数类型有什么关系？
问：Java的字符类型和整数类型有什么关系？
- 答：char类型的值也可直接作为整数类型的值来使用，但它是一个16位的无符号整数，即全部是正数，表数范围是0～65535。如果把0～65535范围内的一个int整数赋给char类型变量，系统会自动把这个int整数当成char类型来处理。如：char aChar = 'a';char aNumChar = 97;
###### Java的浮点类型有哪几种？
问：Java的浮点类型有哪几种？
- 答：Java的浮点类型有两种：float和double。Java的浮点类型有固定的表数范围和字段长度，字段长度和表数范围与机器无关。Java的浮点数遵循IEEE 754标准，采用二进制数据的科学计数法来表示浮点数，对于float型数值，第1位是符号位，接下来8位表示指数，再接下来的23位表示尾数；对于double类型数值，第1位也是符号位，接下来的11位表示指数，再接下来的52位表示尾数。double类型代表双精度浮点数，float类型代表单精度浮点数。一个double类型的数值占8个字节、64位，一个float类型的数值占4个字节、32位。
###### 当Java程序中用到的数值位数特别多时怎么办？
问：当Java程序中用到的数值位数特别多时怎么办？
- 答：当程序中用到的数值位数特别多时，程序员眼睛“看花”了都看不清到底有多少位数。为了解决这种问题，Java 7引入了一个新功能：程序员可以在数值中使用下画线，不管是整型数值，还是浮点型数值，都可以自由地使用下画线。通过使用下画线分隔，可以更直观地分辨数值常量中到底包含多少位。如double a = 3.14_15_92_65_36;。
###### Java语言中的运算符可分为几种？
问：Java语言中的运算符可分为几种？
- 答："Java语言中的运算符可分为如下几种： 算术运算符 赋值运算符 比较运算符 逻辑运算符 位运算符 类型相关运算符"
###### Java支持的基本算术运算符有哪些？
问：Java支持的基本算术运算符有哪些？
- 答：
```
Java支持所有的基本算术运算符，这些算术运算符用于执行基本的数学运算：加、减、乘、除和求余等。如+, - , * , / , % , ++, --
```
###### Java支持的位运算符有哪些？
问：Java支持的位运算符有哪些？
- 答："&：按位与。 |：按位或。 ~：按位非。 ^：按位异或。 <<：左移运算符。 
 
  
  ：右移运算符。 
   
   ：无符号右移运算符。"
###### Java支持的逻辑运算符有哪些？
问：Java支持的逻辑运算符有哪些？
- 答："&&：与，前后两个操作数必须都是true才返回true，否则返回false。 &：不短路与，作用与&&相同，但不会短路。 ||：或，只要两个操作数中有一个是true，就可以返回true，否则返回false。 |：不短路或，作用与||相同，但不会短路。 !：非，只需要一个操作数，如果操作数为true，则返回false；如果操作数为false，则返回true。 ^：异或，当两个操作数不同时才返回true，如果两个操作数相同则返回false。"
###### Java的三目运算符怎么使用？
问：Java的三目运算符怎么使用？
- 答：目运算符的规则是：先对逻辑表达式expression求值，如果逻辑表达式返回true，则返回第二个操作数的值，如果逻辑表达式返回false，则返回第三个操作数的值。如String str = x > y ? "x" : "y";
###### Java也支持面向对象的三大特征是啥？
问：Java也支持面向对象的三大特征是啥？
- 答：Java也支持面向对象的三大特征：封装、继承和多态，Java提供了private、protected和public三个访问控制修饰符来实现良好的封装，提供了extends关键字来让子类继承父类，子类继承父类就可以继承到父类的Field和方法，如果访问控制允许，子类实例可以直接调用父类里定义的方法。继承是实现类复用的重要手段，除此之外，也可通过组合关系来实现这种复用，从某种程度上来看，继承和组合具有相同的功能。使用继承关系来实现复用时，子类对象可以直接赋给父类变量，这个变量具有多态性，编程更加灵活；而利用组合关系来实现复用时，则不具备这种灵活性。
###### Java初始化块怎么使用？
问：Java初始化块怎么使用？
- 答：构造器用于对类实例进行初始化操作，构造器支持重载，如果多个重载的构造器里包含了相同的初始化代码，则可以把这些初始化代码放置在普通初始化块里完成，初始化块总在构造器执行之前被调用。除此之外，Java还提供了一种静态初始化块，静态初始化块用于初始化类，在类初始化阶段被执行。如果继承树里的某一个类需要被初始化，系统将会同时初始化该类的所有父类。
###### Java构造器不是没有返回值吗？为什么不能用void修饰呢？
问：Java构造器不是没有返回值吗？为什么不能用void修饰呢？
- 答：简单地说，这是Java的语法规定。实际上，类的构造器是有返回值的，当我们用new关键字来调用构造器时，构造器返回该类的实例，可以把这个类的实例当成构造器的返回值，因此构造器的返回值类型总是当前类，无须定义返回值类型。但必须注意：不能在构造器里显式使用return来返回当前类的对象，因为构造器的返回值是隐式的。
###### Java的对象、引用和指针之间的联系？
问：Java的对象、引用和指针之间的联系？
- 答：有这样一行代码：Person p=newPerson();，这行代码创建了一个Person实例，也被称为Person对象，这个Person对象被赋给p变量。程序中定义的Person类型的变量实际上是一个引用，它被存放在栈内存里，指向实际的Person对象；而真正的Person对象则存放在堆（heap）内存中。
###### Java语言里方法的所属性主要体现在哪几个方面？
问：Java语言里方法的所属性主要体现在哪几个方面？
- 答："Java语言里方法的所属性主要体现在如下几个方面。 方法不能独立定义，方法只能在类体里定义。 从逻辑意义上来看，方法要么属于该类本身，要么属于该类的一个对象。 永远不能独立执行方法，执行方法必须使用类或对象作为调用者。"
###### Java的实参值是如何传入方法的呢？
问：Java的实参值是如何传入方法的呢？
- 答：这是由Java方法的参数传递机制来控制的，Java里方法的参数传递方式只有一种：值传递。所谓值传递，就是将实际参数值的副本（复制品）传入方法内，而参数本身不会受到任何影响。
###### Java基本类型的参数传递和引用类型的参数传递有啥区别？
问：Java基本类型的参数传递和引用类型的参数传递有啥区别？
- 答：对于基本类型，在main方法中调用swap方法时，main方法还未结束。因此，系统分别为main方法和swap方法分配两块栈区，用于保存main方法和swap方法的局部变量。main方法中的a、b变量作为参数值传入swap方法，实际上是在swap方法栈区中重新产生了两个变量a、b，并将main方法栈区中a、b变量的值分别赋给swap方法栈区中的a、b参数（就是对swap方法的a、b形参进行了初始化）。此时，系统存在两个a变量、两个b变量，只是存在于不同的方法栈区中而已。对于引用类型，统一样复制了参数的副本传入swap方法，但关键在于参数只是一个引用变量，所以系统复制了参数变量，但并未复制参数对象。
###### Java如何定义形参个数可变的参数？
问：Java如何定义形参个数可变的参数？
- 答：如下：public static void test(int a, String... books);还要指出的是，数组形式的形参可以处于形参列表的任意位置，但个数可变的形参只能处于形参列表的最后。也就是说，一个方法中最多只能有一个长度可变的形参。
###### Java的方法重载是啥？`
问：Java的方法重载是啥？`
- 答：Java允许同一个类里定义多个同名方法，只要形参列表不同就行。如果同一个类中包含了两个或两个以上方法的方法名相同，但形参列表不同，则被称为方法重载。
###### 为什么Java方法的返回值类型不能用于区分重载的方法？
问：为什么Java方法的返回值类型不能用于区分重载的方法？
- 答：对于int f(){}和void f(){}两个方法，如果这样调用intresult=f();，系统可以识别是调用返回值类型为int的方法；但Java调用方法时可以忽略方法返回值，如果采用如下方法来调用f();，你能判断是调用哪个方法吗？如果你尚且不能判断，那么Java系统也会糊涂。在编程过程中有一条重要规则：不要让系统糊涂，系统一糊涂，肯定就是你错了。因此，Java里不能使用方法返回值类型作为区分方法重载的依据。
###### Java面向对象的三大特征是什么？
问：Java面向对象的三大特征是什么？
- 答：封装、继承、多态
- 答：封装、继承和多态
###### Java封装有什么用处？
问：Java封装有什么用处？
- 答："隐藏类的实现细节。 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对Field的不合理访问。 可进行数据检查，从而有利于保证对象信息的完整性。 便于修改，提高代码的可维护性。为了实现良好的封装，需要从两个方面考虑。 将对象的Field和实现细节隐藏起来，不允许外部直接访问。 把方法暴露出来，让方法来控制对这些Field进行安全的访问和操作。"
###### Java有几个访问控制级别？
问：Java有几个访问控制级别？
- 答：Java提供了3个访问控制符：private、protected和public，分别代表了3个访问控制级别，另外还有一个不加任何访问控制符的访问控制级别，提供了4个访问控制级别。
###### 关于Java访问控制符的使用，存在几条基本原则？
问：关于Java访问控制符的使用，存在几条基本原则？
- 答："类里的绝大部分Field都应该使用private修饰，只有一些static修饰的、类似全局变量的Field，才可能考虑使用public修饰。除此之外，有些方法只是用于辅助实现该类的其他方法，这些方法被称为工具方法，工具方法也应该使用private修饰。 如果某个类主要用做其他类的父类，该类里包含的大部分方法可能仅希望被其子类重写，而不想被外界直接调用，则应该使用protected修饰这些方法。 希望暴露出来给其他类自由调用的方法应该使用public修饰。因此，类的构造器通过使用public修饰，从而允许在其他地方创建该类的实例。因为外部类通常都希望被其他类自由使用，所以大部分外部类都使用public修饰。"
###### Java中package、import和import static有什么区别？
问：Java中package、import和import static有什么区别？
- 答："package语句必须作为源文件的第一条非注释性语句，一个源文件只能指定一个包，即只能包含一条package语句，该源文件中可以定义多个类，则这些类将全部位于该包下。 如果需要使用不同包中的其他类时，总是需要使用该类的全名，这是一件很烦琐的事情。为了简化编程，Java引入了import关键字，import可以向某个Java文件中导入指定包层次下某个类或全部类，import语句应该出现在package语句（如果有的话）之后、类定义之前。一个Java源文件只能包含一个package语句，但可以包含多个import语句，多个import语句用于导入多个包层次下的类。 JDK 1.5以后更是增加了一种静态导入的语法，它用于导入指定类的某个静态Field、方法或全部的静态Field、方法。"
###### 构造器是创建Java对象的途径，是不是说构造器完全负责创建Java对象？
问：构造器是创建Java对象的途径，是不是说构造器完全负责创建Java对象？
- 答：不是！构造器是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回了该类的对象，但这个对象并不是完全由构造器负责创建的。实际上，当程序员调用构造器时，系统会先为该对象分配内存空间，并为这个对象执行默认初始化，这个对象已经产生了——这些操作在构造器执行之前就都完成了。也就是说，当系统开始执行构造器的执行体之前，系统已经创建了一个对象，只是这个对象还不能被外部程序访问，只能在该构造器中通过this来引用。当构造器的执行体执行结束后，这个对象作为构造器的返回值被返回，通常还会赋给另一个引用类型的变量，从而让外部程序可以访问该对象。
###### Java的构造器如何重载？
问：Java的构造器如何重载？
- 答：同一个类里具有多个构造器，多个构造器的形参列表不同，即被称为构造器重载。构造器重载允许Java类里包含多个初始化逻辑，从而允许使用不同的构造器来初始化Java对象。构造器重载和方法重载基本相似：要求构造器的名字相同，这一点无须特别要求，因为构造器必须与类名相同，所以同一个类的所有构造器名肯定相同。为了让系统能区分不同的构造器，多个构造器的参数列表必须不同。
###### 为什么要用this来调用另一个重载的构造器？我把另一个构造器里的代码复制、粘贴到这个构造器里不就可以
问：为什么要用this来调用另一个重载的构造器？我把另一个构造器里的代码复制、粘贴到这个构造器里不就可以了吗？
- 答：如果仅仅从软件功能实现上来看，这样复制、粘贴确实可以实现这个效果；但从软件工程的角度来看，这样做是相当糟糕的。在软件开发里有一个规则：不要把相同的代码段书写两次以上！因为软件是一个需要不断更新的产品，如果有一天需要更新图4.16中构造器A的初始化代码，假设构造器B、构造器C……里都包含了相同的初始化代码，则需要同时打开构造器A、构造器B、构造器C……的代码进行修改；反之，如果构造器B、构造器C……是通过this调用了构造器A的初始化代码，则只需要打开构造器A进行修改即可。因此，尽量避免相同的代码重复出现，充分复用每一段代码，既可以让程序代码更加简洁，也可以降低软件的维护成本。
###### Java类如何继承？
问：Java类如何继承？
- 答：Java的继承通过extends关键字来实现，实现继承的类被称为子类，被继承的类被称为父类，有的也称其为基类、超类。父类和子类的关系，是一种一般和特殊的关系。例如水果和苹果的关系，苹果继承了水果，苹果是水果的子类，则苹果是一种特殊的水果。
###### Java方法重写需要遵循什么原则？
问：Java方法重写需要遵循什么原则？
- 答：方法的重写要遵循“两同两小一大”规则，“两同”即方法名相同、形参列表相同；“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。尤其需要指出的是，覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法，一个是实例方法。
###### Java如何在子类方法中调用父类被覆盖的实例方法？
问：Java如何在子类方法中调用父类被覆盖的实例方法？
- 答：如果需要在子类方法中调用父类被覆盖的实例方法，则可使用super限定来调用父类被覆盖的实例方法。super是Java提供的一个关键字，super用于限定该对象调用它从父类继承得到的Field或方法。正如this不能出现在static修饰的方法中一样，super也不能出现在static修饰的方法中。static修饰的方法是属于类的，该方法的调用者可能是一个类，而不是对象，因而super限定也就失去了意义。
###### Java子类继承父类会重新分配内存吗？
问：Java子类继承父类会重新分配内存吗？
- 答：当程序创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存，也会为它从父类继承得到的所有实例变量分配内存，即使子类定义了与父类中同名的实例变量。也就是说，当系统创建一个Java对象时，如果该Java类有两个父类（一个直接父类A，一个间接父类B），假设A类中定义了2个实例变量，B类中定义了3个实例变量，当前类中定义了2个实例变量，那么这个Java对象将会保存2+3+2个实例变量。
###### 为什么我创建Java对象时从未感觉到java.lang. Object类的构造器被调用过？
问：为什么我创建Java对象时从未感觉到java.lang. Object类的构造器被调用过？
- 答：你当然感觉不到啦，因为自定义的类从未显式调用过java.lang.Object类的构造器，即使显式调用，java.lang.Object类也只有一个默认的构造器可被调用。当系统执行java.lang.Object类的默认构造器时，该构造器的执行体并未输出任何内容，所以你感觉不到调用过java.lang.Object类的构造器。
###### Java的多态是指什么？
问：Java的多态是指什么？
- 答：Java引用变量有两个类型：一个是编译时类型，一个是运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现所谓的多态（Polymorphism）。
###### Java的instanceof有什么用处？`
问：Java的instanceof有什么用处？
- 答：instanceof运算符的作用是：在进行强制类型转换之前，首先判断前一个对象是否是后一个类的实例，是否可以成功转换，从而保证代码更加健壮。
###### 为了保证Java父类有良好的封装性，不会被子类随意改变，设计父类通常应该遵循什么规则？
问：为了保证Java父类有良好的封装性，不会被子类随意改变，设计父类通常应该遵循什么规则？
- 答："尽量隐藏父类的内部数据。尽量把父类的所有Field都设置成private访问类型，不要让子类直接访问父类的Field。 不要让子类可以随意访问、修改父类的方法。父类中那些仅为辅助其他的工具方法，应该使用private访问控制符修饰，让子类无法访问该方法；如果父类中的方法需要被外部类调用，则必须以public修饰，但又不希望子类重写该方法，可以使用final修饰符（该修饰符后面会有更详细的介绍）来修饰该方法；如果希望父类的某个方法被子类重写，但不希望被其他类自由访问，则可以使用protected来修饰该方法。 尽量不要在父类构造器中调用将要被子类重写的方法。"
###### Java如何把某些类设置成最终类？
问：Java如何把某些类设置成最终类？
- 答：如果想把某些类设置成最终类，即不能被当成父类，则可以使用final修饰这个类，例如JDK提供的java.lang.String类和java.lang.System类。除此之外，使用private修饰这个类的所有构造器，从而保证子类无法调用该类的构造器，也就无法继承该类。对于把所有的构造器都使用private修饰的父类而言，可另外提供一个静态方法，用于创建该类的实例。
###### Java如何利用组合实现复用？
问：Java如何利用组合实现复用？
- 答：如果需要复用一个类，除了把这个类当成基类来继承之外，还可以把该类当成另一个类的组合成分，从而允许新类直接复用该类的public方法。不管是继承还是组合，都允许在新类（对于继承就是子类）中直接复用旧类的方法。
###### 使用组合关系来实现复用时，需要创建两个Animal对象，是不是意味着使用组合关系时系统开销更大？
问：使用组合关系来实现复用时，需要创建两个Animal对象，是不是意味着使用组合关系时系统开销更大？
- 答：不会。回忆前面介绍继承时所讲的内容，当创建一个子类对象时，系统不仅需要为该子类定义的Field分配内存空间，而且需要为它的父类所定义的Field分配内存空间。如果采用继承的设计方式，假设父类定义了2个Field，子类定义了3个Field，当创建子类实例时，系统需要为子类实例分配5块内存空间；如果采用组合的设计方式，先创建被嵌入类实例，此时需要分配2块内存空间，再创建整体类实例，也需要分配3块内存空间，只是需要多一个引用变量来引用被嵌入的对象。通过这个分析来看，继承设计与组合设计的系统开销不会有本质的差别。
###### Java到底该用继承？还是该用组合呢？
问：Java到底该用继承？还是该用组合呢？
- 答：继承是对已有的类做一番改造，以此获得一个特殊的版本。简而言之，就是将一个较为抽象的类改造成能适用于某些特定需求的类。因此，对于Wolf和Animal的关系，使用继承更能表达其现实意义。用一个动物来合成一匹狼毫无意义：狼并不是由动物组成的。反之，如果两个类之间有明确的整体、部分的关系，例如Person类需要复用Arm类的方法（Person对象由Arm对象组合而成），此时就应该采用组合关系来实现复用，把Arm作为Person类的嵌入Field，借助于Arm的方法来实现Person的方法，这是一个不错的选择。
###### Java类中可能出现的四种成员是啥？
问：Java类中可能出现的四种成员是啥？
- 答：Field、方法、构造器和初始化块
###### Java可以使用两个初始化块吗？
问：Java可以使用两个初始化块吗？
- 答：虽然Java允许一个类里定义2个普通初始化块，但这没有任何意义。因为初始化块是在创建Java对象时隐式执行的，而且它们总是全部执行，因此我们完全可以把多个普通初始化块合并成一个初始化块，从而可以让程序更加简洁，可读性更强。
###### 创建一个Java对象时，执行顺序是怎样的？
问：创建一个Java对象时，执行顺序是怎样的？
- 答：创建一个Java对象时，不仅会执行该类的普通初始化块和构造器，而且系统会一直上溯到java.lang.Object类，先执行java.lang.Object类的初始化块，开始执行java.lang.Object的构造器，依次向下执行其父类的初始化块，开始执行其父类的构造器……最后才执行该类的初始化块和构造器，返回该类的对象。
###### Java类静态属性的执行顺序是怎样的？
问：Java类静态属性的执行顺序是怎样的？
- 答：当JVM第一次主动使用某个类时，系统会在类准备阶段为该类的所有静态Field分配内存；在初始化阶段则负责初始化这些静态Field，初始化静态Field就是执行类初始化代码或者声明类Field时指定的初始值，它们的执行顺序与源代码中的排列顺序相同。
###### 同样是两个int类型的数值自动装箱成Integer实例后，如果是两个2自动装箱后就相等；但如果是两个
问：同样是两个int类型的数值自动装箱成Integer实例后，如果是两个2自动装箱后就相等；但如果是两个128自动装箱后就不相等，这是为什么呢？
- 答：系统把一个−128～127之间的整数自动装箱成Integer实例，并放入了一个名为cache的数组中缓存起来。如果以后把一个−128～127之间的整数自动装箱成一个Integer实例时，实际上是直接指向对应的数组元素，因此−128～127之间的同一个整数自动装箱成Integer实例时，永远都是引用cache数组的同一个数组元素，所以它们全部相等；但每次把一个不在−128～127范围内的整数自动装箱成Integer实例时，系统总是重新创建一个Integer实例，所以出现程序中的运行结果。
###### Java为什么要对−128～127之间的整数进行缓存呢?
问：Java为什么要对−128～127之间的整数进行缓存呢?
- 答：缓存是一种非常优秀的设计模式，在Java、Java EE平台的很多地方都会通过缓存来提高系统的运行性能。简单地说，如果你需要一台电脑，那么你就去买了一台电脑。但你不可能一直使用这台电脑，你总会离开这台电脑——在你离开电脑的这段时间内，你如何做？你会不会立即把电脑扔掉？当然不会，你会把电脑放在房间里，等下次又需要电脑时直接开机使用，而不是再次去购买一台。假设电脑是内存中的对象，而你的房间是内存，如果房间足够大，则可以把所有曾经用过的各种东西都缓存起来，但这不可能，房间的空间是有限制的，因此有些东西你用过一次就扔掉了。你只会把一些购买成本大、需要频繁使用的东西保存下来。类似地，Java也把一些创建成本大、需要频繁使用的对象缓存起来，从而提高程序的运行性能。
###### Java打印对象会输出什么？
问：Java打印对象会输出什么？
- 答：创建了一个Person对象，然后使用System.out.println方法输出Person对象。编译、运行上面程序，看到如下运行结果：Person@f72617。运行程序时，可能看到不同的输出结果：@符号后的6位十六进制数字可能发生改变。但这个输出结果是怎么来的呢？System.out.println方法只能在控制台输出字符串，而Person实例是一个内存中的对象，当使用该方法输出Person对象时，实际上输出的是Person对象的toString()方法的返回值。
###### Java的toString方法有什么作用？
问：Java的toString方法有什么作用？
- 答：toString方法是一个非常特殊的方法，它是一个“自我描述”方法，该方法通常用于实现这样一个功能：当程序员直接打印该对象时，系统将会输出该对象的“自我描述”信息，用以告诉外界该对象具有的状态信息。Object类提供的toString方法总是返回该对象实现类的“类名+@+hashCode”值，这个返回值并不能真正实现“自我描述”的功能，因此如果用户需要自定义类能实现“自我描述”的功能，就必须重写Object类的toString方法。
###### Java程序中==和equals方法有什么区别？
问：Java程序中==和equals方法有什么区别？
- 答：当使用==来判断两个变量是否相等时，如果两个变量是基本类型变量，且都是数值类型（不一定要求数据类型严格相同），则只要两个变量的值相等，就将返回true。但对于两个引用类型变量，它们必须指向同一个对象时，==判断才会返回true。==不可用于比较类型上没有父子关系的两个对象。equals方法是Object类提供的一个实例方法，因此所有引用变量都可调用该方法来判断是否与其他引用变量相等。但使用这个方法判断两个对象相等的标准与使用==运算符没有区别，同样要求两个引用变量指向同一个对象才会返回true。因此这个Object类提供的equals方法没有太大的实际意义，如果希望采用自定义的相等标准，则可采用重写equals方法来实现。
###### Java中"hello"直接量和new String("hello")有什么区别呢？
问：Java中"hello"直接量和new String("hello")有什么区别呢？
- 答：当Java程序直接使用形如"hello"的字符串直接量（包括可以在编译时就计算出来的字符串值）时，JVM将会使用常量池来管理这些字符串；当使用new String("hello")时，JVM会先使用常量池来管理"hello"直接量，再调用String类的构造器来创建一个新的String对象，新创建的String对象被保存在堆内存中。换句话说，new String("hello")一共产生了两个对象。
###### Java如何正确地重写equals方法？
问：Java如何正确地重写equals方法？
- 答："自反性：对任意x，x.equals(x)一定返回true。 对称性：对任意x和y，如果y.equals(x)返回true，则x.equals(y)也返回true。 传递性：对任意x,y,z，如果x.equals(y)返回ture，y.equals(z)返回true，则x.equals(z)一定返回true。 一致性：对任意x和y，如果对象中用于等价比较的信息没有改变，那么无论调用x.equals(y)多少次，返回的结果应该保持一致，要么一直是true，要么一直是false。 对任何不是null的x，x.equals(null)一定返回false。"
###### Java判断obj是否为Person类的实例时，为何不用obj instanceof Person来
问：Java判断obj是否为Person类的实例时，为何不用obj instanceof Person来判断呢？
- 答：对于instanceof运算符而言，当前面对象是后面类的实例或其子类的实例时都将返回true，所以实际上重写equals()方法判断两个对象是否为同一个类的实例时使用instanceof是有问题的。比如有一个Teacher类型的变量t，如果判断t instanceof Person，这也将返回true。但对于重写equals()方法的要求而言，通常要求两个对象是同一个类的实例，因此使用instanceof运算符不太合适。改为使用t.getClass()==Person.class比较合适。这行代码用到了反射基础，读者可参考第13章来理解此行代码。
###### Java的final修饰的成员变量为什么必须由程序员显式地指定初始值？
问：Java的final修饰的成员变量为什么必须由程序员显式地指定初始值？
- 答：对于final修饰的成员变量而言，一旦有了初始值，就不能被重新赋值，如果既没有在定义成员变量时指定初始值，也没有在初始化块、构造器中为成员变量指定初始值，那么这些成员变量的值将一直是系统默认分配的0、'\u0000'、false或null，这些成员变量也就完全失去了存在的意义。
###### Java的final修饰的局部变量不指定初始值可以吗？
问：Java的final修饰的局部变量不指定初始值可以吗？
- 答：可以的，如果final修饰的局部变量在定义时没有指定默认值，则可以在后面代码中对该final变量赋初始值，但只能一次，不能重复赋值；如果final修饰的局部变量在定义时已经指定默认值，则后面代码中不能再对该变量赋值。
###### Java final修饰基本类型变量和引用类型变量的区别？
问：Java final修饰基本类型变量和引用类型变量的区别？
- 答：当使用final修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。但对于引用类型变量而言，它保存的仅仅是一个引用，final只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。
###### Java中怎样的final变量可执行“宏替换”？
问：Java中怎样的final变量可执行“宏替换”？
- 答："对一个final变量来说，不管它是类Field、实例Field，还是局部变量，只要该变量满足3个条件，这个final变量就不再是一个变量，而是相当于一个直接量。 使用final修饰符修饰； 在定义该final变量时指定了初始值； 该初始值可以在编译时就被确定下来。"
###### Java不希望子类重写父类的某个方法怎么办？
问：Java不希望子类重写父类的某个方法怎么办？
- 答：final修饰的方法不可被重写，如果出于某些原因，不希望子类重写父类的某个方法，则可以使用final修饰该方法。
###### Java中不可变类是指什么？
问：Java中不可变类是指什么？
- 答：不可变（immutable）类的意思是创建该类的实例后，该实例的Field是不可改变的。Java提供的8个包装类和java.lang.String类都是不可变类，当创建它们的实例后，其实例的Field不可改变。String a = new String("one");上面程序创建了一个String对象，并为这个对象传入了"Hello"字符串作为参数，那么String类肯定需要提供实例Field来保存这个参数，但程序无法修改这个实例Field值，因此String类没有提供修改它们的方法。
###### Java如何创建自定义的不可变类？
问：Java如何创建自定义的不可变类？
- 答："如果需要创建自定义的不可变类，可遵守如下规则。 使用private和final修饰符来修饰该类的Field。 提供带参数构造器，用于根据传入参数来初始化类里的Field。 仅为该类的Field提供getter方法，不要为该类的Field提供setter方法，因为普通方法无法修改final修饰的Field。 如果有必要，重写Object类的hashCode和equals方法。equals方法以关键Field来作为判断两个对象是否相等的标准，除此之外，还应该保证两个用equals方法判断为相等的对象的hashCode也相等。"
###### Java什么时候会用到抽象类？
问：Java什么时候会用到抽象类？
- 答："当编写一个类时，常常会为该类定义一些方法，这些方法用以描述该类的行为方式，那么这些方法都有具体的方法体。但在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确地知道这些子类如何实现这些方法。例如定义了一个Shape类，这个类应该提供一个计算周长的方法calPerimeter()，但不同Shape子类对周长的计算方法是不一样的，即Shape类无法准确地知道其子类计算周长的方法。 可能有人会提出，既然Shape类不知道如何实现calPerimeter()方法，那就干脆不要管它了！这不是一个好思路：假设有一个Shape引用变量，该变量实际上引用到Shape子类的实例，那么这个Shape变量就无法调用calPerimeter()方法，必须将其强制类型转换为其子类类型，才可调用calPerimeter()方法，这就降低了程序的灵活性。 如何既能让Shape类里包含calPerimeter()方法，又无须提供其方法实现呢？使用抽象方法即可满足该要求：抽象方法是只有方法签名，没有方法实现的方法。"
###### Java抽象方法和抽象类有什么规则？
问：Java抽象方法和抽象类有什么规则？
- 答："抽象类必须使用abstract修饰符来修饰，抽象方法也必须使用abstract修饰符来修饰，抽象方法不能有方法体。 抽象类不能被实例化，无法使用new关键字来调用抽象类的构造器创建抽象类的实例。即使抽象类里不包含抽象方法，这个抽象类也不能创建实例。 抽象类可以包含Field、方法（普通方法和抽象方法都可以）、构造器、初始化块、内部类、枚举类6种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。 含有抽象方法的类（包括直接定义了一个抽象方法；继承了一个抽象父类，但没有完全实现父类包含的抽象方法，以及实现了一个接口，但没有完全实现接口包含的抽象方法3种情况）只能被定义成抽象类。"
###### Java抽象类有什么用处?
问：Java抽象类有什么用处?
- 答：抽象类不能创建实例，只能当成父类来被继承。从语义的角度来看，抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其子类的模板，从而避免了子类设计的随意性。抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会大致保留抽象类的行为方式。如果编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，这就是一种模板模式，模板模式也是十分常见且简单的设计模式之一。
###### Java接口和抽象类之间有什么异同？
问：Java接口和抽象类之间有什么异同？
- 答："接口和抽象类很像，它们都具有如下特征。 接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。但接口和抽象类之间的差别非常大，这种差别主要体现在二者设计目的上。下面具体分析二者的差别。接口作为系统与外界交互的窗口，接口体现的是一种规范。对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务（以方法的形式来提供）；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务（就是如何来调用方法）。当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。从某种程度上来看，接口类似于整个系统的“总纲”，它制定了系统各模块应该遵循的标准，因此一个系统中的接口不应该经常改变。一旦接口被改变，对整个系统甚至其他系统的影响将是辐射式的，导致系统中大部分类都需要改写。抽象类则不一样，抽象类作为系统中多个子类的共同父类，它所体现的是一种模板式设计。抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能（那些已经提供实现的方法），但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。"
###### Java为什么要倡导面向接口编程？
问：Java为什么要倡导面向接口编程？
- 答：接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这种原则，很多软件架构设计理论都倡导“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。下面介绍两种常用场景来示范面向接口编程的优势。
###### Java非静态内部类对象和外部类对象的关系是怎样的？
问：Java非静态内部类对象和外部类对象的关系是怎样的？
- 答：非静态内部类对象必须寄存在外部类对象里，而外部类对象则不必一定有非静态内部类对象寄存其中。简单地说，如果存在一个非静态内部类对象，则一定存在一个被它寄存的外部类对象。但外部类对象存在时，外部类对象里不一定寄存了非静态内部类对象。因此外部类对象访问非静态内部类成员时，可能非静态普通内部类对象根本不存在！而非静态内部类对象访问外部类成员时，外部类对象一定存在。
###### 为什么Java静态内部类的实例方法也不能访问外部类的实例属性呢？
问：为什么Java静态内部类的实例方法也不能访问外部类的实例属性呢？
- 答：因为静态内部类是外部类的类相关，而不是外部类的对象相关的。也就是说，静态内部类对象不是寄存在外部类对象里的，而是寄存在外部类的类本身中。当静态内部类对象存在时，并不存在一个被它寄存的外部类对象，静态内部类对象里只有外部类的类引用，没有持有外部类对象的引用。如果允许静态内部类的实例方法访问外部类的实例成员，但找不到被寄存的外部类对象，这将引起错误。
###### Java接口里是否能定义内部接口？
问：Java接口里是否能定义内部接口？
- 答：可以的。接口里的内部接口是接口的成员，因此系统默认添加public static两个修饰符。如果定义接口里的内部接口时指定访问控制符，则只能使用public修饰符。当然，定义接口里的内部接口的意义不大，因为接口的作用是定义一个公共规范（暴露出来供大家使用），如果把这个接口定义成一个内部接口，那么意义何在呢？至少我在开发过程中很少见到这种应用场景。
###### Java中既然内部类是外部类的成员，那么是否可以为外部类定义子类，在子类中再定义一个内部类来重写其父
问：Java中既然内部类是外部类的成员，那么是否可以为外部类定义子类，在子类中再定义一个内部类来重写其父类中的内部类？
- 答：不可以！从上面知识可以看出，内部类的类名不再是简单地由内部类的类名组成，它实际上还把外部类的类名作为一个命名空间，作为内部类类名的限制。因此子类中的内部类和父类中的内部类不可能完全同名，即使二者所包含的内部类的类名相同，但因为它们所处的外部类空间不同，所以它们不可能完全同名，也就不可能重写。
###### Java如何手动实现枚举类？
问：Java如何手动实现枚举类？
- 答："通过private将构造器隐藏起来。 把这个类的所有可能实例都使用public static final修饰的类变量来保存。 如果有必要，可以提供一些静态方法，允许其他程序根据特定参数来获取与之匹配的实例。"
###### 枚举类与普通类有什么区别？
问：枚举类与普通类有什么区别？
- 答："枚举类可以实现一个或多个接口，使用enum定义的枚举类默认继承了java.lang.Enum类，而不是继承Object类。其中java.lang.Enum类实现了java.lang.Serializable和java.lang. Comparable两个接口。 使用enum定义、非抽象的枚举类默认会使用final修饰，因此枚举类不能派生子类。 枚举类的构造器只能使用private访问控制符，如果省略了构造器的访问控制符，则默认使用private修饰；如果强制指定访问控制符，则只能指定private修饰符。 枚举类的所有实例必须在枚举类的第一行显式列出，否则这个枚举类永远都不能产生实例。列出这些实例时，系统会自动添加public static final修饰，无须程序员显式添加。"
###### java.lang.Enum类中提供了哪几个方法？
问：java.lang.Enum类中提供了哪几个方法？
- 答："int compareTo(E o)：该方法用于与指定枚举对象比较顺序，同一个枚举实例只能与相同类型的枚举实例进行比较。如果该枚举对象位于指定枚举对象之后，则返回正整数；如果该枚举对象位于指定枚举对象之前，则返回负整数，否则返回零。 String name()：返回此枚举实例的名称，这个名称就是定义枚举类时列出的所有枚举值之一。与此方法相比，大多数程序员应该优先考虑使用toString()方法，因为toString()方法返回更加用户友好的名称。 int ordinal()：返回枚举值在枚举类中的索引值（就是枚举值在枚举声明中的位置，第一个枚举值的索引值为零）。 String toString()：返回枚举常量的名称，与name方法相似，但toString()方法更常用。 public static<T extends Enum
 
  >T valueOf(Class
  
   enumType,String name)：这是一个静态方法，用于返回指定枚举类中指定名称的枚举值。名称必须与在该枚举类中声明枚举值时所用的标识符完全匹配，不允许使用额外的空白字符。"
###### Java枚举类不是用final修饰了吗？怎么还能派生子类呢？
问：Java枚举类不是用final修饰了吗？怎么还能派生子类呢？
- 答：并不是所有的枚举类都使用了final修饰！非抽象的枚举类才默认使用final修饰。对于一个抽象的枚举类而言——只要它包含了抽象方法，它就是抽象枚举类，系统会默认使用abstract修饰，而不是使用final修饰。
###### Java垃圾回收机制具有什么特征？
问：Java垃圾回收机制具有什么特征？
- 答："垃圾回收机制只负责回收堆内存中的对象，不会回收任何物理资源（例如数据库连接、网络IO等资源）。 程序无法精确控制垃圾回收的运行，垃圾回收会在合适的时候进行。当对象永久性地失去引用后，系统就会在合适的时候回收它所占的内存。 在垃圾回收机制回收任何对象之前，总会先调用它的finalize()方法，该方法可能使该对象重新复活（让一个引用变量重新引用该对象），从而导致垃圾回收机制取消回收。"
- 答：浅谈java的垃圾回收机制的特点: 
1.垃圾回收机制的目标是回收无用对象的内存空间（记住：不是对象），这些内存空间是JVM堆内存的内存空间。垃圾回收只回收内存资源，对于那些物理资源，如数据库连接，Socket,I/O流等资源无能无能为力，我们要自己关闭回收。

2.为了加快垃圾回收机制回收那些无用对象所占的内存空间，我们可以讲对象的引用变量置于null（记住：置于null后，垃圾回收机制不会立即执行的）。

3.垃圾回收机制的潜在缺点它的开销会影响性能。Java虚拟机必须跟踪程序中有用的对象才可以确定哪些对象时无用的，并释放那些无用对象所占的内存空间。这个过程要处花费处理器时间的。

4.垃圾回收的不可预知性。我们可以通过Runtime对象的gc()方法或者System.gc()的方法来建议系统进行垃圾回收，但我们不能精确控制垃圾回收机制的运行
###### 当一个Java对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分成哪几种状态？
问：当一个Java对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分成哪几种状态？
- 答："可达状态：当一个对象被创建后，若有一个以上的引用变量引用它，则这个对象在程序中处于可达状态，程序可通过引用变量来调用该对象的Field和方法。 可恢复状态：如果程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。在这种状态下，系统的垃圾回收机制准备回收该对象所占用的内存，在回收该对象之前，系统会调用所有可恢复状态对象的finalize()方法进行资源清理。如果系统在调用finalize()方法时重新让一个引用变量引用该对象，则这个对象会再次变为可达状态；否则该对象将进入不可达状态。 不可达状态：当对象与所有引用变量的关联都被切断，且系统已经调用所有对象的finalize()方法后依然没有使该对象变成可达状态，那么这个对象将永久性地失去引用，最后变成不可达状态。只有当一个对象处于不可达状态时，系统才会真正回收该对象所占有的资源。"
###### Java如何强制系统垃圾回收？
问：Java如何强制系统垃圾回收？
- 答：当一个对象失去引用后，系统何时调用它的finalize()方法对它进行资源清理，何时它可以变成不可达状态，系统何时回收它占有的内存，对于程序完全透明。程序只能控制一个对象不再被任何引用变量引用，不能控制它何时被回收。 
程序可以强制系统进行垃圾回收——这种强制只是通知系统进行垃圾回收，但系统是否进行垃圾回收依然不能确定。大部分时候，程序强制垃圾回收后总是有一些效果： 
方法1：调用System类的gc()静态方法：System.gc() 
方法2：调用Runtime对象的gc()实例方法：Runtime.getRuntime().gc()
- 答："强制系统垃圾回收有如下两个方法。 调用System类的gc()静态方法：System.gc() 调用Runtime对象的gc()实例方法：Runtime.getRuntime().gc()"
- 答：当对象对当前使用这个对象的应用程序变得不可触及的时百候，这个对象就可以被回收了。 
java垃圾回收是有jvm自动执行的，不是人为操作的，所以当不存在对某对度象的任何引用时，该对象就处于被jvm回收的状态，并不是马上予以销毁。 class Animal { public static void main(String[] args) { Animal lion = new Animal(); System.out.println("Main is completed."); } protected void finalize() { System.out.println("Rest in Peace!"); } } 
lion 对象在实例化行后从未被使用过。因此 Java 编译器作为一种优化措施可以直接在实例化行后赋值lion = null。因此，即使在 SOP 输出知之前， finalize 函数也能够打印出 'Rest in Peace!'。不能证明这确定会发生，因为它依赖JVM的实现方式和运行时使用的内存。如果编译器看到该实例在未来再也不道会被引用，能够选择并提早释放实例空间。
###### Java finalize()方法具有什么特点？
问：Java finalize()方法具有什么特点？
- 答：finalize方法是Object提供的的实例方法，使用规则如下： 
当对象不再被任何对象引用时，GC会调用该对象的finalize()方法 
finalize()是Object的方法，子类可以覆盖这个方法来做一些系统资源的释放或者数据的清理 
可以在finalize()让这个对象再次被引用，避免被GC回收；7a686964616f31333366306437但是最常用的目的还是做cleanup 
Java不保证这个finalize()一定被执行；但是保证调用finalize的线程没有持有任何user-visible同步锁。 
在finalize里面抛出的异常会被忽略，同时方法终止。 
当finalize被调用之后，JVM会再一次检测这个对象是否能被存活的线程访问得到，如果不是，则清除该对象。也就是finalize只能被调用一次；也就是说，覆盖了finalize方法的对象需要经过两个GC周期才能被清除。
- 答："finalize()方法具有如下4个特点。 永远不要主动调用某个对象的finalize()方法，该方法应交给垃圾回收机制调用。 finalize()方法何时被调用，是否被调用具有不确定性，不要把finalize()方法当成一定会被执行的方法。 当JVM执行可恢复对象的finalize()方法时，可能使该对象或系统中其他对象重新变成可达状态。 当JVM执行finalize()方法时出现异常时，垃圾回收机制不会报告异常，程序继续执行。"
###### Java程序引用变量引用该对象有几种引用方式？
问：Java程序引用变量引用该对象有几种引用方式？
- 答："Java语言对对象的引用有如下4种方式。 1.强引用（StrongReference）这是Java程序中最常见的引用方式。程序创建一个对象，并把这个对象赋给一个引用变量，程序通过该引用变量来操作实际的对象，前面介绍的对象和数组都采用了这种强引用的方式。当一个对象被一个或一个以上的引用变量所引用时，它处于可达状态，不可能被系统垃圾回收机制回收。 2.软引用（SoftReference）软引用需要通过SoftReference类来实现，当一个对象只有软引用时，它有可能被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象；当系统内存空间不足时，系统可能会回收它。软引用通常用于对内存敏感的程序中。 3.弱引用（WeakReference）弱引用通过WeakReference类实现，弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收——正如那些失去引用的对象一样，必须等到系统垃圾回收机制运行时才会被回收。 4.虚引用（PhantomReference）虚引用通过PhantomReference类实现，虚引用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。如果一个对象只有一个虚引用时，那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列（ReferenceQueue）联合使用。"
###### Java使用JAR文件有什么好处？
问：Java使用JAR文件有什么好处？
- 答："使用JAR文件有以下好处。 安全。能够对JAR文件进行数字签名，只让能够识别数字签名的用户使用里面的东西。 加快下载速度。在网上使用Applet时，如果存在多个文件而不打包，为了能够把每个文件都下载到客户端，需要为每个文件单独建立一个HTTP连接，这是非常耗时的工作。将这些文件压缩成一个JAR包，只要建立一次HTTP连接就能够一次下载所有的文件。 压缩。使文件变小，JAR的压缩机制和ZIP完全相同。 包封装。能够让JAR包里面的文件依赖于统一版本的类文件。 可移植性。JAR包作为内嵌在Java平台内部处理的标准，能够在各种平台上直接使用。"
###### Java怎么运行jar包？
问：Java怎么运行jar包？
- 答：在开始按钮中输入cmd出现如图所示的情况，然后按下enter打开cmd窗口。 
 首先你的电脑要配好了java环境。这是你能打开的前提。如果你已配好，接下来进入到你所要打开的jar文件度所在的目录，比如我现在在desktop上，也就是桌面上，我知先要运行cd 
 点击enter我们就进入了desktop中。然后，再输道入如下命令就可以成功的打开一个jar文件的，输入的命令为java -jar 后面再加上你的jar文件的名字。 
 点击enter就可以打开你的jar文件了，不过打开要一点时间，看文件的大小了，要耐心等待一下哦。
- 答："运行JAR包有两种方式。 使用java命令，使用java运行时的语法是：java-jar test.jar。 使用javaw命令，使用javaw运行时的语法是：javaw test.jar。"
###### Java集合可分为哪几种体系？
问：Java集合可分为哪几种体系？
- 答：
```
集合类是放在java.util.*；这个包里。集合类存放的都是对象的引用，而非对象本身，为了说起来方便些，我们称集合中的对象就是指集合中对象的引用（reference)。引用的概念大家不会忘了吧，在前边我们讲数据类型时讲的。 集合类型主要有3种：set(集）、list(列表）、map(映射)和Queue（队列）。//队列为jdk5中的加上的 
(1) Set 
集（set）是最简单的一种集合，它的对象不按特定方式排序，只是简单的把对象加入集合中，就像往口袋里放东西。对集中成员的访问和操作是通过集中对象的引用进行的，所以集中不能有重复对象。我们知道数学上的集合也是Set这个，集合里面一定是没有重复的元素的。 
（2）List 
列表（List）的主要特征是其对象以线性方式存储，没有特定顺序，只有一个开头和一个结尾，当然，它与根本没有顺序的Set是不同的。它是链表嘛，一条链肯定有顺序这个顺序就不一定了。 
（3）Map 
映射（Map），这个在java里不是地图的意思，其实地图也是映射哈。它里面的东西是键－值对（key-value）出现的，键值对是什么呢？举个例子，比如我们查字典，用部首查字法。目录那个字就是键，这个字的解释就是值。键和值成对出现。这样说可以理解吧。这也是很常用的数据结构哦。 
（4）Queue 
在jdk5.0以前，通常的实636f7079e799bee5baa631333238656133现方式是使用java.util.List集合来模仿Queue。Queue的概念通过把对象添加（称为enqueuing的操作）到List的尾部（即Queue的后部）并通过从List的头部（即Queue的前部）提取对象而从 List中移除（称为dequeuing的操作）来模拟。你需要执行先进先出的动作时可以直接使用Queue接口就可以了。 
这4个东西，有时候功能还不太完善，需要有些子类继承它的特性。Set的子接口有TreeSet,SortedSet，List的有ArrayList等，Map里有HashMap,HashTable等，Queue里面有BlockingQueue等。我们来看看例子吧： 
实践： Set举例 
import java.util.*; 
public class SetExample {<!-- --> 
public static void main(String[] args) {<!-- --> 
Set set = new HashSet(); //HashSet是Set的子接口 
set.add("one"); 
set.add("second"); 
set.add("3rd"); 
set.add(new Integer(4)); 
set.add(new Float( 5.0F )); 
set.add("second"); 
set.add(new Integer(4)); 
System.out.println(set); 
}} 
List举例： 
import java.util.*; 
public class ListExample {<!-- --> 
public static void main(String[] args) {<!-- --> 
List list = new ArrayList(); 
list.add("one"); 
list.add("second"); 
list.add("3rd"); 
list.add(new Integer(4)); 
list.add(new Float( 5.0F )); 
list.add("second"); 
list.add(new Integer(4)); 
System.out.println(list); 
}} 
Map举例 
import java.util.Map; 
import java.util.HashMap; 
import java.util.Iterator; 
import java.io.FileReader; 
public class MapExample {<!-- --> 
public static void main(String[] args) throws java.io.FileNotFoundException {<!-- --> 
Map word_count_map = new HashMap(); 
FileReader reader = new FileReader(args[0]); 
Iterator words = new WordStreamIterator(reader); 
while ( words.hasNext() ) {<!-- --> 
String word = (String) words.next(); 
String word_lowercase = word.toLowerCase(); 
Integer frequency = (Integer)word_count_map.get(word_lowercase); 
if ( frequency == null ) {<!-- --> 
frequency = new Integer(1); 
} else {<!-- --> 
int value = frequency.intValue(); 
frequency = new Integer(value + 1);} 
word_count_map.put(word_lowercase, frequency); 
} 
System.out.println(word_count_map); 
}} 
Queue举例： 
import java.io.IOException; 
import java.io.PrintStream; 
import java.util.LinkedList; 
import java.util.Queue; 
public class QueueTester {<!-- --> 
public Queue
 
   q; //发现了一个奇怪的语法，这个尖括号是泛型声明
  
public QueueTester() {q = new LinkedList
 
  ();}
  
public void testFIFO(PrintStream out) throws IOException {<!-- --> 
q.add("First"); 
q.add("Second"); 
q.add("Third"); 
Object o; 
while ((o = q.poll()) != null) {<!-- --> 
out.println(o);}} 
public static void main(String[] args) {<!-- --> 
QueueTester tester = new QueueTester(); 
try { tester.testFIFO(System.out); 
} catch (IOException e) {<!-- --> 
e.printStackTrace(); } }}
```
- 答：Java集合大致可分为Set、List和Map三种体系，其中Set代表无序、不可重复的集合；List代表有序、重复的集合；而Map则代表具有映射关系的集合。从Java 5以后，Java又增加了Queue体系集合，代表一种队列集合实现。
###### Java Collection接口里定义了哪些操作集合元素的方法？
问：Java Collection接口里定义了哪些操作集合元素的方法？
- 答："Collection接口里定义了如下操作集合元素的方法。 boolean add(Object o)：该方法用于向集合里添加一个元素。如果集合对象被添加操作改变了，则返回true。 boolean addAll(Collection c)：该方法把集合c里的所有元素添加到指定集合里。如果集合对象被添加操作改变了，则返回true。 void clear()：清除集合里的所有元素，将集合长度变为0。 boolean contains(Object o)：返回集合里是否包含指定元素。 boolean containsAll(Collection c)：返回集合里是否包含集合c里的所有元素。 boolean isEmpty()：返回集合是否为空。当集合长度为0时返回true，否则返回false。 Iterator iterator()：返回一个Iterator对象，用于遍历集合里的元素。 boolean remove(Object o)：删除集合中的指定元素o，当集合中包含了一个或多个元素o时，这些元素将被删除，该方法将返回true。 boolean removeAll(Collection c)：从集合中删除集合c里包含的所有元素（相当于用调用该方法的集合减集合c），如果删除了一个或一个以上的元素，则该方法返回true。 boolean retainAll(Collection c)：从集合中删除集合c里不包含的元素（相当于把调用该方法的集合变成该集合和集合c的交集），如果该操作改变了调用该方法的集合，则该方法返回true。 int size()：该方法返回集合里元素的个数。 Object[]toArray()：该方法把集合转换成一个数组，所有的集合元素变成对应的数组元素。"
- 答：Collection 总接口 
--| List 特征 有序 可重复 
----| ArrayList 底层维护的是一个Object类型的数组，如果使用无参构造方法创建ArrayList集合，默认的容量为10 
​ 用带有参数的构造方法，创建ArrayList集合，传入的initCapacity是多少，容量就是多少 
​ 特征: 增删慢 查找快 
​ newCapacity = oldCapacity + (oldCapacity >> 1) 二进制位运算 
----| LinkedList 底层维护的是一个双向链表 特征是增删快 查找慢 
----| Vector 线程安全的ArrayList 和ArrayList基本相同，JDK1.0的古老产物。效率低于ArrayList 
--| Set 特征 无序 不可重复 
----| HashSet 底层维护是一个哈希表，存储效率极高 
​ 一个自定义类对象放入到HashSet中，需要经历如下过程： 
​ 通过当前类对象的HashCode，获取到当前类对象的哈希值，进行移位运算，计算出当前元素应该保存到哈希表中的位置。 
​ 情况1: 当前位置没有元素，直接放入 
​ 情况2: 当前位置已经存在其他元素。需要调用该元素的equals方法，进行比较，如果比较结果为两个元素不同，能够放入，两个元素相同，不能放入。 
----| TreeSet 树形结构的Set集合 
​ 能够放入TreeSet中的元素必须有自然顺序，或者提供【比较规则】 
​ 一个自定义类对象，想要放入到TreeSet集合中，有两种方式 
​ 1. 当前类【遵从】Comparable接口，实现compareTo(Object o)方法 
​ 2. 实现一个自定义的比较器【遵从】Comparator接口，实现compare(Object o1, Object o2)方法 
Collection中的方法 
//添加方法： add(Object o) //添加指定元素 addAll(Collection c) //添加指定集合 //删除方法： remove(Object o) //删除指定元素 removeAll(Collection c) //输出两个集合的交集 retainAll(Collection c) //保留两个集合的交集 clear() //清空集合 //查询方法： size() //集合中的有效元素个数 toArray() //将集合中的元素转换成Object类型数组 //判断方法： isEmpty() //判断是否为空 equals(Object o) //判断是否与指定元素相同 contains(Object o) //判断是否包含指定元素 containsAll(Collection c) //判断是否包含指定集合 
List中的方法 
//添加方法： add(int index, Object o) //向指定位置添加元素 addAll(int index, Collection c) //向指定位置添加集合 //删除方法 remove(int index) //删除指定元素 //查询方法： get(int index) //获取指定位置的元素 indexOf(Object o) //获取指定元素的位置 lastIndexOf(Object o) //获取指定元素最后一次出现的位置 //修改方法： subList(int fromIndex, int toIndex) //截取子集合从fromIndex到toIndex，要头不要尾 set(int index, Object o) //修改指定位置的元素 
ArrayList中特有的方法 
ensureCapacity(int minCapactiy) //判断当前数组中的元素个数是否大于指定的minCapacity trimToSize() //修改数组容量为当前数组有效元素个数 
LinkedList中特有的方法 
//查询方法： getFirst() //获取集合中的第一个元素 getLast() //获取集合中的最后一个元素 //添加方法： addFirst(Object o) //在集合的第一个位置添加指定元素 addLast(Object o) //在集合的最后一个位置添加指定元素 //删除方法： removeFirst() //删除集合中的第一个元素 removeLast() //删除集合中的最后一个元素 
Collection中的迭代器Iterator方法 
Iterator iterator(); //迭代器构造方法 boolean hasNext() //判断是否有下一个元素 Object next() //获取当前元素 void remove() //删除通过next()获取的元素,在next()之后使用，不可以单独使用 
List中的迭代器 ListIterator方法 
ListIterator listIterator(); //迭代器构造函数 boolean hasNext() //判断是否有下一个元素 boolean hasPrevious() //判断是否有上一个元素 Object next() //获取当前元素 Object previous() //获取上一个元素 void remove() //删除通过next()获取的元素,在next()之后使用，不可以单独使用 add(Object o) //添加指定元素 set(Object o) //修改指定元素 int nextIndex() //获取当前元素所在位置
###### Java Iterator接口隐藏了各种Collection实现类的底层细节，向应用程序提供了遍历C
问：Java Iterator接口隐藏了各种Collection实现类的底层细节，向应用程序提供了遍历Collection集合元素的统一编程接口。Iterator接口里定义了哪些方法？
- 答："Iterator接口里定义了如下三个方法。 boolean hasNext()：如果被迭代的集合元素还没有被遍历，则返回true。 Object next()：返回集合里的下一个元素。 void remove()：删除集合里上一次next方法返回的元素。"
###### Java Iterator能单独使用吗？
问：Java Iterator能单独使用吗？
- 答：Iterator仅用于遍历集合，Iterator本身并不提供盛装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。没有集合的Iterator仿佛无本之木，没有存在的价值。Iterator必须依附于Collection对象，若有一个Iterator对象，则必然有一个与之关联的Collection对象。Iterator提供了两个方法来迭代访问Collection集合里的元素，并可通过remove()方法来删除集合中上一次next()方法返回的集合元素。
###### Java Iterator迭代器采用的是什么机制？
问：Java Iterator迭代器采用的是什么机制？
- 答：Iterator迭代器采用的是快速失败（fail-fast）机制，一旦在迭代过程中检测到该集合已经被修改（通常是程序中的其他线程修改），程序立即引发ConcurrentModificationException异常，而不是显示修改后的结果，这样可以避免共享资源而引发的潜在问题。
###### 除了可以使用Iterator接口迭代访问Collection集合里的元素之外，还有其他方式吗？
问：除了可以使用Iterator接口迭代访问Collection集合里的元素之外，还有其他方式吗？
- 答：除了可以使用Iterator接口迭代访问Collection集合里的元素之外，使用Java 5提供的foreach循环迭代访问集合元素更加便捷，使用foreach循环来迭代访问Collection集合里的元素更加简洁，这正是JDK 1.5的foreach循环带来的优势。与使用Iterator接口迭代访问集合元素类似的是，foreach循环中的迭代变量也不是集合元素本身，系统只是依次把集合元素的值赋给迭代变量，因此在foreach循环中修改迭代变量的值也没有任何实际意义。
###### Java Set集合怎么判断两个对象是否相同？
问：Java Set集合怎么判断两个对象是否相同？
- 答：Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象；反之，只要两个对象用equals方法比较返回false，Set就会接受这两个对象（甚至这两个对象是同一个对象，Set也可把它们当成两个对象处理，在后面程序中可以看到这种极端的情况）。
###### Java HashSet具有什么特点？
问：Java HashSet具有什么特点？
- 答："HashSet具有以下特点。 不能保证元素的排列顺序，顺序有可能发生变化。 HashSet不是同步的，如果多个线程同时访问一个HashSet，假设有两个或者两个以上线程同时修改了HashSet集合时，则必须通过代码来保证其同步。 集合元素值可以是null。"
###### Java HashSet集合怎么判断两个对象是否相同？
问：Java HashSet集合怎么判断两个对象是否相同？
- 答：当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该HashCode值决定该对象在HashSet中的存储位置。如果有两个元素通过equals()方法比较返回true，但它们的hashCode()方法返回值不相等，HashSet将会把它们存储在不同的位置，依然可以添加成功。简单地说，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法返回值也相等。
###### Java hashCode()方法对于HashSet是不是十分重要？
问：Java hashCode()方法对于HashSet是不是十分重要？
- 答：我们先要理解hash（也被翻译为哈希、散列）算法的功能——它能保证通过一个对象快速查找到另一个对象。hash算法的价值在于速度，它可以保证查询被快速执行。当需要查询集合中某个元素时，hash算法可以直接根据该元素的值计算出该元素的存储位置，从而可以让程序快速定位该元素。为了理解这个概念，我们先看数组（数组是所有能存储一组元素里最快的数据结构）。数组可以包含多个元素，每个元素也有索引，如果需要访问某个数组元素，只需提供该元素的索引，该索引即指出了该元素在数组内存区里的存储位置。表面上看起来，HashSet集合里的元素都没有索引，实际上当程序向HashSet集合中添加元素时，HashSet会根据该元素的hashCode值来计算它的存储位置——也就是说，每个元素的hashCode值就可以决定它的存储“索引”。为什么不直接使用数组，还需要使用HashSet呢？因为数组元素的索引是连续的，而且数组的长度是固定的，无法自由增加数组的长度。而HashSet就不一样了，HashSet采用每个元素的hashCode值来计算其索引，从而可以自由增加HashSet的长度，并可以根据元素的hashCode值来访问元素。因此，当从HashSet中访问元素时，HashSet先计算该元素的hashCode值（也就是调用该对象的hashCode()方法的返回值），然后直接到该hashCode值对应的位置去取出该元素——这就是HashSet速度很快的
###### Java重写hashCode()方法的基本规则有哪些？
问：Java重写hashCode()方法的基本规则有哪些？
- 答："重写hashCode()方法的基本规则。 在程序运行过程中，同一个对象多次调用hashCode()方法应该返回相同的值。 当两个对象通过equals()方法比较返回true时，这两个对象的hashCode()方法应返回相等的值。 对象中用作equals()方法比较标准的Field，都应该用来计算hashCode值。定该对象在HashSet中的存储位置。"
###### Java HashSet和LinkedHashSet有啥区别？
问：Java HashSet和LinkedHashSet有啥区别？
- 答：HashSet还有一个子类LinkedHashSet，LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。也就是说，当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但在迭代访问Set里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。
###### Java中与HashSet集合相比，TreeSet还提供了哪几个额外的方法？
问：Java中与HashSet集合相比，TreeSet还提供了哪几个额外的方法？
- 答："TreeSet还提供了如下几个额外的方法。 Comparator comparator()：如果TreeSet采用了定制排序，则该方法返回定制排序所使用的Comparator；如果TreeSet采用了自然排序，则返回null。 Object first()：返回集合中的第一个元素。 Object last()：返回集合中的最后一个元素。 Object lower(Object e)：返回集合中位于指定元素之前的元素（即小于指定元素的最大元素，参考元素不需要是TreeSet集合里的元素）。 Object higher (Object e)：返回集合中位于指定元素之后的元素（即大于指定元素的最小元素，参考元素不需要是TreeSet集合里的元素）。 SortedSet subSet(fromElement,toElement)：返回此Set的子集合，范围从fromElement（包含）到toElement（不包含）。 SortedSet headSet(toElement)：返回此Set的子集，由小于toElement的元素组成。 SortedSet tailSet(fromElement)：返回此Set的子集，由大于或等于fromElement的元素组成。"
###### Java TreeSet支持哪种排序方法？
问：Java TreeSet支持哪种排序方法？
- 答："TreeSet采用红黑树的数据结构来存储集合元素。TreeSet支持两种排序方法：自然排序和定制排序。在默认情况下，TreeSet采用自然排序。 1.自然排序TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排列，这种方式就是自然排序。 2.定制排序TreeSet的自然排序是根据集合元素的大小，TreeSet将它们以升序排列。如果需要实现定制排序，例如以降序排列，则可以通过Comparator接口的帮助。该接口里包含一个int compare(To1,T o2)方法，该方法用于比较o1和o2的大小：如果该方法返回正整数，则表明o1大于o2；如果该方法返回0，则表明o1等于o2；如果该方法返回负整数，则表明o1小于o2。"
###### Java EnumSet在内部以什么形式存储？
问：Java EnumSet在内部以什么形式存储？
- 答：EnumSet在内部以位向量的形式存储，这种存储形式非常紧凑、高效，因此EnumSet对象占用内存很小，而且运行效率很好。尤其是进行批量操作（如调用containsAll和retainAll方法）时，如果其参数也是EnumSet集合，则该批量操作的执行速度也非常快。
###### Java EnumSet集合允许加入null元素吗？
问：Java EnumSet集合允许加入null元素吗？
- 答：EnumSet集合不允许加入null元素，如果试图插入null元素，EnumSet将抛出NullPointerException异常。如果只是想判断EnumSet是否包含null元素或试图删除null元素都不会抛出异常，只是删除操作将返回false，因为没有任何null元素被删除。
###### Java EnumSet类怎么创建该类的实例？
问：Java EnumSet类怎么创建该类的实例？
- 答："EnumSet类没有暴露任何构造器来创建该类的实例，程序应该通过它提供的static方法来创建EnumSet对象。EnumSet类它提供了如下常用的static方法来创建EnumSet对象。 static EnumSet allOf(Class elementType)：创建一个包含指定枚举类里所有枚举值的EnumSet集合。 static EnumSet complementOf(EnumSet s)：创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合，新EnumSet集合包含原EnumSet集合所不包含的、此枚举类剩下的枚举值（即新EnumSet集合和原EnumSet集合的集合元素加起来就是该枚举类的所有枚举值）。 static EnumSet copyOf(Collection c)：使用一个普通集合来创建EnumSet集合。 static EnumSet copyOf(EnumSet s)：创建一个与指定EnumSet具有相同元素类型、相同集合元素的EnumSet集合。 static EnumSet noneOf(Class elementType)：创建一个元素类型为指定枚举类型的空EnumSet。 static EnumSet of(E first,E...rest)：创建一个包含一个或多个枚举值的EnumSet集合，传入的多个枚举值必须属于同一个枚举类。 static EnumSet range(E from,E to)：创建一个包含从from枚举值到to枚举值范围内所有枚举值的EnumSet集合。"
###### Java的HashSet、TreeSet和EnumSet性能之间有什么区别？
问：Java的HashSet、TreeSet和EnumSet性能之间有什么区别？
- 答：HashSet和TreeSet是Set的两个典型实现，到底如何选择HashSet和TreeSet呢？HashSet的性能总是比TreeSet好（特别是最常用的添加、查询元素等操作），因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet。HashSet还有一个子类：LinkedHashSet，对于普通的插入、删除操作，LinkedHashSet比HashSet要略微慢一点，这是由维护链表所带来的额外开销造成的；不过，因为有了链表，遍历LinkedHashSet会更快。EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素。必须指出的是，Set的三个实现类HashSet、TreeSet和EnumSet都是线程不安全的。如果有多个线程同时访问一个Set集合，并且有超过一个线程修改了该Set集合，则必须手动保证该Set集合的同步性。通常可以通过Collections工具类的synchronizedSortedSet方法来“包装”该Set集合。此操作最好在创建时进行，以防止对Set集合的意外非同步访问。
###### List作为Collection接口的子接口,增加了哪些根据索引来操作集合元素的方法？
问：List作为Collection接口的子接口,增加了哪些根据索引来操作集合元素的方法？
- 答："List作为Collection接口的子接口，当然可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List集合里增加了一些根据索引来操作集合元素的方法。 void add(int index,Object element)：将元素element插入到List集合的index处。 boolean addAll(int index,Collection c)：将集合c所包含的所有元素都插入到List集合的index处。 Object get(int index)：返回集合index索引处的元素。 int indexOf(Object o)：返回对象o在List集合中第一次出现的位置索引。 int lastIndexOf(Object o)：返回对象o在List集合中最后一次出现的位置索引。 Object remove(int index)：删除并返回index索引处的元素。 Object set(int index,Object element)：将index索引处的元素替换成element对象，返回新元素。 List subList(int fromIndex,int toIndex)：返回从索引fromIndex（包含）到索引toIndex（不包含）处所有集合元素组成的子集合。"
###### ListIterator与普通的Iterator进行对比有什么不同？
问：ListIterator与普通的Iterator进行对比有什么不同？
- 答：拿ListIterator与普通的Iterator进行对比，不难发现ListIterator增加了向前迭代的功能（Iterator只能向后迭代），而且ListIterator还可通过add方法向List集合中添加元素（Iterator只能删除元素）。
###### Java Queue接口中定义了哪些方法？
问：Java Queue接口中定义了哪些方法？
- 答："Queue接口中定义了如下几个方法。 void add(Object e)：将指定元素加入此队列的尾部。 Object element()：获取队列头部的元素，但是不删除该元素。 boolean offer(Object e)：将指定元素加入此队列的尾部。当使用有容量限制的队列时，此方法通常比add(Object e)方法更好。 Object peek()：获取队列头部的元素，但是不删除该元素。如果此队列为空，则返回null。 Object poll()：获取队列头部的元素，并删除该元素。如果此队列为空，则返回null。 Object remove()：获取队列头部的元素，并删除该元素。"
###### Java中Map和Set、List有啥关系？
问：Java中Map和Set、List有啥关系？
- 答：三种不同的数据结构实现对象类，可以看下相关的知识
- 答："如果把Map里的所有key放在一起来看，它们就组成了一个Set集合（所有的key没有顺序，key与key之间不能重复），实际上Map确实包含了一个keySet()方法，用于返回Map里所有key组成的Set集合。不仅如此，Map里key集和Set集合里元素的存储形式也很像，Map子类和Set子类在名字上也惊人地相似，比如Set接口下有HashSet、LinkedHashSet、SortedSe（t接口）、TreeSet、EnumSet等子接口和实现类，而Map接口下则有HashMap、LinkedHashMap、SortedMap（接口）、TreeMap、EnumMap等子接口和实现类。正如它们的名字所暗示的，Map的这些实现类和子接口中key集的存储形式和对应Set集合中元素的存储形式完全相同。 如果把Map里的所有value放在一起来看，它们又非常类似于一个List：元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中的索引不再使用整数值，而是以另一个对象作为索引。如果需要从List集合中取出元素，则需要提供该元素的数字索引；如果需要从Map中取出元素，则需要提供该元素的key索引。因此，Map有时也被称为字典，或关联数组。"
###### Map接口中定义了哪些常用的方法？
问：Map接口中定义了哪些常用的方法？
- 答："Map接口中定义了如下常用的方法。 void clear()：删除该Map对象中的所有key-value对。 boolean containsKey(Object key)：查询Map中是否包含指定的key，如果包含则返回true。 boolean containsValue(Object value)：查询Map中是否包含一个或多个value，如果包含则返回true。 Set entrySet()：返回Map中包含的key-value对所组成的Set集合，每个集合元素都是Map.Entry（Entry是Map的内部类）对象。 Object get(Object key)：返回指定key所对应的value；如果此Map中不包含该key，则返回null。 boolean isEmpty()：查询该Map是否为空（即不包含任何key-value对），如果为空则返回true。 Set keySet()：返回该Map中所有key组成的Set集合。 Object put(Object key,Object value)：添加一个key-value对，如果当前Map中已有一个与该key相等的key-value对，则新的key-value对会覆盖原来的key-value对。 void putAll(Map m)：将指定Map中的key-value对复制到本Map中。 Object remove(Object key)：删除指定key所对应的key-value对，返回被删除key所关联的value，如果该key不存在，则返回null。 int size()：返回该Map里的key-value对的个数。 Collection values()：返回该Map里所有value组成的Collection。"
###### Map中包括一个内部类Entry有何作用？
问：Map中包括一个内部类Entry有何作用？
- 答："该类封装了一个key-value对。Entry包含如下三个方法。 Object getKey()：返回该Entry里包含的key值。 Object getValue()：返回该Entry里包含的value值。 Object setValue(V value)：设置该Entry里包含的value值，并返回新设置的value值。"
###### Java Hashtable和HashMap有什么典型区别？
问：Java Hashtable和HashMap有什么典型区别？
- 答："Hashtable和HashMap存在两点典型区别。 Hashtable是一个线程安全的Map实现，但HashMap是线程不安全的实现，所以HashMap比Hashtable的性能高一点；但如果有多个线程访问同一个Map对象时，使用Hashtable实现类会更好。 Hashtable不允许使用null作为key和value，如果试图把null值放进Hashtable中，将会引发NullPointerException异常；但HashMap可以使用null作为key或value。"
###### HashMap、Hashtable如何判断两个value相等呢？
问：HashMap、Hashtable如何判断两个value相等呢？
- 答：HashMap、Hashtable判断两个value相等的标准更简单：只要两个对象通过equals()方法比较返回true即可。
###### Java LinkedHashMap和HashMap有什么区别？
问：Java LinkedHashMap和HashMap有什么区别？
- 答："LinkedHashMap使用双向链表来维护key-value对的次序（其实只需要考虑key的次序），该链表负责维护Map的迭代顺序，迭代顺序与key-value对的插入顺序保持一致。 LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能；但因为它以链表来维护内部顺序，所以在迭代访问Map里的全部元素时将有较好的性能。"
###### Collections提供了哪几个方法用于对List集合元素进行排序？
问：Collections提供了哪几个方法用于对List集合元素进行排序？
- 答："Collections提供了如下几个方法用于对List集合元素进行排序。 static void reverse(List list)：反转指定List集合中元素的顺序。 static void shuffle(List list)：对List集合元素进行随机排序（shuffle方法模拟了“洗牌”动作）。 static void sort(List list)：根据元素的自然顺序对指定List集合的元素按升序进行排序。 static void sort(List list,Comparator c)：根据指定Comparator产生的顺序对List集合元素进行排序。 static void swap(List list,int i,int j)：将指定List集合中的i处元素和j处元素进行交换。 static void rotate(List list,int distance)：当distance为正数时，将list集合的后distance个元素“整体”移到前面；当distance为负数时，将list集合的前distance个元素“整体”移到后面。该方法不会改变集合的长度。 "
###### Java Collections还提供了哪些用于查找、替换集合元素的常用方法？
问：Java Collections还提供了哪些用于查找、替换集合元素的常用方法？
- 答："Collections还提供了如下用于查找、替换集合元素的常用方法。 static int binarySearch(List list,Object key)：使用二分搜索法搜索指定的List集合，以获得指定对象在List集合中的索引。如果要使该方法可以正常工作，则必须保证List中的元素已经处于有序状态。 static Object max(Collection coll)：根据元素的自然顺序，返回给定集合中的最大元素。 static Object max(Collection coll,Comparator comp)：根据Comparator指定的顺序，返回给定集合中的最大元素。 static Object min(Collection coll)：根据元素的自然顺序，返回给定集合中的最小元素。 static Object min(Collection coll,Comparator comp)：根据Comparator指定的顺序，返回给定集合中的最小元素。 static void fill(List list,Object obj)：使用指定元素obj替换指定List集合中的所有元素。 static int frequency(Collection c,Object o)：返回指定集合中指定元素的出现次数。 static int indexOfSubList(List source,List target)：返回子List对象在父List对象中第一次出现的位置索引；如果父List中没有出现这样的子List，则返回-1。 static int lastIndexOfSubList(List source,List target)：返回子List对象在父List对象中最后一次出现的位置索引；如果父List中没有出现这样的子List，则返回-1。 static boolean replaceAll(List list,Object oldVal,Object newVal)：使用一个新值newVal替换List对象的所有旧值oldVal。"
###### Java Collections类怎么解决并发访问集合的线程安全问题？
问：Java Collections类怎么解决并发访问集合的线程安全问题？
- 答：Collections类中提供了多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。
###### Java Collections怎么设置不可变集合？
问：Java Collections怎么设置不可变集合？
- 答："Collections提供了如下三类方法来返回一个不可变的集合。 emptyXxx()：返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。 singletonXxx()：返回一个只包含指定对象（只有一个或一项元素）的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。 unmodifiableXxx：返回指定集合对象的不可变视图，此处的集合既可以是List，也可以是Set，还可以是Map。"
###### Java中的泛型是指什么？
问：Java中的泛型是指什么？
- 答：所谓泛型，就是允许在定义类、接口、方法时使用类型形参，这个类型形参将在声明变量、创建对象、调用方法时动态地指定（即传入实际的类型参数，也可称为类型实参）。Java 5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参，这就是在前面程序中看到的List
 
  和ArrayList
  
   两种类型。
###### Java过度使用异常会带来什么负面影响？
问：Java过度使用异常会带来什么负面影响？
- 答："过度使用异常主要有两个方面。 把异常和普通错误混淆在一起，不再编写任何错误处理代码，而是以简单地抛出异常来代替所有的错误处理。 使用异常处理来代替流程控制。"
###### Java为何不推荐使用异常处理代替正常的逻辑判断？
问：Java为何不推荐使用异常处理代替正常的逻辑判断？
- 答：当程序检测到用户试图下棋的坐标点已经有棋子时，并没有提供相应的处理，而是简单地抛出了一个异常。这种处理方式虽然简单，但Java运行时接收到这个异常后，还需要进入相应的catch块来捕获该异常，所以运行效率要差一些。而且用户下棋重复这个错误完全是预料的，所以程序完全可以针对该错误提供相应的处理，而不是抛出异常。必须指出：异常处理机制的初衷是将不可预期异常的处理代码和正常的业务逻辑处理代码分离，因此绝不要使用异常处理来代替正常的业务逻辑判断。另外，异常机制的效率比正常的流程控制效率差，所以不要使用异常处理来代替正常的程序流程控制。
###### Java为何不推荐使用过于庞大的try块？
问：Java为何不推荐使用过于庞大的try块？
- 答：在一个try块里放置大量的代码看上去“很简单”，但这种“简单”只是一种假象，只是在编写程序时看上去比较简单。但因为try块里的代码过于庞大，业务过于复杂，就会造成try块中出现异常的可能性大大增加，从而导致分析异常原因的难度也大大增加。而且当try块过于庞大时，就难免在try块后紧跟大量的catch块才可以针对不同的异常提供不同的处理逻辑。同一个try块后紧跟大量的catch块则需要分析它们之间的逻辑关系，反而增加了编程复杂度。正确的做法是，把大块的try块分割成多个可能出现异常的程序段落，并把它们放在单独的try块中，从而分别捕获并处理异常。
###### Java为啥要避免使用Catch All语句？
问：Java为啥要避免使用Catch All语句？
- 答："不可否认，每个程序员都曾经用过这种异常处理方式；但在编写关键程序时就应避免使用这种异常处理方式。这种处理方式有如下两点不足之处。 所有的异常都采用相同的处理方式，这将导致无法对不同的异常分情况处理，如果要分情况处理，则需要在catch块中使用分支语句进行控制，这是得不偿失的做法。 这种捕获方式可能将程序中的错误、Runtime异常等可能导致程序终止的情况全部捕获到，从而“压制”了异常。如果出现了一些“关键”异常，那么此异常也会被“静悄悄”地忽略。实际上，Catch All语句不过是一种通过避免错误处理而加快编程进度的机制，应尽量避免在实际应用中使用这种语句。 "
###### Java为啥不要忽略捕获到的异常？
问：Java为啥不要忽略捕获到的异常？
- 答："不要忽略异常！既然已捕获到异常，那catch块理应做些有用的事情——处理并修复这个错误。catch块整个为空，或者仅仅打印出错信息都是不妥的！catch块为空就是假装不知道甚至瞒天过海，这是最可怕的事情——程序出了错误，所有的人都看不到任何异常，但整个应用可能已经彻底坏了。仅在catch块里打印错误跟踪栈信息稍微好一点，但仅仅比空白多了几行异常信息。通常建议对异常采取适当措施，比如： 处理异常。对异常进行合适的修复，然后绕过异常发生的地方继续执行；或者用别的数据进行计算，以代替期望的方法返回值；或者提示用户重新操作……总之，对于Checked异常，程序应该尽量修复。 重新抛出新异常。把当前运行环境下能做的事情尽量做完，然后进行异常转译，把异常包装成当前层的异常，重新抛出给上层调用者。 在合适的层处理异常。如果当前层不清楚如何处理异常，就不要在当前层使用catch语句来捕获该异常，直接使用throws声明抛出该异常，让上层调用者来负责处理该异常。"
###### Java Annotation用来干嘛的？
问：Java Annotation用来干嘛的？
- 答：从JDK 5开始，Java增加了对元数据（MetaData）的支持，也就是Annotation（注释），这种Annotation与第2章所介绍的注释有一定的区别，也有一定的联系。本章所介绍的Annotation，其实是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用Annotation，程序开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充的信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。
###### Java提供的哪几个基本Annotation？
问：Java提供的哪几个基本Annotation？
- 答："Java提供的4个基本Annotation的用法——使用Annotation时要在其前面增加@符号，并把该Annotation当成一个修饰符使用，用于修饰它支持的程序元素。4个基本的Annotation如下： @Override @Deprecated @SuppressWarnings @SafeVarargs"
###### Java @Override有何作用？
问：Java @Override有何作用？
- 答：@Override就是用来指定方法覆载的，它可以强制一个子类必须覆盖父类的方法。因为@Override的作用是告诉编译器检查这个方法，保证父类要包含一个被该方法重写的方法，否则就会编译出错。@Override主要是帮助我们避免一些低级错误。
###### Java @Deprecated有何作用？
问：Java @Deprecated有何作用？
- 答：@Deprecated用于表示某个程序元素（类、方法等）已过时，当其他程序使用已过时的类、方法时，编译器将会给出警告。
###### Java @SuppressWarnings有何作用？
问：Java @SuppressWarnings有何作用？
- 答：@SuppressWarnings指示被该Annotation修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译器警告。@SuppressWarnings会一直作用于该程序元素的所有子元素，例如，使用@SuppressWarnings修饰某个类取消显示某个编译器警告，同时又修饰该类里的某个方法取消显示另一个编译器警告，那么该方法将会同时取消显示这两个编译器警告。在通常情况下，如果程序中使用没有泛型限制的集合将会引起编译器警告，为了避免这种编译器警告，可以使用@SuppressWarnings修饰。
###### Java @SafeVarargs有何作用？
问：Java @SafeVarargs有何作用？
- 答：抑制程序方法发出“堆污染”警告。
###### Java jdk有哪些元Annotation？
问：Java jdk有哪些元Annotation？
- 答：JDK提供了@Retention，@Target，@Documented，@Inherited四个元注解。
###### Java元注解@Retention怎么使用？
问：Java元注解@Retention怎么使用？
- 答："@Retention只能用于修饰一个Annotation定义，用于指定被修饰的Annotation可以保留多长时间，@Retention包含一个RetentionPolicy类型的value成员变量，所以使用@Retention时必须为该value成员变量指定值。value成员变量的值只能是如下3个。 RetentionPolicy.CLASS：编译器将把Annotation记录在class文件中。当运行Java程序时，JVM不再保留Annotation。这是默认值。 RetentionPolicy.RUNTIME：编译器将把Annotation记录在class文件中。当运行Java程序时，JVM也会保留Annotation，程序可以通过反射获取该Annotation信息。 RetentionPolicy.SOURCE：Annotation只保留在源代码中，编译器直接丢弃这种Annotation。如果需要通过反射获取注释信息，就需要使用value属性值为RetentionPolicy.RUNTIME的@Retention。使用@Retention元数据Annotation可采用如下代码为value指定值 "
###### Java元注解@Target怎么使用？
问：Java元注解@Target怎么使用？
- 答："@Target也只能修饰一个Annotation定义，它用于指定被修饰的Annotation能用于修饰哪些程序单元。@Target元Annotation也包含一个名为value的成员变量，该成员变量的值只能是如下几个。 ElementType.ANNOTATION_TYPE：指定该策略的Annotation只能修饰Annotation。 ElementType.CONSTRUCTOR：指定该策略的Annotation只能修饰构造器。 ElementType.FIELD：指定该策略的Annotation只能修饰成员变量。 ElementType.LOCAL_VARIABLE：指定该策略的Annotation只能修饰局部变量。 ElementType.METHOD：指定该策略的Annotation只能修饰方法定义。 ElementType.PACKAGE：指定该策略的Annotation只能修饰包定义。 ElementType.PARAMETER：指定该策略的Annotation可以修饰参数。 ElementType.TYPE：指定该策略的Annotation可以修饰类、接口（包括注释类型）或枚举定义。与使用@Retention类似的是，使用@Target也可以直接在括号里指定value值，而无须使用name=value的形式。 "
###### Java元注解@Documented怎么使用？
问：Java元注解@Documented怎么使用？
- 答：@Documented用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档，如果定义Annotation类时使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。
###### Java元注解@Inherited怎么使用？
问：Java元注解@Inherited怎么使用？
- 答：@Inherited元Annotation指定被它修饰的Annotation将具有继承性——如果某个类使用了@AAnnotation（定义该Annotation时使用了@Inherited修饰）修饰，则其子类将自动被@A修饰
###### Java怎么操作文件和目录？
问：Java怎么操作文件和目录？
- 答：File类是java.io包下代表与平台无关的文件和目录，也就是说，如果希望在程序中操作文件和目录，都可以通过File类来完成。值得指出的是，不管是文件还是目录都是使用File来操作的，File能新建、删除、重命名文件和目录，File不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。
###### Java File类提供了哪些方法访问文件名？
问：Java File类提供了哪些方法访问文件名？
- 答："访问文件名相关的方法 String getName()：返回此File对象所表示的文件名或路径名（如果是路径，则返回最后一级子路径名）。 String getPath()：返回此File对象所对应的路径名。 File getAbsoluteFile()：返回此File对象所对应的绝对路径所对应的File对象。 String getAbsolutePath()：返回此File对象所对应的绝对路径名。 String getParent()：返回此File对象所对应目录（最后一级子目录）的父目录名。 boolean renameTo(File newName)：重命名此File对象所对应的文件或目录，如果重命名成功，则返回true；否则返回false。 "
###### Java File类提供了哪些方法进行文件检测？
问：Java File类提供了哪些方法进行文件检测？
- 答："文件检测相关的方法 boolean exists()：判断File对象所对应的文件或目录是否存在。 boolean canWrite()：判断File对象所对应的文件和目录是否可写。 boolean canRead()：判断File对象所对应的文件和目录是否可读。 boolean isFile()：判断File对象所对应的是否是文件，而不是目录。 boolean isDirectory()：判断File对 象所对应的是否是目录，而不是文件。 boolean isAbsolute()：判断File对象所对应的文件或目录是否是绝对路径。该方法消除了不同平台的差异，可以直接判断File对象是否为绝对路径。在UNIX/Linux/BSD等系统上，如果路径名开头是一条斜线（/），则表明该File对象对应一个绝对路径；在Windows等系统上，如果路径开头是盘符，则说明它是一个绝对路径。 "
###### Java File类提供了哪些方法获取常规文件信息？
问：Java File类提供了哪些方法获取常规文件信息？
- 答："获取常规文件信息 long lastModified()：返回文件的最后修改时间。 long length()：返回文件内容的长度。"
###### Java File类提供了哪些方法进行文件操作？
问：Java File类提供了哪些方法进行文件操作？
- 答："文件操作相关的方法 boolean createNewFile()：当此File对象所对应的文件不存在时，该方法将新建一个该File对象所指定的新文件，如果创建成功则返回true；否则返回false。 boolean delete()：删除File对象所对应的文件或路径。 static File createTempFile(String prefix,String suffix)：在默认的临时文件目录中创建一个临时的空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名。这是一个静态方法，可以直接通过File类来调用。prefix参数必须至少是3个字节长。建议前缀使用一个短的、有意义的字符串，比如 ""hjb"" 或 ""mail""。suffix参数可以为null，在这种情况下，将使用默认的后缀“.tmp”。 static File createTempFile(String prefix,String suffix,File directory)：在directory所指定的目录中创建一个临时的空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名。这是一个静态方法，可以直接通过File类来调用。 void deleteOnExit()：注册一个删除钩子，指定当Java虚拟机退出时，删除File对象所对应的文件和目录。 "
###### Java File类提供了哪些方法进行目录操作？
问：Java File类提供了哪些方法进行目录操作？
- 答："目录操作相关的方法 boolean mkdir()：试图创建一个File对象所对应的目录，如果创建成功，则返回true；否则返回false。调用该方法时File对象必须对应一个路径，而不是一个文件。 String[]list()：列出File对象的所有子文件名和路径名，返回String数组。 File[]listFiles()：列出File对象的所有子文件和路径，返回File数组。 static File[] listRoots()：列出系统所有的根路径。这是一个静态方法，可以直接通过File类来调用。 "
###### Java怎么进行文件过滤器？
问：Java怎么进行文件过滤器？
- 答：在File类的list()方法中可以接收一个FilenameFilter参数，通过该参数可以只列出符合条件的文件。这里的FilenameFilter接口和javax.swing.filechooser包下的FileFilter抽象类的功能非常相似，可以把FileFilter当成FilenameFilter的实现类，但可能Sun在设计它们时产生了一些小小遗漏，所以没有让FileFilter实现FilenameFilter接口。FilenameFilter接口里包含了一个accept(File dir,String name)方法，该方法将依次对指定File的所有子目录或者文件进行迭代，如果该方法返回true，则list()方法会列出该子目录或者文件。
###### Java 的IO流是指什么东西？
问：Java 的IO流是指什么东西？
- 答：Java中的IO流是输入输出流。至于理解，可以将输入和输出两个端点看作是两个工厂百，工厂之间需要互相运输度货物，而流则是两工厂之间的公路，没有公路就不能互相运输，至于版字符，字节和二进制则可以看作是运输的方式和单位大小，比如说把二权进制理解成三轮车，那么字节就是小卡车，而字符则是集卡之类的。
- 答：Java的IO流是实现输入/输出的基础，它可以方便地实现数据的输入/输出操作，在Java中把不同的输入/输出源（键盘、文件、网络连接等）抽象表述为“流”（stream），通过流的方式允许Java程序使用相同的方式来访问不同的输入/输出源。stream是从起源（source）到接收（sink）的有序数据。
###### Java 的IO流按照流的流向来分有什么类型？
问：Java 的IO流按照流的流向来分有什么类型？
- 答："按照流的流向来分，可以分为输入流和输出流。 输入流：只能从中读取数据，而不能向其写入数据。 输出流：只能向其写入数据，而不能从中读取数据。此处的输入、输出涉及一个方向问题，对于如图10.1所示的数据流向，数据从内存到硬盘，通常称为输出流——也就是说，这里的输入、输出都是从程序运行所在内存的角度来划分的。 "
###### Java 的IO流按照操作的数据单元来分有什么类型？
问：Java 的IO流按照操作的数据单元来分有什么类型？
- 答："字节流和字符流的用法几乎完全一样，区别在于字节流和字符流所操作的数据单元不同——字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符。字节流主要由InputStream和OutputStream作为基类，而字符流则主要由Reader和Writer作为基类。 "
###### Java 的IO流按照流的角色来分有什么类型？
问：Java 的IO流按照流的角色来分有什么类型？
- 答："按照流的角色来分，可以分为节点流和处理流。可以从/向一个特定的IO设备（如磁盘、网络）读/写数据的流，称为节点流，节点流也被称为低级流（Low Level Stream）。 处理流则用于对一个已存在的流进行连接或封装，通过封装后的流来实现数据读/写功能。处理流也被称为高级流。"
###### Java的处理流有什么好处？
问：Java的处理流有什么好处？
- 答：当使用处理流进行输入/输出时，程序并不会直接连接到实际的数据源，没有和实际的输入/输出节点连接。使用处理流的一个明显好处是，只要使用相同的处理流，程序就可以采用完全相同的输入/输出代码来访问不同的数据源，随着处理流所包装节点流的变化，程序实际所访问的数据源也相应地发生变化。
###### Java的IO流有几个抽象基类？
问：Java的IO流有几个抽象基类？
- 答："Java的IO流的40多个类都是从如下4个抽象基类派生的。 InputStream/Reader：所有输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流。"
###### Java InputStream里面包含了哪些方法？
问：Java InputStream里面包含了哪些方法？
- 答："在InputStream里包含如下3个方法。 int read()：从输入流中读取单个字节（相当于从图10.5所示的水管中取出一滴水），返回所读取的字节数据（字节数据可直接转换为int类型）。 int read(byte[]b)：从输入流中最多读取b.length个字节的数据，并将其存储在字节数组b中，返回实际读取的字节数。 int read(byte[]b,int off,int len)：从输入流中最多读取len个字节的数据，并将其存储在数组b中，放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字节数。"
###### Java Reader里面包含了哪些方法？
问：Java Reader里面包含了哪些方法？
- 答："在Reader里包含如下3个方法。 int read()：从输入流中读取单个字符（相当于从图10.5所示的水管中取出一滴水），返回所读取的字符数据（字符数据可直接转换为int类型）。 int read(char[]cbuf)：从输入流中最多读取cbuf.length个字符的数据，并将其存储在字符数组cbuf中，返回实际读取的字符数。 int read(char[]cbuf,int off,int len)：从输入流中最多读取len个字符的数据，并将其存储在字符数组cbuf中，放入数组cbuf中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字符数。"
###### Java输入流的工作原理是啥？
问：Java输入流的工作原理是啥？
- 答："InputStream和Reader都是将输入数据抽象成水管，所以程序既可以通过read()方法每次读取一个“水滴”，也可以通过read(char[]cbuf)或read(byte[]b)方法来读取多个“水滴”。当使用数组作为read()方法的参数时，我们可以理解为使用一个“竹筒”到水管中取水。read(char[]cbuf)方法中的数组可理解成一个“竹筒”，程序每次调用输入流的read(char[]cbuf)或read(byte[]b)方法，就相当于用“竹筒”从输入流中取出一筒“水滴”，程序得到“竹筒”里的“水滴”后，转换成相应的数据即可；程序多次重复这个“取水”过程，直到最后。程序如何判断取水取到了最后呢？直到read(char[] cbuf)或read(byte[]b)方法返回−1，即表明到了输入流的结束点。 "
###### Java InputStream和Reader还支持哪几个方法来移动记录指针？
问：Java InputStream和Reader还支持哪几个方法来移动记录指针？
- 答："InputStream和Reader还支持如下几个方法来移动记录指针。 void mark(int readAheadLimit)：在记录指针当前位置记录一个标记（mark）。 boolean markSupported()：判断此输入流是否支持mark()操作，即是否支持记录标记。 void reset()：将此流的记录指针重新定位到上一次记录标记（mark）的位置。 long skip(long n)：记录指针向前移动n个字节/字符。"
###### Java OutputStream里面包含了哪些方法？
问：Java OutputStream里面包含了哪些方法？
- 答："OutputStream里还包含如下3个方法 void write(int c)：将指定的字节/字符输出到输出流中，其中c既可以代表字节，也可以代表字符。 void write(byte[]/char[]buf)：将字节数组/字符数组中的数据输出到指定输出流中。 void write(byte[]/char[]buf,int off,int len)：将字节数组/字符数组中从off位置开始，长度为len的字节/字符输出到输出流中。"
###### Java Writer里面包含了哪些方法？
问：Java Writer里面包含了哪些方法？
- 答：public void write(int c): 写单个字符 
public void write(char[] cbuf): 写字符数组 
public abstract void write(char[] cbuf, int off,  int len): 写字符数组的一部分 
public void write(String str): 写字符串 
public void write(String str,int off, int len): 写字符串的某一部分 
public void flush() throws IOException 刷新该流的缓冲。 
public void close() throws IOException 关闭此流，但要先刷新它
- 答："Writer里还包含如下5个方法 void write(int c)：将指定的字节/字符输出到输出流中，其中c既可以代表字节，也可以代表字符。 void write(byte[]/char[]buf)：将字节数组/字符数组中的数据输出到指定输出流中。 void write(byte[]/char[]buf,int off,int len)：将字节数组/字符数组中从off位置开始，长度为len的字节/字符输出到输出流中。 void write(String str)：将str字符串里包含的字符输出到指定输出流中。 void write(String str,int off,int len)：将str字符串里从off位置开始，长度为len的字符输出到指定输出流中。"
###### 使用Java的IO流执行输出时，为啥要关闭输出流？
问：使用Java的IO流执行输出时，为啥要关闭输出流？
- 答：总之就是先关闭里面（被引用答）的。如果反专过来，先关闭引用的，那么就无法关闭被引用的了，会导致IO不能即时释放。
- 答：使用Java的IO流执行输出时，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，可能还可以将输出流缓冲区中的数据flush到物理节点里（因为在执行close()方法之前，自动执行输出流的flush()方法）。Java的很多输出流默认都提供了缓冲功能，其实我们没有必要刻意去记忆哪些流有缓冲功能、哪些流没有，只要正常关闭所有的输出流即可保证程序正常。
###### Java中怎么没有把字符流转换成字节流的转换流呢？
问：Java中怎么没有把字符流转换成字节流的转换流呢？
- 答：你这个问题很“聪明”，似乎一语指出了Java设计的遗漏之处。想一想字符流和字节流的差别：字节流比字符流的使用范围更广，但字符流比字节流操作方便。如果有一个流已经是字符流了，也就是说，是一个用起来更方便的流，为什么要转换成字节流呢？反之，如果现在有一个字节流，但我们知道这个字节流的内容都是文本内容，那么把它转换成字符流来处理就会更方便一些，所以Java只提供了将字节流转换成字符流的转换流，没有提供将字符流转换成字节流的转换流。
###### Java虚拟机怎么读写其他进程的数据？
问：Java虚拟机怎么读写其他进程的数据？
- 答："使用Runtime对象的exec()方法可以运行平台上的其他程序，该方法产生一个Process对象，Process对象代表由该Java程序启动的子进程。Process类提供了如下3个方法，用于让程序和其子进程进行通信。 InputStream getErrorStream()：获取子进程的错误流。 InputStream getInputStream()：获取子进程的输入流。 OutputStream getOutputStream()：获取子进程的输出流。"
###### Java为啥要进行序列化？
问：Java为啥要进行序列化？
- 答：序列化机制允许将实现序列化的Java对象转换成字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以备以后重新恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。
###### Java对象怎么实现序列化？
问：Java对象怎么实现序列化？
- 答："如果需要让某个对象支持序列化机制，则必须让它的类是可序列化的（serializable）。为了让某个类是可序列化的，该类必须实现如下两个接口之一： Serializable Externalizable Java的很多类已经实现了Serializable，该接口是一个标记接口，实现该接口无须实现任何方法，它只是表明该类的实例是可序列化的。"
- 答：package common.lang; 
import java.io.Serializable; 
import org.apache.commons.lang3.builder.ToStringBuilder; import org.apache.commons.lang3.builder.ToStringStyle; 
public class User1 implements Serializable{<!-- --> 
private String name;
private int age;

public String getName() {
	return name;
}
public void setName(String name) {
	this.name = name;
}
public int getAge() {
	return age;
}
public void setAge(int age) {
	this.age = age;
}

@Override
public String toString() {
	return new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE)
							   .append("name", name)
							   .append("age", age)
							   .toString();
}
 
}
###### 在网络上传输的对象的类为啥都应该是可序列化的？
问：在网络上传输的对象的类为啥都应该是可序列化的？
- 答：所有可能在网络上传输的对象的类都应该是可序列化的，否则程序将会出现异常，比如RMI（Remote Method Invoke，即远程方法调用，是Java EE的基础）过程中的参数和返回值；所有需要保存到磁盘里的对象的类都必须可序列化，比如Web应用中需要保存到HttpSession或ServletContext属性的Java对象。因为序列化是RMI过程的参数和返回值都必须实现的机制，而RMI又是Java EE技术的基础——所有的分布式应用常常需要跨平台、跨网络，所以要求所有传递的参数、返回值必须实现序列化。因此序列化机制是Java EE平台的基础。通常建议：程序创建的每个JavaBean类都实现Serializable。
###### Java 新IO和传统的IO有啥不同？
问：Java 新IO和传统的IO有啥不同？
- 答：新IO和传统的IO有相同的目的，都是用于进行输入/输出，但新IO使用了不同的方式来处理输入/输出，新IO采用内存映射文件的方式来处理输入/输出，新IO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件了（这种方式模拟了操作系统上的虚拟内存的概念），通过这种方式来进行输入/输出比传统的输入/输出要快得多。
###### Java中与新IO相关的包有哪些？
问：Java中与新IO相关的包有哪些？
- 答："Java中与新IO相关的包如下。 java.nio包：主要包含各种与Buffer相关的类。 java.nio.channels包：主要包含与Channel和Selector相关的类。 java.nio.charset包：主要包含与字符集相关的类。 java.nio.channels.spi包：主要包含与Channel相关的服务提供者编程接口。 java.nio.charset.spi包：包含与字符集相关的服务提供者编程接口。"
###### Java 新IO中的两个核心对象是啥？
问：Java 新IO中的两个核心对象是啥？
- 答：Channel（通道）和Buffer（缓冲）是新IO中的两个核心对象，Channel是对传统的输入/输出系统的模拟，在新IO系统中所有的数据都需要通过通道传输；Channel与传统的InputStream、OutputStream最大的区别在于它提供了一个map()方法，通过该map()方法可以直接将“一块数据”映射到内存中。如果说传统的输入/输出系统是面向流的处理，则新IO则是面向块的处理。Buffer可以被理解成一个容器，它的本质是一个数组，发送到Channel中的所有对象都必须首先放到Buffer中，而从Channel中读取的数据也必须先放到Buffer中。此处的Buffer有点类似于前面介绍的“竹筒”，但该Buffer既可以像“竹筒”那样一次次去Channel中取水，也允许使用Channel直接将文件的某块数据映射成Buffer。
###### Java Buffer 有哪些子类？
问：Java Buffer 有哪些子类？
- 答：对应于基本数据类型（boolean除外）都有相应的Buffer类：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。
###### Java 中如何创建Buffer对象？
问：Java 中如何创建Buffer对象？
- 答："Buffer类都没有提供构造器，通过使用如下方法来得到一个Buffer对象。 static XxxBuffer allocate(int capacity)：创建一个容量为capacity的XxxBuffer对象。"
###### Java Buffer 有哪些重要概念？
问：Java Buffer 有哪些重要概念？
- 答："在Buffer中有3个重要的概念：容量（capacity）、界限（limit）和位置（position）。 容量（capacity）：缓冲区的容量（capacity）表示该Buffer的最大数据容量，即最多可以存储多少数据。缓冲区的容量不可能为负值，创建后不能改变。 界限（limit）：第一个不应该被读出或者写入的缓冲区位置索引。也就是说，位于limit后的数据既不可被读，也不可被写。 位置（position）：用于指明下一个可以被读出的或者写入的缓冲区位置索引（类似于IO流中的记录指针）。当使用Buffer从Channel中读取数据时，position的值恰好等于已经读到了多少数据。当刚刚新建一个Buffer对象时，其position为0；如果从Channel中读取了2个数据到该Buffer中，则position为2，指向Buffer中第3个（第1个位置的索引为0）位置。"
###### Java Buffer 实现原理是啥？
问：Java Buffer 实现原理是啥？
- 答：Buffer的主要作用就是装入数据，然后输出数据（其作用类似于前面介绍的取水的“竹筒”），开始时Buffer的position为0，limit为capacity，程序可通过put()方法向Buffer中放入一些数据（或者从Channel中获取一些数据），每放入一些数据，Buffer的position相应地向后移动一些位置。当Buffer装入数据结束后，调用Buffer的flip()方法，该方法将limit设置为position所在位置，并将position设为0，这就使得Buffer的读写指针又移到了开始位置。也就是说，Buffer调用flip()方法之后，Buffer为输出数据做好准备；当Buffer输出数据结束后，Buffer调用clear()方法，clear()方法不是清空Buffer的数据，它仅仅将position置为0，将limit置为capacity，这样为再次向Buffer中装入数据做好准备。
###### Java Channel 与传统的流对象有什么区别？
问：Java Channel 与传统的流对象有什么区别？
- 答："Channel类似于传统的流对象，但与传统的流对象有两个主要区别。 Channel可以直接将指定文件的部分或全部直接映射成Buffer。 程序不能直接访问Channel中的数据，包括读取、写入都不行，Channel只能与Buffer进行交互。也就是说，如果要从Channel中取得数据，必须先用Buffer从Channel中取出一些数据，然后让程序从Buffer中取出这些数据；如果要将程序中的数据写入Channel，一样先让程序将数据放入Buffer中，程序再将Buffer里的数据写入Channel中。"
###### Java 新IO怎么锁定文件？
问：Java 新IO怎么锁定文件？
- 答：在NIO中，Java提供了FileLock来支持文件锁定功能，在FileChannel中提供的lock()/tryLock()方法可以获得文件锁FileLock对象，从而锁定文件。lock()和tryLock()方法存在区别：当lock()试图锁定某个文件时，如果无法得到文件锁，程序将一直阻塞；而tryLock()是尝试锁定文件，它将直接返回而不是阻塞，如果获得了文件锁，该方法则返回该文件锁，否则将返回null。
###### Java 新IO怎么监控文件变化？
问：Java 新IO怎么监控文件变化？
- 答："在以前的Java版本中，如果程序需要监控文件的变化，则可以考虑启动一条后台线程，这条后台线程每隔一段时间去“遍历”一次指定目录的文件，如果发现此次遍历结果与上次遍历结果不同，则认为文件发生了变化。但这种方式不仅十分烦琐，而且性能也不好。NIO.2的Path类提供了如下一个方法来监听文件系统的变化。 register(WatchService watcher,WatchEvent.Kind<?>...events)：用watcher监听该path代表的目录下的文件变化。events参数指定要监听哪些类型的事件。 在这个方法中WatchService代表一个文件系统监听服务，它负责监听path代表的目录下的文件变化。一旦使用register()方法完成注册之后，接下来就可调用WatchService的如下3个方法来获取被监听目录的文件变化事件。 WatchKey poll()：获取下一个WatchKey，如果没有WatchKey发生就立即返回null。 WatchKey poll(long timeout, TimeUnit unit)：尝试等待timeout时间去获取下一个WatchKey。 Wa tchKey take()：获取下一个WatchKey，如果没有WatchKey发生就一直等待。如果程序需要一直监控，则应该选择使用take()方法； 如果程序只需要监控指定时间，则可考虑使用poll()方法。"
###### Java进程有什么特征？
问：Java进程有什么特征？
- 答："进程包含如下3个特征。 独立性：进程是系统中独立存在的实体，它可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况下，一个用户进程不可以直接访问其他进程的地址空间。 动态性：进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念。进程具有自己的生命周期和各种不同的状态，这些概念在程序中都是不具备的。 并发性：多个进程可以在单个处理器上并发执行，多个进程之间不会互相影响。"
###### Java线程和进程有啥区别？
问：Java线程和进程有啥区别？
- 答：线程是进程的组成部分，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量，但不拥有系统资源，它与父进程的其他线程共享该进程所拥有的全部资源。因为多个线程共享父进程里的全部资源，因此编程更加方便；但必须更加小心，我们必须确保线程不会妨碍同一进程里的其他线程。线程可以完成一定的任务，可以与其他线程共享父进程中的共享变量及部分环境，相互之间协同来完成进程所要完成的任务。线程是独立运行的，它并不知道进程中是否还有其他线程存在。线程的执行是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便另外一个线程可以运行。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。
###### Java 多线程有什么优势？
问：Java 多线程有什么优势？
- 答："总结起来，使用多线程编程具有如下几个优点。 进程之间不能共享内存，但线程之间共享内存非常容易。 系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价小得多，因此使用多线程来实现多任务并发比多进程的效率高。 Java语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了Java的多线程编程。 在实际应用中，多线程是非常有用的，一个浏览器必须能同时下载多个图片；一个We b服务器必须能同时响应多个用户请求；Java虚拟机本身就在后台提供了一个超级线程来进行垃圾回收；图形用户界面（GUI）应用也需要启动单独的线程从主机环境收集用户界面事件……总之，多线程在实际编程中的应用是非常广泛的。"
###### Java 继承Thread类创建线程类的步骤是啥？
问：Java 继承Thread类创建线程类的步骤是啥？
- 答："通过继承Thread类来创建并启动多线程的步骤如下。 （1）定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务。因此把run()方法称为线程执行体。 （2）创建Thread子类的实例，即创建了线程对象。 （3）调用线程对象的start()方法来启动该线程。"
###### Java 实现Runnable接口创建线程类的步骤是啥？
问：Java 实现Runnable接口创建线程类的步骤是啥？
- 答："实现Runnable接口来创建并启动多线程的步骤如下。 （1）定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 （2）创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。"
###### Java 使用Callable和Future创建线程的步骤是啥？
问：Java 使用Callable和Future创建线程的步骤是啥？
- 答："创建并启动有返回值的线程的步骤如下。 （1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，且该call()方法有返回值。 （2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 （3）使用FutureTask对象作为Thread对象的target创建并启动新线程。 （4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。"
###### Java 在Future接口里定义了哪些公共方法来控制它关联的Callable任务？
问：Java 在Future接口里定义了哪些公共方法来控制它关联的Callable任务？
- 答："在Future接口里定义了如下几个公共方法来控制它关联的Callable任务。 boolean cancel(boolean mayInterruptIfRunning)：试图取消该Future里关联的Callable任务。 V get()：返回Callable任务里call()方法的返回值。调用该方法将导致程序阻塞，必须等到子线程结束后才会得到返回值。 V get(long timeout,TimeUnit unit)：返回Callable任务里call()方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间后Callable任务依然没有返回值，将会抛出TimeoutException异常。 boolean isCancelled()：如果在Callable任务正常完成前被取消，则返回 true。 boolean isDone()：如果Callable任务已完成，则返回 true。"
###### Java 创建线程的三种方式有啥区别？
问：Java 创建线程的三种方式有啥区别？
- 答："通过继承Thread类或实现Runnable、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值，可以声明抛出异常而已。因此可以将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。采用实现Runnable、Callable接口的方式创建多线程—— 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。 在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 劣势是：编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread()方法。采用继承Thread类的方式创建多线程—— 劣势是：因为线程类已经继承了Thread类，所以不能再继承其他父类。 优势是：编写简单，如果需要访问当前线程，则无须使用 Thread.currentThread()方法，直接使用this即可获得当前线程。鉴于上面分析，因此一般推荐采用实现Runnable接口、Callable接口的方式来创建多线程。"
###### Java线程的生命周期有哪些？
问：Java线程的生命周期有哪些？
- 答：当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态。尤其是当线程启动以后，它不可能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。
###### Java 线程的新建和就绪状态是指什么？
问：Java 线程的新建和就绪状态是指什么？
- 答：当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。
###### Java 线程的运行和阻塞状态是指什么？
问：Java 线程的运行和阻塞状态是指什么？
- 答："如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个 CPU，那么在任何时刻只有一个线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程并行（注意是并行：parallel）执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。 当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说，被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。"
###### 当发生什么情况时，Java线程将会进入阻塞状态？
问：当发生什么情况时，Java线程将会进入阻塞状态？
- 答："当发生如下情况时，线程将会进入阻塞状态。 线程调用sleep()方法主动放弃所占用的处理器资源。 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。关于同步监视器的知识、后面将有更深入的介绍。 线程在等待某个通知（notify）。 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。"
###### 当发生什么情况时，Java线程将会解除阻塞状态？
问：当发生什么情况时，Java线程将会解除阻塞状态？
- 答："当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态。 调用sleep()方法的线程经过了指定时间。 线程调用的阻塞式IO方法已经返回。 线程成功地获得了试图取得的同步监视器。 线程正在等待某个通知时，其他线程发出了一个通知。 处于挂起状态的线程被调用了resume()恢复方法。"
###### Java线程会以什么样的方式结束，然后处于死亡状态？
问：Java线程会以什么样的方式结束，然后处于死亡状态？
- 答："线程会以如下3种方式结束，结束后就处于死亡状态。 run()或call()方法执行完成，线程正常结束。 线程抛出一个未捕获的 Exception或Error。 直接调用该线程的stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。"
###### Java 线程使用的start()方法有什么限制？
问：Java 线程使用的start()方法有什么限制？
- 答：不要对处于死亡状态的线程调用start()方法，程序只能对新建状态的线程调用start()方法，对新建状态的线程两次调用start()方法也是错误的。这都会引发IllegalThreadState Exception异常。
###### Java join线程有什么作用？
问：Java join线程有什么作用？
- 答：Thread 提供了让一个线程等待另一个线程完成的方法——join()方法。当在某个程序执行流中调用其他线程的 join()方法时，调用线程将被阻塞，直到被 join()方法加入的 join 线程执行完为止。join()方法通常由使用线程的程序调用，以将大问题划分成许多小问题，每个小问题分配一个线程。当所有的小问题都得到处理后，再调用主线程来进一步操作。
###### Java join()方法有几种种重载形式？
问：Java join()方法有几种种重载形式？
- 答："join()方法有如下3种重载形式。 join()：等待被join的线程执行完成。 join(long millis)：等待被join的线程的时间最长为millis毫秒。如果在millis毫秒内被join的线程还没有执行结束，则不再等待。 join(long millis,int nanos)：等待被join的线程的时间最长为millis毫秒加nanos毫微秒。"
###### Java 后台线程是指什么？
问：Java 后台线程是指什么？
- 答：有一种线程，它是在后台运行的，它的任务是为其他的线程提供服务，这种线程被称为“后台线程（Daemon Thread）”，又称为“守护线程”或“精灵线程”。JVM的垃圾回收线程就是典型的后台线程。后台线程有个特征：如果所有的前台线程都死亡，后台线程会自动死亡。调用Thread对象的setDaemon(true)方法可将指定线程设置成后台线程。下面程序将执行线程设置成后台线程，可以看到当所有的前台线程死亡时，后台线程随之死亡。当整个虚拟机中只剩下后台线程时，程序就没有继续运行的必要了，所以虚拟机也就退出了。
###### Java 怎么判断线程是否是后台线程？
问：Java 怎么判断线程是否是后台线程？
- 答：Thread类还提供了一个isDaemon()方法，用于判断指定线程是否为后台线程。
###### Java 使用后台线程应该注意什么？
问：Java 使用后台线程应该注意什么？
- 答：前台线程死亡后，JVM 会通知后台线程死亡，但从它接收指令到做出响应，需要一定时间。而且要将某个线程设置为后台线程，必须在该线程启动之前设置，也就是说，setDaemon(true)必须在start()方法之前调用，否则会引发IllegalThreadStateException异常。
###### Java如何让当前正在执行的线程暂停一段时间，并进入阻塞状态？
问：Java如何让当前正在执行的线程暂停一段时间，并进入阻塞状态？
- 答："如果需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread类的静态sleep()方法来实现。sleep()方法有两种重载形式。 static void sleep(long millis)：让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度与准确度的影响。 static void sleep(long millis,int nanos)：让当前正在执行的线程暂停millis毫秒加nanos毫微秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度与准确度的影响。 与前面类似的是，程序很少调用第二种形式的sleep()方法。 当当前线程调用 sleep()方法进入阻塞状态后，在其睡眠时间段内，该线程不会获得执行的机会，即使系统中没有其他可执行的线程，处于sleep()中的线程也不会执行，因此sleep()方法常用来暂停程序的执行。 "
###### Java如何让当前正在执行的线程暂停一段时间，并进入就绪状态？
问：Java如何让当前正在执行的线程暂停一段时间，并进入就绪状态？
- 答：yield()方法是一个和 sleep()方法有点相似的方法，它也是 Thread 类提供的一个静态方法，它也可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程转入就绪状态。yield()只是让当前线程暂停一下，让系统的线程调度器重新调度一次，完全可能的情况是：当某个线程调用了yield()方法暂停之后，线程调度器又将其调度出来重新执行。
###### Java 多线程sleep()方法和yield()方法的区别在哪？
问：Java 多线程sleep()方法和yield()方法的区别在哪？
- 答："关于sleep()方法和yield()方法的区别如下。 sleep()方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级；但yield()方法只会给优先级相同，或优先级更高的线程执行机会。 sleep()方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yield()不会将线程转入阻塞状态，它只是强制当前线程进入就绪状态。因此完全有可能某个线程调用yield()方法暂停之后，立即再次获得处理器资源被执行。 sleep()方法声明抛出了 InterruptedException 异常，所以调用 sleep()方法时要么捕捉该异常，要么显式声明抛出该异常；而yield()方法则没有声明抛出任何异常。 sleep()方法比 yield()方法有更好的可移植性，通常不建议使用 yield()方法来控制并发线程的执行。"
###### Java如何改变线程优先级？
问：Java如何改变线程优先级？
- 答："每个线程执行时都具有一定的优先级，优先级高的线程获得较多的执行机会，而优先级低的线程则获得较少的执行机会。 每个线程默认的优先级都与创建它的父线程的优先级相同，在默认情况下，main 线程具有普通优先级，由main线程创建的子线程也具有普通优先级。 Thread类提供了setPriority(int newPriority)、getPriority()方法来设置和返回指定线程的优先级，其中setPriority()方法的参数可以是一个整数，范围是1～10之间，也可以使用Thread类的如下3个静态常量。 MAX_PRIORITY：其值是10。 MIN_PRIORITY：其值是1。 NORM_PRIORITY：其值是5。"
###### Java线程安全的类具有什么特征？
问：Java线程安全的类具有什么特征？
- 答："通过使用同步方法可以非常方便地实现线程安全的类，线程安全的类具有如下特征。 该类的对象可以被多个线程安全地访问。 每个线程调用该对象的任意方法之后都将得到正确结果。 每个线程调用该对象的任意方法之后，该对象状态依然保持合理状态。"
###### Java线程会在什么情况下释放对同步监视器的锁定？
问：Java线程会在什么情况下释放对同步监视器的锁定？
- 答："程序无法显式释放对同步监视器的锁定，线程会在如下几种情况下释放对同步监视器的锁定。 当前线程的同步方法、同步代码块执行结束，当前线程即释放同步监视器。 当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行，当前线程将会释放同步监视器。 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致了该代码块、该方法异常结束时，当前线程将会释放同步监视器。 当前线程执行同步代码块或同步方法时，程序执行了同步监视器对象的wait()方法，则当前线程暂停，并释放同步监视器。在如下所示的情况下，线程不会释放同步监视器。 线程执行同步代码块或同步方法时，程序调用 Thread.sleep()、Thread.yield()方法来暂停当前线程的执行，当前线程不会释放同步监视器。 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放同步监视器。当然，我们应该尽量避免使用suspend()和resume()方法来控制线程。"
###### Java Thread类提供了哪些构造器来设置新创建的线程属于哪个线程组？
问：Java Thread类提供了哪些构造器来设置新创建的线程属于哪个线程组？
- 答："Thread类提供了如下几个构造器来设置新创建的线程属于哪个线程组。 Thread(ThreadGroup group,Runnable target)：以target的run()方法作为线程执行体创建新线程，属于group线程组。 Thread(ThreadGroup group,Runnable target,String name)：以target的run()方法作为线程执行体创建新线程，该线程属于group线程组，且线程名为name。 Thread(ThreadGroup group,String name)：创建新线程，新线程名为name，属于group线程组。"
###### Java Thread类提供了哪些方法来设置异常处理器？
问：Java Thread类提供了哪些方法来设置异常处理器？
- 答："Thread类提供了如下两个方法来设置异常处理器。 static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandlereh)：为该线程类的所有线程实例设置默认的异常处理器。 setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为指定的线程实例设置异常处理器。"
###### Java线程组处理异常的默认流程是啥？
问：Java线程组处理异常的默认流程是啥？
- 答："线程组处理异常的默认流程如下。 （1）如果该线程组有父线程组，则调用父线程组的uncaughtException()方法来处理该异常。 （2）如果该线程实例所属的线程类有默认的异常处理器（由 setDefaultUncaughtExceptionHandler()方法设置的异常处理器），那么就调用该异常处理器来处理该异常。 （3）如果该异常对象是ThreadDeath的对象，则不做任何处理；否则，将异常跟踪栈的信息打印到System.err错误输出流，并结束该线程。"
###### Java为何要使用线程池？
问：Java为何要使用线程池？
- 答："系统启动一个新线程的成本是比较高的，因为它涉及与操作系统交互。在这种情形下，使用线程池可以很好地提高性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。 与数据库连接池类似的是，线程池在系统启动时即创建大量空闲的线程，程序将一个Runnable对象或Callable对象传给线程池，线程池就会启动一个线程来执行它们的run()或call()方法，当run()或call()方法执行结束后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个Runnable对象的run()或call()方法。 除此之外，使用线程池可以有效地控制系统中并发线程的数量，当系统中包含大量并发线程时，会导致系统性能剧烈下降，甚至导致JVM崩溃，而线程池的最大线程数参数可以控制系统中并发线程数不超过此数。"
###### Java Executors工厂类怎么创建线程池？
问：Java Executors工厂类怎么创建线程池？
- 答："Java5新增了一个Executors工厂类来产生线程池，该工厂类包含如下几个静态工厂方法来创建线程池。 newCachedThreadPool()：创建一个具有缓存功能的线程池，系统根据需要创建线程，这些线程将会被缓存在线程池中。 newFixedThreadPool(int nThreads)：创建一个可重用的、具有固定线程数的线程池。 newSingleThreadExecutor()：创建一个只有单线程的线程池，它相当于调用newFixedThread Pool()方法时传入参数为1。 newScheduledThreadPool(int corePoolSize)：创建具有指定线程数的线程池，它可以在指定延迟后执行线程任务。corePoolSize指池中所保存的线程数，即使线程是空闲的也被保存在线程池内。 newSingleThreadScheduledExecutor()：创建只有一个线程的线程池，它可以在指定延迟后执行线程任务。"
###### Java ExecutorService提供了哪些方法提交线程任务到线程池？
问：Java ExecutorService提供了哪些方法提交线程任务到线程池？
- 答："ExecutorService代表尽快执行线程的线程池（只要线程池中有空闲线程，就立即执行线程任务），程序只要将一个Runnable对象或Callable对象（代表线程任务）提交给该线程池，该线程池就会尽快执行该任务。ExecutorService里提供了如下3个方法。 Future<?> submit(Runnable task)：将一个Runnable对象提交给指定的线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。其中Future对象代表Runnable任务的返回值——但run()方法没有返回值，所以Future对象将在run()方法执行结束后返回null。但可以调用Future的isDone()、isCancelled()方法来获得Runnable对象的执行状态。 
 
  Future
  
   submit(Runnable task,T result)：将一个Runnable对象提交给指定的线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。其中result显式指定线程执行结束后的返回值，所以Future对象将在run()方法执行结束后返回result。 
   
     Future
    
      submit(Callable
     
       task)：将一个Callable对象提交给指定的线程池，线程池将在有空闲线程时执行Callable对象代表的任务。其中Future代表Callable对象里call()方法的返回值。"
###### Java ScheduledExecutorService提供了哪些方法提交线程任务到线程池？
问：Java ScheduledExecutorService提供了哪些方法提交线程任务到线程池？
- 答：
```
"ScheduledExecutorService 代表可在指定延迟后或周期性地执行线程任务的线程池，它提供了如下4个方法。 ScheduledFuture
 
   schedule(Callable
  
    callable, long delay, TimeUnit unit)：指定callable任务将在delay延迟后执行。 ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)：指定command任务将在delay延迟后执行。 ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay,long period,TimeUnit unit)：指定command任务将在delay延迟后执行，而且以设定频率重复执行。也就是说，在 initialDelay 后开始执行，依次在 initialDelay+period、initialDelay+2*period…处重复执行，依此类推。 ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, longinitialDelay, long delay,TimeUnit unit)：创建并执行一个在给定初始延迟后首次启用的定期操作，随后在每一次执行终止和下一次执行开始之间都存在给定的延迟。如果任务在任一次执行时遇到异常，就会取消后续执行；否则，只能通过程序来显式取消或终止该任务。"
```
###### Java如何启动线程池的关闭序列？
问：Java如何启动线程池的关闭序列？
- 答：当用完一个线程池后，应该调用该线程池的shutdown()方法，该方法将启动线程池的关闭序列，调用shutdown()方法后的线程池不再接收新任务，但会将以前所有已提交任务执行完成。当线程池中的所有任务都执行完成后，池中的所有线程都会死亡；另外也可以调用线程池的shutdownNow()方法来关闭线程池，该方法试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。
###### Java使用线程池来执行线程任务的步骤有啥？
问：Java使用线程池来执行线程任务的步骤有啥？
- 答："使用线程池来执行线程任务的步骤如下。 （1）调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池。 （2）创建Runnable实现类或Callable实现类的实例，作为线程执行任务。 （3）调用ExecutorService对象的submit()方法来提交Runnable实例或Callable实例。 （4）当不想提交任何任务时，调用ExecutorService对象的shutdown()方法来关闭线程池。"
###### Java如何利用多核CPU的优势？
问：Java如何利用多核CPU的优势？
- 答："为了充分利用多CPU、多核CPU的性能优势，计算机软件系统应该可以充分“挖掘”每个CPU的计算能力，绝不能让某个CPU处于“空闲”状态。为了充分利用多CPU、多核 CPU 的优势，可以考虑把一个任务拆分成多个“小任务”，把多个“小任务”放到多个处理器核心上并行执行；当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。 Java 7提供了ForkJoinPool来支持将一个任务拆分成多个“小任务”并行计算，再把多个“小任务”的结果合并成总的计算结果。ForkJoinPool是ExecutorService的实现类，因此是一种特殊的线程池。"
###### Java ForkJoinPool有哪些构造器?
问：Java ForkJoinPool有哪些构造器?
- 答："ForkJoinPool提供了如下两个常用的构造器。 ForkJoinPool(int parallelism)：创建一个包含parallelism个并行线程的ForkJoinPool。 ForkJoinPool()：以Runtime.availableProcessors()方法的返回值作为parallelism参数来创建Fork JoinPool。"
###### Java如何简洁地隔离多线程程序的竞争资源？
问：Java如何简洁地隔离多线程程序的竞争资源？
- 答：ThreadLocal，是 Thread Local Variable（线程局部变量）的意思，也许将它命名为ThreadLocalVar更加合适。线程局部变量（ThreadLocal）的功用其实非常简单，就是为每一个使用该变量的线程都提供一个变量值的副本，使每一个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量一样。
###### Java ThreadLocal类提供了哪些方法？
问：Java ThreadLocal类提供了哪些方法？
- 答："ThreadLocal类的用法非常简单，它只提供了如下3个public方法。 T get()：返回此线程局部变量中当前线程副本中的值。 void remove()：删除此线程局部变量中当前线程的值。 void set(T value)：设置此线程局部变量中当前线程副本中的值。"
###### Java ThreadLocal类能代替同步机制吗？
问：Java ThreadLocal类能代替同步机制吗？
- 答："ThreadLocal并不能替代同步机制，两者面向的问题领域不同。同步机制是为了同步多个线程对相同资源的并发访问，是多个线程之间进行通信的有效方式；而ThreadLocal是为了隔离多个线程的数据共享，从根本上避免多个线程之间对共享资源（变量）的竞争，也就不需要对多个线程进行同步了。 通常我们认为：如果多个线程之间需要共享资源，以达到线程之间的通信功能，就使用同步机制；如果仅仅需要隔离多个线程之间的共享冲突，则可以使用ThreadLocal。"
###### Java如何包装线程不安全的集合？
问：Java如何包装线程不安全的集合？
- 答："Java 集合 ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap等都是线程不安全的，也就是说，当多个并发线程向这些集合中存、取元素时，就可能会破坏这些集合的数据完整性。 如果程序中有多个线程可能访问以上这些集合，那么我们可以使用 Collections 提供的静态方法把这些集合包装成线程安全的集合。Collections提供了如下几个静态方法。 
 
  Collection
  
   synchronizedCollection(Collection
   
    c)：返回指定 collection对应的线程安全的collection。 static
    
     List
     
      synchronizedList(List
      
       list)：返回指定List对象对应的线程安全的List对象。 static<K,V>Map<K,V>synchronizedMap(Map<K,V>m)：返回指定Map对象对应的线程安全的Map对象。 static 
       
         Set
        
          synchronizedSet(Set
         
           s)：返回指定Set对象对应的线程安全的Set对象。 static <K,V>SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m)：返回指定SortedMap对象对应的线程安全的SortedMap对象。 static 
          
            SortedSet
           
             synchronizedSortedSet(SortedSet
            
              s)：返回指定SortedSet对象对应的线程安全的SortedSet对象。"
###### Java如何进行普通字符和url字符相互转换？
问：Java如何进行普通字符和url字符相互转换？
- 答：URLDecoder和URLEncoder用于完成普通字符串和application/x-www-form-urlencodedMIME 字符串之间的相互转换。
###### Java 获得了URL对象之后，调用什么方法来访问该URL对应的资源？
问：Java 获得了URL对象之后，调用什么方法来访问该URL对应的资源？
- 答："URL类提供了多个构造器用于创建URL对象，一旦获得了URL对象之后，就可以调用如下方法来访问该URL对应的资源。 String getFile()：获取该URL的资源名。 String getHost()：获取该URL的主机名。 String getPath()：获取该URL的路径部分。 int getPort()：获取该URL的端口号。 String getProtocol()：获取该URL的协议名称。 String getQuery()：获取该URL的查询字符串部分。 URLConnection openConnection()：返回一个URLConnection对象，它代表了与URL所引用的远程对象的连接。 InputStream openStream()：打开与此URL的连接，并返回一个用于读取该URL资源的InputStream。"
###### Java 读取此URL引用的资源需要哪些步骤？
问：Java 读取此URL引用的资源需要哪些步骤？
- 答："通常创建一个和URL的连接，并发送请求、读取此URL引用的资源需要如下几个步骤。 （1）通过调用URL对象的openConnection()方法来创建URLConnection对象。 （2）设置URLConnection的参数和普通请求属性。 （3）如果只是发送GET方式请求，则使用connect()方法建立和远程资源之间的实际连接即可；如果需要发送POST方式的请求，则需要获取URLConnection实例对应的输出流来发送请求参数。 （4）远程资源变为可用，程序可以访问远程资源的头字段或通过输入流读取远程资源的数据。"
###### Java中能怎么接收其他通信实体连接请求？
问：Java中能怎么接收其他通信实体连接请求？
- 答："Java中能接收其他通信实体连接请求的类是ServerSocket，ServerSocket对象用于监听来自客户端的 Socket 连接，如果没有连接，它将一直处于等待状态。ServerSocket 包含一个监听来自客户端连接请求的方法。 Socket accept()：如果接收到一个客户端Socket的连接请求，该方法将返回一个与客户端Socket对应的Socket（如图12.4所示，每个TCP连接有两个Socket）；否则该方法将一直处于等待状态，线程也被阻塞。"
###### Java如何创建ServerSocket对象？
问：Java如何创建ServerSocket对象？
- 答："为了创建ServerSocket对象，ServerSocket类提供了如下几个构造器。 ServerSocket(int port)：用指定的端口port来创建一个ServerSocket。该端口应该有一个有效的端口整数值，即0～65535。 ServerSocket(int port,int backlog)：增加一个用来改变连接队列长度的参数backlog。 ServerSocket(int port,int backlog,InetAddress localAddr)：在机器存在多个 IP地址的情况下，允许通过localAddr参数来指定将ServerSocket绑定到指定的IP地址。"
###### Java客户端怎么使用Socket的构造器来连接到指定服务器？
问：Java客户端怎么使用Socket的构造器来连接到指定服务器？
- 答："客户端通常可以使用Socket的构造器来连接到指定服务器，Socket通常可以使用如下两个构造器。 Socket(InetAddress/String remoteAddress, int port)：创建连接到指定远程主机、远程端口的Socket，该构造器没有指定本地地址、本地端口，默认使用本地主机的默认IP地址，默认使用系统动态分配的端口。 Socket(InetAddress/String remoteAddress, int port, InetAddress localAddr, intlocalPort)：创建连接到指定远程主机、远程端口的Socket，并指定本地IP地址和本地端口，适用于本地主机有多个IP地址的情形。 上面两个构造器中指定远程主机时既可使用 InetAddress 来指定，也可直接使用 String对象来指定，但程序通常使用String对象（如192.168.2.23）来指定远程IP地址。当本地主机只有一个IP地址时，使用第一个方法更为简单。"
###### Java Socket怎么获取输入流和输出流？
问：Java Socket怎么获取输入流和输出流？
- 答："Socket提供了如下两个方法来获取输入流和输出流。 InputStream getInputStream()：返回该Socket对象对应的输入流，让程序通过该输入流从Socket中取出数据。 OutputStream getOutputStream()：返回该Socket对象对应的输出流，让程序通过该输出流向Socket中输出数据。"
###### Java在什么时候JVM进程将被终止？
问：Java在什么时候JVM进程将被终止？
- 答："当我们调用Java命令运行某个Java程序时，该命令将会启动一个Java虚拟机进程，不管该Java程序有多么复杂，该程序启动了多少个线程，它们都处于该Java虚拟机进程里。正如前面介绍的，同一个JVM的所有线程、所有变量都处于同一个进程里，它们都使用该JVM进程的内存区。当系统出现以下几种情况时，JVM进程将被终止。 程序运行到最后正常结束。 程序运行到使用System.exit()或Runtime.getRuntime().exit()代码处结束程序。 程序执行过程中遇到未捕获的异常或错误而结束。 程序所在平台强制结束了JVM进程。"
###### Java类加载要经过哪几个步骤？
问：Java类加载要经过哪几个步骤？
- 答：当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成这3个步骤，所以有时也把这3个步骤统称为类加载或类初始化。
###### Java中类是一种对象吗？
问：Java中类是一种对象吗？
- 答：类是某一类对象的抽象，类是概念层次的东西。但不知道读者有没有想过：类也是一种对象。就像我们说概念主要用于定义、描述其他事物，但概念本身也是一种事物，那么概念本身也需要被描述——这有点像一个哲学命题。但事实就是这样，每个类是一批具有相同特征的对象的抽象（或者说概念），而系统中所有的类实际上也是实例，它们都是java.lang.Class的实例。
###### Java可以从哪些来源加载类？
问：Java可以从哪些来源加载类？
- 答："通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。 通过网络加载class文件。 把一个Java源文件动态编译，并执行加载。 类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。"
###### Java类连接分为哪几个阶段？
问：Java类连接分为哪几个阶段？
- 答："当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。 （1）验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。 （2）准备：类准备阶段则负责为类的静态Field分配内存，并设置默认初始值。 （3）解析：将类的二进制数据中的符号引用替换成直接引用。"
###### 在Java类中对静态Field指定初始值有几种方式？
问：在Java类中对静态Field指定初始值有几种方式？
- 答："在类的初始化阶段，虚拟机负责对类进行初始化，主要就是对静态Field进行初始化。在Java类中对静态Field指定初始值有两种方式： ① 声明静态Field时指定初始值； ② 使用静态初始化块为静态Field指定初始值。"
###### Java JVM初始化一个类包含哪写步骤？
问：Java JVM初始化一个类包含哪写步骤？
- 答："JVM初始化一个类包含如下几个步骤。 （1）假如这个类还没有被加载和连接，则程序先加载并连接该类。 （2）假如该类的直接父类还没有被初始化，则先初始化其直接父类。 （3）假如类中有初始化语句，则系统依次执行这些初始化语句。"
###### 当Java程序首次如何使用某个类或接口就会初始化？
问：当Java程序首次如何使用某个类或接口就会初始化？
- 答："当Java程序首次通过下面6种方式来使用某个类或接口时，系统就会初始化该类或接口。 创建类的实例。为某个类创建实例的方式包括：使用new操作符来创建实例，通过反射来创建实例，通过反序列化的方式来创建实例。 调用某个类的静态方法。 访问某个类或接口的静态Field，或为该静态Field赋值。 使用反射方式来强制创建某个类或接口对应的 java.lang.Class 对象。例如代码：Class.forName(""Person"")，如果系统还未初始化 Person 类，则这行代码将会导致该Person 类被初始化，并返回 Person 类对应的 java.lang.Class 对象。关于 Class 的forName方法请参考13.3节。 初始化某个类的子类。当初始化某个类的子类时，该子类的所有父类都会被初始化。 直接使用java.exe命令来运行某个主类。当运行某个主类时，程序会先初始化该主类。"
###### Java中对于使用一个final型的静态Field一定会导致类初始化吗？
问：Java中对于使用一个final型的静态Field一定会导致类初始化吗？
- 答："对于一个final型的静态Field，如果该Field的值在编译时就可以确定下来，那么这个Field相当于“宏变量”。Java编译器会在编译时直接把这个Field出现的地方替换成它的值，因此即使程序使用该静态Field，也不会导致该类的初始化。 反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该Field的值，如果通过该类来访问它的静态Field，则会导致该类被初始化。"
###### Java类加载器如何识别是不是同一个类？
问：Java类加载器如何识别是不是同一个类？
- 答：正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为（Person、pg、kl）。这意味着两个类加载器加载的同名类：（Person、pg、kl）和（Person、pg、kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。
###### Java JVM有几个类加载器？
问：Java JVM有几个类加载器？
- 答："当JVM启动时，会形成由3个类加载器组成的初始类加载器层次结构。 Bootstrap ClassLoader：根类加载器。 Extension ClassLoader：扩展类加载器。 System ClassLoader：系统类加载器。"
###### Java Bootstrap ClassLoader 有什么作用？
问：Java Bootstrap ClassLoader 有什么作用？
- 答：Bootstrap ClassLoader被称为引导（也称为原始或根）类加载器，它负责加载Java的核心类。在Sun的JVM中，当执行java.exe命令时，使用-Xbootclasspath选项或使用-D选项指定sun.boot.class.path系统属性值可以指定加载附加的类。
###### Java Extension ClassLoader 有什么作用？
问：Java Extension ClassLoader 有什么作用？
- 答：Extension Classloader 被称为扩展类加载器，它负责加载 JRE 的扩展目录（%JAVA_HOME%/jre/lib/ext或者由java.ext.dirs系统属性指定的目录）中JAR包的类。通过这种方式，就可以为Java扩展核心类以外的新功能，只要我们把自己开发的类打包成JAR文件，然后放入JAVA_HOME/jre/lib/ext路径即可
###### Java System ClassLoader 有什么作用？
问：Java System ClassLoader 有什么作用？
- 答：System Classloader被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性，或CLASSPATH环境变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以类加载器作为父加载器。
###### Java JVM的类加载机制有哪些？
问：Java JVM的类加载机制有哪些？
- 答："JVM的类加载机制主要有如下3种。 全盘负责。所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。 父类委托。所谓父类委托，则是先让 parent（父）类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。 缓存机制。缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个Class 时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区中。这就是为什么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。"
###### 类加载器加载Class大致要经过哪写步骤？
问：类加载器加载Class大致要经过哪写步骤？
- 答："类加载器加载Class大致要经过如下8个步骤。 （1）检测此Class是否载入过（即在缓存区中是否有此Class），如果有则直接进入第8步，否则接着执行第2步。 注意：JVM的根类加载器并不是Java实现的，而且由于程序通常无须访问根类加载器，因此访问扩展类加载器的父类加载器时返回null。 （2）如果父类加载器不存在（如果没有父类加载器，则要么parent一定是根类加载器，要么本身就是根类加载器），则跳到第4步执行；如果父类加载器存在，则接着执行第3步。 （3）请求使用父类加载器去载入目标类，如果成功载入则跳到第8步，否则接着执行第5步。 （4）请求使用根类加载器来载入目标类，如果成功载入则跳到第8步，否则跳到第7步。 （5）当前类加载器尝试寻找Class文件（从与此ClassLoader相关的类路径中寻找），如果找到则执行第6步，如果找不到则跳到第7步。 （6）从文件中载入Class，成功载入后跳到第8步。 （7）抛出ClassNotFoundException异常。 （8）返回对应的java.lang.Class对象。 其中，第5、6步允许重写ClassLoader的findClass()方法来实现自己的载入策略，甚至重写loadClass()方法来实现自己的载入过程。"
###### Java程序如何在运行时发现对象和类的真实信息？
问：Java程序如何在运行时发现对象和类的真实信息？
- 答："为了解决这些问题，程序需要在运行时发现对象和类的真实信息。为了解决这个问题，我们有以下两种做法。 第一种做法是假设在编译时和运行时都完全知道类型的具体信息，在这种情况下，我们可以直接先使用 instanceof 运算符进行判断，再利用强制类型转换将其转换成其运行时类型的变量即可。关于这种方式请参考5.7节的内容。 第二种做法是编译时根本无法预知该对象和类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射。"
###### Java程序中如何获得Class对象？
问：Java程序中如何获得Class对象？
- 答："在Java程序中获得Class对象通常有如下3种方式。 使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定类名（必须添加完整包名）。 调用某个类的class属性来获取该类对应的Class对象。例如，Person.class将会返回Person类对应的Class对象。 调用某个对象的getClass()方法。该方法是java.lang.Object类中的一个方法，所以所有的Java对象都可以调用该方法，该方法将会返回该对象所属类对应的Class对象。"
###### Java如何获取Class对应类所包含的构造器？
问：Java如何获取Class对应类所包含的构造器？
- 答："下面4个方法用于获取Class对应类所包含的构造器。 Constructor
 
   getConstructor(Class<?>... parameterTypes)：返回此Class对象对应类的指定public构造器。 Constructor<?>[]getConstructors()：返回此Class对象对应类的所有public构造器。 Constructor
  
    getDeclaredConstructor(Class<?>... parameterTypes)：返回此Class对象对应类的指定构造器，与构造器的访问权限无关。 Constructor<?>[]getDeclaredConstructors()：返回此Class对象对应类的所有构造器，与构造器的访问权限无关。"
###### Java如何获取Class对应类所包含的方法？
问：Java如何获取Class对应类所包含的方法？
- 答："下面4个方法用于获取Class对应类所包含的方法。 Method getMethod(String name,Class<?>...parameterTypes)：返回此Class对象对应类的指定public方法。 Method[]getMethods()：返回此Class对象所表示的类的所有public方法。 Method getDeclaredMethod(String name,Class<?>...parameterTypes)：返回此Class对象对应类的指定方法，与方法的访问权限无关。 Method[] getDeclaredMethods()：返回此Class对象对应类的全部方法，与方法的访问权限无关。"
###### Java如何访问Class对应类所包含的Field？
问：Java如何访问Class对应类所包含的Field？
- 答："如下4个方法用于访问Class对应类所包含的Field。 Field getField(String name)：返回此Class对象对应类的指定public Field。 Field[]getFields()：返回此Class对象对应类的所有public Field。 Field getDeclaredField(String name)：返回此Class对象对应类的指定 Field，与Field的访问权限无关。 Field[] getDeclaredFields()：返回此Class对象对应类的全部 Field，与Field的访问权限无关。"
###### Java如何访问Class对应类上所包含的Annotation？
问：Java如何访问Class对应类上所包含的Annotation？
- 答：" A getAnnotation(ClassannotationClass)：试图获取该Class对象对应类上指定类型的Annotation；如果该类型的注释不存在，则返回null。 Annotation[]getAnnotations()：返回该Class对象对应类上的所有Annotation。 Annotation[] getDeclaredAnnotations()：返回直接修饰该 Class 对应类的所有Annotation。"
###### Java如何访问该Class对象对应类包含的内部类？
问：Java如何访问该Class对象对应类包含的内部类？
- 答：Class<?>[]getDeclaredClasses()：返回该Class对象对应类里包含的全部内部类。
###### Java如何访问该Class对象对应类所在的外部类？
问：Java如何访问该Class对象对应类所在的外部类？
- 答：Class<?>getDeclaringClass()：返回该Class对象对应类所在的外部类。
###### Java如何访问该Class对象对应类所继承的父类、所实现的接口等？
问：Java如何访问该Class对象对应类所继承的父类、所实现的接口等？
- 答：Class<?>[]getInterfaces()：返回该Class对象对应类所实现的全部接口。
###### Java如何访问该Class对象对应类所继承的父类？
问：Java如何访问该Class对象对应类所继承的父类？
- 答：Class<?super T>getSuperclass()：返回该 Class对象对应类的超类的Class对象。
###### Java Class对象如何判断该类是否为接口、枚举、注释类型？
问：Java Class对象如何判断该类是否为接口、枚举、注释类型？
- 答："Class对象还可调用如下几个判断方法来判断该类是否为接口、枚举、注释类型等。 boolean isAnnotation()：返回此Class对象是否表示一个注释类型（由@interface定义）。 boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)：判断此Class 对象是否使用了Annotation注释修饰。 boolean isAnonymousClass()：返回此Class对象是否是一个匿名类。 boolean isArray()：返回此Class对象是否表示一个数组类。 boolean isEnum()：返回此Class对象是否表示一个枚举（由enum关键字定义）。 boolean isInterface()：返回此Class对象是否表示一个接口（使用interface定义）。 boolean isInstance(Object obj)：判断obj是否是此Class对象的实例，该方法可以完全代替instanceof操作符。"
###### Java如何通过反射来生成对象？
问：Java如何通过反射来生成对象？
- 答：1.第一种方式newInstance(); 
2.第二种方式： 
有带参数的构造函数的类，先获取到其构造对象，再通过该构造方法类获取实例： 
/ /获取构造函数类的对象 
Constroctor constroctor = User.class.getConstructor(String.class); 
// 使用构造器对象的newInstance方法初始化对象 
Object obj = constroctor.newInstance("name"); 
<img src="https://ucc.alicdn.com/pic/developer-ecology/1184e1cec73a482782b014168ea78ab0.png" alt="2.png" />
- 答："通过反射来生成对象有如下两种方式。 使用Class对象的newInstance()方法来创建该Class对象对应类的实例，这种方式要求该Class 对象的对应类有默认构造器，而执行 newInstance()方法时实际上是利用默认构造器来创建该类的实例。 先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。"
###### Java如何利用指定的构造器来创建Java对象？
问：Java如何利用指定的构造器来创建Java对象？
- 答："如果不想利用默认构造器来创建Java对象，而想利用指定的构造器来创建Java对象，则需要利用Constructor对象，每个Constructor对应一个构造器。为了利用指定的构造器来创建Java对象，需要如下3个步骤。 （1）获取该类的Class对象。 （2）利用Class对象的getConstructor()方法来获取指定的构造器。 （3）调用Constructor的newInstance()方法来创建Java对象。"
###### Java Class对象如何获取该类所包括的全部Field或指定Field？
问：Java Class对象如何获取该类所包括的全部Field或指定Field？
- 答："通过Class对象的getFields()或getField()方法可以获取该类所包括的全部Field或指定Field。Field提供了如下两组方法来读取或设置Field值。 getXxx(Object obj)：获取obj对象该Field的属性值。此处的Xxx对应8个基本类型，如果该属性的类型是引用类型，则取消get后面的Xxx。 setXxx(Object obj,Xxx val)：将obj对象的该Field设置成val值。此处的Xxx对应8个基本类型，如果该属性的类型是引用类型，则取消set后面的Xxx。 使用这两个方法可以随意地访问指定对象的所有属性，包括private访问控制的属性。"
###### Java如何使用Proxy和InvocationHandler创建动态代理？
问：Java如何使用Proxy和InvocationHandler创建动态代理？
- 答："Proxy 提供了用于创建动态代理类和代理对象的静态方法，它也是所有动态代理类的父类。如果在程序中为一个或多个接口动态地生成实现类，就可以使用Proxy来创建动态代理类；如果需要为一个或多个接口动态地创建实例，也可以使用Proxy来创建动态代理实例。Proxy提供了如下两个方法来创建动态代理类和动态代理实例。 static Class
 getProxyClass(ClassLoader loader,Class
 ...interfaces)：创建一个动态代理类所对应的Class对象，该代理类将实现interfaces所指定的多个接口。第一个ClassLoader参数指定生成动态代理类的类加载器。 static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)：直接创建一个动态代理对象，该代理对象的实现类实现了interfaces 指定的系列接口，执行代理对象的每个方法时都会被替换执行InvocationHandler对象的invoke方法。 实际上，即使采用第一个方法获取了一个动态代理类之后，当程序需要通过该代理类来创建对象时一样需要传入一个 InvocationHandler 对象。也就是说，系统生成的每个代理对象都有一个与之关联的InvocationHandler对象。"
###### Java Spring框架Core Container（核心容器）包含哪些模块？
问：Java Spring框架Core Container（核心容器）包含哪些模块？
- 答：Core Container（核心容器）包含有Core、Beans、Context和Expression Language模块。
###### Java Spring框架Core Container中Core模块有何作用？
问：Java Spring框架Core Container中Core模块有何作用？
- 答：Core模块主要包含Spring框架基本的核心工具类，Spring的其他组件要都要使用到这个包里的类，Core模块是其他组件的基本核心。当然你也可以在自己的应用系统中使用这些工具类。
###### Java Spring框架Core Container中Beans模块有何作用？
问：Java Spring框架Core Container中Beans模块有何作用？
- 答：Beans模块是所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类。
###### Java Spring框架Core Container中Context模块有何作用？
问：Java Spring框架Core Container中Context模块有何作用？
- 答：Context模块构建于Core和Beans模块基础之上，提供了一种类似于JNDI注册器的框架式的对象访问方法。Context模块继承了Beans的特性，为Spring核心提供了大量扩展，添加了对国际化（例如资源绑定）、事件传播、资源加载和对Context的透明创建的支持。Context模块同时也支持J2EE的一些特性，例如EJB、JMX和基础的远程处理。ApplicationContext接口是Context模块的关键。
###### Java Spring框架Core Container中Expression Language模块有
问：Java Spring框架Core Container中Expression Language模块有何作用？
- 答：Expression Language模块提供了一个强大的表达式语言用于在运行时查询和操纵对象。它是JSP 2.1规范中定义的unifed expression language的一个扩展。该语言支持设置/获取属性的值，属性的分配，方法的调用，访问数组上下文（accessiong the context ofarrays）、容器和索引器、逻辑和算术运算符、命名变量以及从Spring的IoC容器中根据名称检索对象。它也支持list投影、选择和一般的list聚合。
###### Java Spring框架Data Access/Integration层包含哪些模块？
问：Java Spring框架Data Access/Integration层包含哪些模块？
- 答：Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块
###### Java Spring框架Data Access/Integration层JDBC模块有何作用？
问：Java Spring框架Data Access/Integration层JDBC模块有何作用？
- 答：JDBC模块提供了一个JDBC抽象层，它可以消除冗长的JDBC编码和解析数据库厂商特有的错误代码。这个模块包含了Spring对JDBC数据访问进行封装的所有类。
###### Java Spring框架Data Access/Integration层ORM模块有何作用？
问：Java Spring框架Data Access/Integration层ORM模块有何作用？
- 答：ORM模块为流行的对象-关系映射API，如JPA、JDO、Hibernate、iBatis等，提供了一个交互层。利用ORM封装包，可以混合使用所有Spring提供的特性进行O/R映射。如前边提到的简单声明性事物管理。
###### Java Spring框架Data Access/Integration层OXM模块有何作用？
问：Java Spring框架Data Access/Integration层OXM模块有何作用？
- 答：OXM模块提供了一个对Object/XML映射实现的抽象层，Object/XML映射实现包括JAXB、Castor、XMLBeans、JiBX和XStream。
###### Java Spring框架Data Access/Integration层JMS模块有何作用？
问：Java Spring框架Data Access/Integration层JMS模块有何作用？
- 答：JMS（Java Messaging Service）模块主要包含了一些制造和消费消息的特性。
###### Java Spring框架Data Access/Integration层Transaction模块
问：Java Spring框架Data Access/Integration层Transaction模块有何作用？
- 答：Transaction模块支持编程和声明性的事物管理，这些事物类必须实现特定的接口，并且对所有的POJO都适用。
###### Java Spring框架web层包含哪些模块？
问：Java Spring框架web层包含哪些模块？
- 答：Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。所以， Spring框架支持与Jakarta Struts的集成。Web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。Web层包含了Web、Web-Servlet、Web-Struts和Web-Porlet模块。
###### Java Spring框架web层Web模块有何作用？
Java Spring框架web层Web模块
问：Java Spring框架web层Web模块有何作用？
- 答：Web模块：提供了基础的面向Web的集成特性。例如，多文件上传、使用servletlisteners初始化IoC容器以及一个面向Web的应用上下文。它还包含Spring远程支持中Web的相关部分。
###### Java Spring框架web层Web-Servlet模块有何作用？
问：Java Spring框架web层Web-Servlet模块有何作用？
- 答：Web-Servlet模块web.servlet.jar：该模块包含Spring的model-view-controller（MVC）实现。Spring的MVC框架使得模型范围内的代码和web forms之间能够清楚地分离开来，并与Spring框架的其他特性集成在一起。
###### Java Spring框架web层Web-Struts模块有何作用？
问：Java Spring框架web层Web-Struts模块有何作用？
- 答：Web-Struts模块：该模块提供了对Struts的支持，使得类在Spring应用中能够与一个典型的Struts Web层集成在一起。注意，该支持在Spring 3.0中是deprecated的。
###### Java Spring框架web层Web-Porlet模块有何作用？
问：Java Spring框架web层Web-Porlet模块有何作用？
- 答：Web-Porlet模块：提供了用于Portlet环境和Web-Servlet模块的MVC的实现。
###### Java Spring框架AOP模块有何作用？
问：Java Spring框架AOP模块有何作用？
- 答："AOP模块提供了一个符合AOP联盟标准的面向切面编程的实现，它让你可以定义例如方法拦截器和切点，从而将逻辑代码分开，降低它们之间的耦合性。利用source-level的元数据功能，还可以将各种行为信息合并到你的代码中，这有点像.Net技术中的attribute概念。通过配置管理特性，Spring AOP模块直接将面向切面的编程功能集成到了Spring框架中，所以可以很容易地使Spring框架管理的任何对象支持AOP。Spring AOP模块为基于Spring的应用程序中的对象提供了事务管理服务。通过使用Spring AOP，不用依赖EJB组件，就可以将声明性事务管理集成到应用程序中。 ● Aspects模块提供了对AspectJ的集成支持。 ● Instrumentation模块提供了class instrumentation支持和classloader实现，使得可以在特定的应用服务器上使用。"
###### Java Spring框架Test模块有何作用？
问：Java Spring框架Test模块有何作用？
- 答：Test模块支持使用JUnit和TestNG对Spring组件进行测试。
###### Java spring中的DefaultListableBeanFactory有什么作用？
问：Java spring中的DefaultListableBeanFactory有什么作用？
- 答：XmlBeanFactory继承自DefaultListableBeanFactory，而DefaultListableBeanFactory是整个bean加载的核心部分，是Spring注册及加载bean的默认实现，而对于XmlBeanFactory与DefaultListableBeanFactory不同的地方其实是在XmlBeanFactory中使用了自定义的XML读取器XmlBeanDefinitionReader，实现了个性化的BeanDefinitionReader读取，DefaultListableBeanFactory继承了AbstractAutowireCapableBeanFactory并实现了ConfigurableListableBeanFactory以及BeanDefinitionRegistry接口。
###### Java spring中如何读取xml配置文件？
问：Java spring中如何读取xml配置文件？
- 答："XML配置文件的读取是Spring中重要的功能，因为Spring的大部分功能都是以配置作为切入点的，那么我们可以从XmlBeanDefinitionReader中梳理一下资源文件读取、解析及注册的大致脉络，首先我们看看各个类的功能。 ResourceLoader：定义资源加载器，主要应用于根据给定的资源文件地址返回对应的Resource。 BeanDefinitionReader：主要定义资源文件读取并转换为BeanDefinition的各个功能。 EnvironmentCapable：定义获取Environment方法。 DocumentLoader：定义从资源文件加载到转换为Document的功能。 AbstractBeanDefinitionReader：对EnvironmentCapable、BeanDefinitionReader类定义的功能进行实现。 BeanDefinitionDocumentReader：定义读取Docuemnt并注册BeanDefinition功能。 BeanDefinitionParserDelegate：定义解析Element的各种方法。 我们可以梳理出整个XML配置文件读取的大致流程 （1）通过继承自AbstractBeanDefinitionReader中的方法，来使用ResourLoader将资源文件路径转换为对应的Resource文件。 （2）通过DocumentLoader对Resource文件进行转换，将Resource文件转换为Document文件。 （3）通过实现接口BeanDefinitionDocumentReader的DefaultBeanDefinitionDocumentReader类对Document进行解析，并使用BeanDefinitionParserDelegate对Element进行解析。"
###### Java spring加载bean的流程是啥?
问：Java spring加载bean的流程是啥?
- 答："在XmlBeanFactory构造函数中调用了XmlBeanDefinitionReader类型的reader属性提供的方法this.reader.loadBeanDefinitions(resource)，而这句代码则是整个资源加载的切入点， 梳理整个的处理过程如下。 （1）封装资源文件。当进入XmlBeanDefinitionReader后首先对参数Resource使用EncodedResource类进行封装。 （2）获取输入流。从Resource中获取对应的InputStream并构造InputSource。 （3）通过构造的InputSource实例和Resource实例继续调用函数doLoadBeanDefinitions。"
###### Java spring XML文件的验证模式有哪些？
问：Java spring XML文件的验证模式有哪些？
- 答：比较常用的验证模式有两种：DTD和XSD。
###### Java spring中XML文件的验证模式DTD与XSD区别有哪些？
问：Java spring中XML文件的验证模式DTD与XSD区别有哪些？
- 答："DTD（Document Type Definition）即文档类型定义，是一种XML约束模式语言，是XML文件的验证机制，属于XML文件组成的一部分。DTD是一种保证XML文档格式正确的有效方法，可以通过比较XML文档和DTD文件来看文档是否符合规范，元素和标签使用是否正确。一个DTD文档包含：元素的定义规则，元素间关系的定义规则，元素可使用的属性，可使用的实体或符号规则。要使用DTD验证模式的时候需要在XML文件的头部声明。 XML Schema语言就是XSD（XML Schemas Definition）。XML Schema描述了XML文档的结构。可以用一个指定的XML Schema来验证某个XML文档，以检查该XML文档是否符合其要求。文档设计者可以通过XML Schema指定一个XML文档所允许的结构和内容，并可据此检查一个XML文档是否是有效的。XML Schema本身是一个XML文档，它符合XML语法结构。可以用通用的XML解析器解析它。 在使用XML Schema文档对XML实例文档进行检验，除了要声明名称空间外（xmlns=http://www.Springframework.org/schema/beans），还必须指定该名称空间所对应的XML Schema文档的存储位置。通过schemaLocation属性来指定名称空间所对应的XMLSchema文档的存储位置，它包含两个部分，一部分是名称空间的URI，另一部分就是该名称空间所标识的XML Schema文件位置或URL地址（xsi:schemaLocation=""http://www.Springframework.org/schema/beans http://www.Springframework.org/schema/beans/Spring-beans.xsd）。"
###### Java spring 是如何获取验证模式的？
问：Java spring 是如何获取验证模式的？
- 答："Spring通过getValidationModeForResource方法来获取对应资源的的验证模式。 方法的实现其实还是很简单的，无非是如果设定了验证模式则使用设定的验证模式（可以通过对调用XmlBeanDefinitionReader中的setValidationMode方法进行设定），否则使用自动检测的方式。而自动检测验证模式的功能是在函数detectValidationMode方法中实现的，在detectValidationMode函数中又将自动检测验证模式的工作委托给了专门处理类XmlValidationMode Detector，调用了XmlValidationModeDetector的validationModeDetector方法"
###### Java spring如何获取Document？
问：Java spring如何获取Document？
- 答："同样XmlBeanFactoryReader类对于文档读取并没有亲力亲为，而是委托给了DocumentLoader去执行，这里的DocumentLoader是个接口，而真正调用的是DefaultDocumentLoader Spring在这里并没有什么特殊的地方，同样首先创建DocumentBuilderFactory，再通过DocumentBuilderFactory创建DocumentBuilder，进而解析inputSource来返回Document对象。对此感兴趣的读者可以在网上获取更多的资料。这里有必要提及一下EntityResolver，对于参数entityResolver，传入的是通过getEntityResolver()函数获取的返回值"
###### Java spring EntityResolver是怎么使用的？
问：Java spring EntityResolver是怎么使用的？
- 答："在loadDocument方法中涉及一个参数EntityResolver，何为EntityResolver？官网这样解释:如果SAX应用程序需要实现自定义处理外部实体，则必须实现此接口并使用setEntityResolver方法向SAX驱动器注册一个实例。也就是说，对于解析一个XML，SAX首先读取该XML文档上的声明，根据声明去寻找相应的DTD定义，以便对文档进行一个验证。默认的寻找规则，即通过网络（实现上就是声明的DTD的URI地址）来下载相应的DTD声明，并进行认证。下载的过程是一个漫长的过程，而且当网络中断或不可用时，这里会报错，就是因为相应的DTD声明没有被找到的原因。 EntityResolver的作用是项目本身就可以提供一个如何寻找DTD声明的方法，即由程序来实现寻找DTD声明的过程，比如我们将DTD文件放到项目中某处，在实现时直接将此文档读取并返回给SAX即可。这样就避免了通过网络来寻找相应的声明。"
###### Java spring中profile属性如何使用？
问：Java spring中profile属性如何使用？
- 答：分析profile前我们先了解下profile的用法：指定环境。有了这个特性我们就可以同时在配置文件中部署两套配置来适用于生产环境和开发环境，这样可以方便的进行切换开发、部署环境，最常用的就是更换不同的数据库。
###### Java spring为何大量使用FactoryBean？
问：Java spring为何大量使用FactoryBean？
- 答：一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean 。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在
 
  中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.Springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化bean的逻辑。FactoryBean接口对于Spring框架来说占有重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring 3.0开始， FactoryBean开始支持泛型，即接口声明改为FactoryBean
  
   的形式
###### Java spring FactoryBean定义了哪些方法？
问：Java spring FactoryBean定义了哪些方法？
- 答："在该接口中还定义了以下3个方法。 ● T getObject()：返回由FactoryBean创建的bean实例，如果isSingleton()返回true，则该实例会放到Spring容器中单实例缓存池中。 ● boolean isSingleton()：返回由FactoryBean创建的bean实例的作用域是singleton还是prototype。 ● Class
 
   getObjectType()：返回FactoryBean创建的bean类型。"
###### Java spring使用了FactoryBean后，getBean()方法返回的是啥？
问：Java spring使用了FactoryBean后，getBean()方法返回的是啥？
- 答：
```
当配置文件中
 
  的class属性配置的实现类是FactoryBean时，通过getBean()方法返回的不是FactoryBean本身，而是FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法。
```
###### Java spring如何在缓存中获取单例bean？
问：Java spring如何在缓存中获取单例bean？
- 答：介绍过FactoryBean的用法后，我们就可以了解bean加载的过程了。前面已经提到过，单例在Spring的同一个容器内只会被创建一次，后续再获取bean直接从单例缓存中获取，当然这里也只是尝试加载，首先尝试从缓存中加载，然后再次尝试尝试从singletonFactories中加载。因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖，Spring创建bean的原则是不等bean创建完成就会将创建bean的ObjectFactory提早曝光加入到缓存中，一旦下一个bean创建时需要依赖上个bean，则直接使用ObjectFactory。
###### Java spring中getObjectForBeanInstance负责什么逻辑？
问：Java spring中getObjectForBeanInstance负责什么逻辑？
- 答："getObjectForBeanInstance中的所做的工作。 （1）对FactoryBean正确性的验证。 （2）对非FactoryBean不做任何处理。 （3）对bean进行转换。 （4）将从Factory中解析bean的工作委托给getObjectFromFactoryBean。"
###### Java spring中如何扩展BeanFacotry中现有的功能？
问：Java spring中如何扩展BeanFacotry中现有的功能？
- 答：Spring中还提供了另一个接口ApplicationContext，用于扩展BeanFacotry中现有的功能。ApplicationContext和BeanFacotry两者都是用于加载Bean的，但是相比之下，ApplicationContext提供了更多的扩展功能，简单一点说：ApplicationContext包含BeanFactory的所有功能。通常建议比BeanFactory优先，除非在一些限制的场合，比如字节长度对内存有很大的影响时（Applet）。绝大多数“典型的”企业应用和系统，ApplicationContext就是你需要使用的。
###### ApplicationContext比BeanFactory加载配置文件在写法上的不同在哪？
问：ApplicationContext比BeanFactory加载配置文件在写法上的不同在哪？
- 答："● 使用BeanFactory方式加载XML。 BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(""beanFactoryTest.xml"")); ● 使用ApplicationContext方式加载XML。 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(""beanFactoryTest.xml"");"
###### 在Java JDK1.5中常用的包哪些？
问：在Java JDK1.5中常用的包哪些？
- 答：java.lang： 这个是来系统的基础类，比如String、Math、Integer、System和Thread， 提供常用功能。 java.io: 这里面是所有输入输出有关的类，比如文件操作等 java.net: 这里面是与网络有源关的类，比如URL,URLConnection等。 java.util : 这个是系统辅助类，特别zd是集合类Collection,List,Map等。 java.sql: 这个是数据库操作的类，Connection, Statememt，ResultSet等
- 答："在JDK1.5中常用的包有下面这些： • java.lang：语言包。 • java.util：实用包。 • java.awt：抽象窗口工具包。 • javax.swing：轻量级的窗口工具包，这是目前使用最广泛的GUI程序设计包。 • java.io：输入输出包。 • java.net：网络函数包。 • java.applet：编制Applet需要用到的包（目前编制Aapplet程序时，更多是使用swing中的JApplet类）。"
###### Java语言包java.lang有哪些用处？
问：Java语言包java.lang有哪些用处？
- 答：<img src="https://ucc.alicdn.com/pic/developer-ecology/49d56c11ddad48c2b61a9905299fc04a.png" alt="image.png" />
###### Java实用包java.util有哪些用处？
问：Java实用包java.util有哪些用处？
- 答：Java中import的作用是导入要用到的包中的类接口。import就是在java文件开7a686964616fe58685e5aeb931333366303064头的地方，先说明会用到那些类别。 接着我们就能在代码中只用类名指定某个类，也就是只称呼名字，不称呼他的姓。这其中包的作用就是给java类进行分拣分类，不同业务逻辑的java类放在同一个包中。比如实体包，工具包。 
Java的实用工具类库java.util包。在这个包中，Java提供了一些实用的方法和数据结构。本章介绍Java的实用工具类库java.util包。在这个包中，Java提供了一些实用的方法和数据结构。例如，Java提供日期(Data)类、日历(Calendar)类来产生和获取日期及时间，提供随机数(Random)类产生各种类型的随机数，还提供了堆栈(Stack)、向量(Vector) 、位集合(Bitset)以及哈希表(Hashtable)等类来表示相应的数据结构。
- 答："实用包提供了各种实用功能的类，主要包括日期类、集合框架和各种实用工具类等。 • 日期类：包括Data、Calendar和GregorianCalendar类，其中Data类提供获取日期和时间的方法，Calendar和GregorianCalendar类是日历类，它们的功能比Data更强，但Calendar是抽象类，GregorianCalendar是它的子类。 • 集合框架类：包括链表类LinkedList、向量类Vector、栈类Stack、散列表类Hashtable等。 • 随机数类Random：它封装了Math类中的random()方法，并提供了更多的辅助功能。"
###### Java抽象窗口工具包java.awt有哪些用处？
问：Java抽象窗口工具包java.awt有哪些用处？
- 答："Java的java.awt提供了绘图和图像类，主要用于编写GUI程序，包含用于创建用户界面和绘制图形图像的所有类如按钮、标签等常用组件以及相应的事件类。 • 组件类：包括Button、Panel、Label、Choice等类，用于设计图形界面。 • 事件包：在java.awt.event中包括了各种事件处理的接口和类。 • 颜色包：在java.awt.color中提供了用于颜色的类。 • 字体包：在java.awt.font中提供了与字体相关的接口和类。"
###### Java输入输出包java.io有哪些用处？
问：Java输入输出包java.io有哪些用处？
- 答：java.io提供了通过数据流、序列化和文件系统提供系统输入和输出。主要包括输入流类InputStream和输出流OutputStream，可以实现文件的输入/输出、管道的数据传输以及网络数据传输的功能。
###### Java网络函数包java.net有哪些用处？
问：Java网络函数包java.net有哪些用处？
- 答：java.net提供了实现网络应用程序的类，主要包括用于实现Socket通信的Socket类，此外还提供了可以方便处理URL的类。
###### JavaApplet包java.applet有哪些用处？
问：JavaApplet包java.applet有哪些用处？
- 答：这是专为创建Applet程序提供的包，它包含了创建applet所必需的类，以及applet用来与其他applet上下文通信的类。目前基本上被JApplet类所代替。
###### Java jdk中System类与Runtime类有何区别？
问：Java jdk中System类与Runtime类有何区别？
- 答：System类中的所有成员都是静态的，而要引用这些变量和方法时，直接使用System类名作前缀，在前面已经使用到了标准输入和输出的in和out变量。Runtime类封装了Java命令本身的运行进程，其中的许多方法与System中的方法重复。不能直接创建Runtime实例，但可以通过静态方法Runtime.getRuntime获得正在运行的Runtime对象的引用。例如exit(int status)这个方法，在System类中表示终止当前正在运行的Java虚拟机。参数用作状态码；如果参数是非零的数值，则表示该程序发生异常而终止虚拟机的运行。而在Runtime类中，该方法则表示通过启动虚拟机的关闭序列，终止当前正在运行的Java虚拟机，参数也是用作状态码，非零的状态码表示非正常终止。调用System.exit(n)实际上等效于调用Runtime.getRuntime().exit(n)。这两个类虽然都具有终止当前线程运行的功能，但是引用的方式不同。
###### Java jdk中Math与Random类有何区别？
问：Java jdk中Math与Random类有何区别？
- 答：Math类包含了所有用于几何和三角的浮点运算函数，这些函数都是静态的，每个方法的使用都非常简单。Random类是一个随机数产生器，随机数是按照某种算法产生的，一旦用一个初值创建Random对象，就可以得到一系列的随机数。虽然Java在Math类中提供了一个random函数，可以获得随机数，但它的功能单一，只能返回带正号的double值，范围为1.0＞x≥0.0。在Java中还提供了一个功能上更强一些的类——Random。它不仅可以返回浮点类型的随机数，还可以返回整型、布尔型、字节型，也可以由程序员自己指定产生随机数的范围。Random类具有两种构造方法如：Random()和Random(long seed)，其中seed指是创建随机数生成器的种子。如果种子相同，产生的随机数序列一定相同。为了避免每次产生的随机数序列完全相同，必须在构造Random对象时赋予不同的种子，因此Math.random()=Random.nextDouble()。
###### Java jdk中Date与Calendar、DateFormat类有何区别？
问：Java jdk中Date与Calendar、DateFormat类有何区别？
- 答：Date是Java类库里提供对时间进行处理的类，日期在商业逻辑的应用中占据着很重要的地位，它最简单的构造函数是Date()，它以当前的日期和时间初始化一个Date对象。由于开始设计Date时没有考虑到国际化，所以后来又设计了两个新的类来解决Date类中的问题，一个是Calendar类，另一个是DateFormat类。从JDK 1.1起，Date中的方法就被废弃掉，全部都被移植到另外一个类Calendar中。Calendar类是一个抽象基类，主要完成日期字段之间相互操作的功能，它为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。Calendar提供了一个类方法getInstance，以获得此类型的一个通用的对象。Calendar的getInstance方法返回一个Calendar对象，其日历字段已由当前日期和时间初始化。DateFormat提供了很多类方法，以获得基于默认或给定语言环境和多种格式化风格的默认日期/时间Formatter。格式化风格包括FULL、LONG、MEDIUM和SHORT。方法描述中提供了使用这些风格的更多细节和示例，还可帮助进行格式化并分析任何语言环境的日期。java.text.SimpleDateFormat类是JDK目前提供的一个DateFormat子类。它是一个具体类，具有把Date对象格式化为本地字符串，或者通过语义分析把日期或时间字符串转换为Date对象的功能。
###### Java JDBC连接数据库有哪些步骤？
问：Java JDBC连接数据库有哪些步骤？
- 答："JDBC连接数据库主要分为以下4步。 1 创建数据源。 2 加载驱动程序。 3 连接数据源。 4 对数据库的操作。"
###### Java JDBC如何加载驱动程序？
问：Java JDBC如何加载驱动程序？
- 答："通过调用Class.forName方法来加载驱动程序。加载驱动程序只需要一行代码就能完成，以JDBC-ODBC桥接、Oracle连接和MySQL连接为例，看一下它们的驱动程序。 • JDBC-ODBC桥接：sun.jdbc.odbc.JdbcOdbcDriver。 • Oracle连接：oracle.jdbc.driver.OracleDriver。 • MySQL连接：org.gjt.mm. MySQL.Driver。 如果使用Java集成环境时（Eclipse）用Oracle和MySQL连接相应的数据源，要在JRE SystemLibrary中加入相应的jar文件，如MySQL-connector-java-3.1.10-bin.jar。"
###### Java JDBC URL的标准语法是啥？
问：Java JDBC URL的标准语法是啥？
- 答："jdbc:<子协议>:<子名称> 在JDBC编程中，JDBC URL中的协议总是jdbc，jdbc是永远不变的。<子协议>指的是驱动程序名或数据库连接机制的名称。<子名称>是一种标识数据库的方法。这里还是以JDBC-ODBC桥、Oracle和MySQL为例，它们分别是： • jdbc:odbc：数据源名 • jdbc:oracle:thin：@数据库服务器主机名:1521:SID • jdbc: MySQL:://localhost/<数据库名称>"
###### Java JDBC如何建立与数据库的连接？
问：Java JDBC如何建立与数据库的连接？
- 答："DriverManager类是JDBC的管理层，作用于用户和驱动程序之间。它跟踪可用的驱动程序，并验证每个驱动程序，查看它是否可以建立连接。另外，DriverManager类也处理诸如驱动程序登录时间限制及登录和跟踪消息的显示等事务。 打开用户名为user且密码为password的数据库连接的基本代码为： Connection connection = DriverManager.getConnection(""url"", ""username"", ""password""); 正如名称所示，该方法将建立与数据库的连接。JDBC允许用户调用DriverManager的方法getDriver()、getDrivers()和registerDriver()。但在多数情况下，让DriverManager类自行管理建立连接的细节为上策。"
###### Java JDBC如何使用Connection接口？
问：Java JDBC如何使用Connection接口？
- 答："该类对应于数据库连接对象，是JDBC操作的起点，同时也是一个JDBC事务的起点，封装了对数据库连接的操作。在一般情况下，Connetction对象是由DriverManager.getConnection()方法来得到的，程序只需要获取该方法返回的一个指向Connection对象的引用就可以对数据库进行操作了。Connection的方法比较多，但在多数情况下，程序员只需要用到下面的两个方法： • Statement createStatement()：创建一个Statement对象并返回具体的SQL命令。 • void close()：关闭数据库连接，释放资源。"
###### Java JDBC如何使用Statement接口？
问：Java JDBC如何使用Statement接口？
- 答："这是执行SQL命令的主要容器，它一次只能执行一条SQL命令。它通过3个不同的方法来执行SQL命令。 • ResultSet executeQuery(String sql)：执行SQL命令，返回一个结果集合。通常用于执行SELECT命令。 • int executeUpdate(String sql)：执行SQL命令，返回操作成功的记录条数。通常用于执行INSERT、UPDATE或DELETE命令。 • boolean execute(String sql)：执行SQL命令，返回执行结果的标志。如果值为true，表示返回了一个结果集，需要用getResultSet()方法获取这个结果集，也可以使用getMoreResults()获取子结果集。如果值为false，表示没有结果集，只需要调用getUpdateCount()方法获取记录更新的条数即可。"
###### Java JDBC如何使用PreparedStatement接口？
问：Java JDBC如何使用PreparedStatement接口？
- 答："PreparedStatement接口是Statement的子类，它具有对SQL命令进行预编译的功能，对于需要多次执行的SQL语句而言，可以提高执行效率。它用于执行带或不带输入参数的预编译SQL语句。因为PreparedStatement对象已编译过，所以执行速度要快于Statement对象。因此当需要多次调用一条SQL语句时，可以考虑使用PreparedStatement接口。它不仅继承了Statement的所有方法，同时还增加了一些方法，并更改了3个很重要的方法。它们是： • setXXX() • executeQuery() • executeUpdate() 其中，setXXX()方法中的XXX指的是该参数对应的类型。如参数是Int类型，则方法为setInt()。setXXX()方法有两个参数，第一个参数指要设置参数的位置，第二个指要设置的具体值。"
###### Java JDBC如何使用ResultSet接口？
问：Java JDBC如何使用ResultSet接口？
- 答：ResultSet是表示数据库结果集的数据表，通常通过执行查询数据库的语句生成，每当查询语句执行完成后，就会返回一个查询结果的集合给它。ResultSet对象具有指向其当前数据行的指针。最初，指针被置于第一行之前。next方法将指针移动到下一行；因为该方法在ResultSet对象中没有下一行时返回false，所以可以在while循环中使用它来迭代结果集。
###### Java JDBC Connection类中的事物处理方法有哪些？
问：Java JDBC Connection类中的事物处理方法有哪些？
- 答："• setAutoCommit(BooleanautoCommit)：设置是否自动提交事务，默认为自动提交事务，即为true，通过设置false禁止自动提交事务。 • commit()：提交事务。 • rollback()：回滚事务。"
###### Java JDBC 中访问数据库的步骤有哪些？
问：Java JDBC 中访问数据库的步骤有哪些？
- 答：
```
1.注册驱动 Class.forname("com.mysql.jdbc.Driver");//这是连接mysql数据库的驱动 
2.获取数据库连接 java.sql.Connection conn=java.sql.DriverManager.getConnection(); 
3.获取表达式 java.sql.Statement stmt=conn.createStatement("jdbc:mysql://localhost/test?useUnicode=true&characterEncoding=GBK","root","null");//三个参数分别是数据库连接的URL,用户名，密码 
4.执行SQL java.sql.ResultSet rs=stmt.executeQuery("select * from user"); 
5.显示结果集里面的数据 while(rs.next()){ System.out.println(rs.getInt(1)); System.out.println(rs.getString("username")); System.out.println(rs.getString("password")); System.out.pringln(); }//执行插入语句 //stmt.executeUpdate("insert into user values(1,'中文','345')"); 
6.释放资源 rs.close(); stmt.close(); conn.close();
```
- 答："Java中访问数据库的步骤如下： 1 注册驱动。 2 建立连接。 3 创建Statement。 4 执行SQL语句。 5 处理结果集（若SQL语句为查询语句）。 6 关闭连接。 PreparedStatement被创建时即指定了SQL语句，通常用于执行多次结构相同的SQL语句。"
###### Java中UML是啥？
问：Java中UML是啥？
- 答：最近看一些开源项目的时候，总是看到UML中的类图，一开始自己的做法就是跳过去类图的部分，不过后来又遇到了几次，就决定学习下，不能再选择逃避了，这也是一个即将优秀的程序探索者应该必备的素质。今天把自己学习到的内容记录一下（怕健忘…），相信对类图不清楚的朋友，通过读取这篇文章后也能有一个比较清晰的认识，让你看的懂，画的出。 
类图作用 类图是软件工程的统一建模语言一种静态结构图，该图描述了系统的类集合，类的属性和类之间的关系。帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。学习好类图的绘制，是一位合格的软件工程师应有的技能。
- 答：什么是UML？UML是一种标准的图形化建模语言。它是面向对象分析与设计的一种标准表示。它不是一种可视化的程序设计语言，而是一种可视化的建模语言；它不是工具或知识库的规格说明，而是一种建模语言规格说明，是一种表示的标准；UML是标准的建模语言，而不是标准的开发过程。尽管UML的应用必然以系统的开发过程为背景，但由于不同的组织和不同的应用领域，需要采取不同的开发过程，所以它不是过程也不是方法，但允许任何一种过程和方法使用它。
###### Java中为啥要使用UML？
问：Java中为啥要使用UML？
- 答：   UML是一种建模用的语言，所有的语言都是基本词汇和语法组成的，UML也不例外，UML定义了一些建立模型所需要的、表达某种特定含义的基本元素，这些元素称为元模型，UML还定义了这些元模型互相之间关系的规则，以及如何用这些元素和规则绘制图形已建立模型来影射现实世界，这些图形称为视图，UML是一种统一可视化语言，它通过以下三个步骤描绘现实世界： 
从现实世界到业务模型
从业务模型到概念模型
从概念模型到设计模型
- 答：它应用的范围非常广泛，可以描述许多类型的系统，也可以用在系统开发的不同阶段——从需求规格的说明到完成系统的测试。
###### Java中UML又如何应用呢？
问：Java中UML又如何应用呢？
- 答："UML的应用贯穿在系统开发的5个阶段中，如下所示。 • 需求分析：UML的用例视图可以表示客户的需求。 • 分析：分析阶段主要考虑所要解决的问题，可用UML的逻辑视图和动态视图来描述。类图描述系统的静态结构、协作图、状态图、序列图、活动图和状态图描述系统的动态特征。 • 设计：在设计阶段，把分析阶段的结果扩展成技术解决方案。 • 构造：在构造或程序设计阶段，把设计阶段的类转换成某种面向对象程序设计语言的代码。 • 测试：对系统的测试通常分为单元测试、集成测试、系统测试和接受测试几个不同级别。"
###### Java UML的定义包括哪些部分？
问：Java UML的定义包括哪些部分？
- 答："作为一种建模语言，UML的定义包括UML语义和UML表示法两个部分。 • UML语义：描述基于UML的精确元模型定义。元模型为UML的所有元素在语法和语义上提供了简单、一致、通用的定义性说明，使开发者能在语义上取得一致，消除了因人而异的最佳表达方法所造成的影响。此外UML还支持对元模型的扩展定义。 • UML表示法：定义UML符号的表示法，为开发者或开发工具使用这些图形符号和文本语法以及系统建模提供了标准。这些图形符号和文字所表达的是应用级的模型，在语义上它是UML元模型的实例。"
###### Java UML的组成结构是啥？
问：Java UML的组成结构是啥？
- 答："UML由视图（View）、图（Diagram）、模型元素（Model element）和通用机制（Generalmechanism）等几个部分构成。 • 视图：由多个图构成，如果要为系统建立一个完整的模型图。只需要定义一定数量的视图，每个视图表示系统的一个特殊的方面就可以了。另外视图还把建模语言和系统开发时选择的方法或过程连接起来。UML中的视图包括用例视图（Use-case View）逻辑视图（Logical View）组件视图（Component View）并发视图（Concurrency View）展开视图（Deployment View）等。 • 图：由各种图片（graph）构成用来描述一个视图的内容，UML定义了9种不同的图的类型，把它们有机地结合起来就可以描述系统的所有视图。UML中包含用例图、类图、对象图、状态图、序列图、协作图、活动图、组件图和展开图共九种。 • 模型元素：用语义元素的正式定义或确定的语句所代表的准确含义来定义。它代表了面向对象中的类、对象、消息和关系等概念。一个模型元素可以用在多个不同的图中，无论怎样使用它总是具有相同的含义和相同的符号表示。图15.3表示了面向对象成员的模型元素的符号图例。 • 通用机制：用于表示其他信息比如注释、模型元素的语义等。另外，它还提供扩展机制，使UML语言能够适应一个特殊的方法或过程或扩充至一个组织或用户。 "
###### Java UML工具有哪些？
问：Java UML工具有哪些？
- 答：当前市场上基于UML可视化建模的工具很多，例如有微软的Visio 2002、Oracle的Designer2000，还有PlayCase、CA BPWin、CA ERWin、Sybase PowerDesigner等。而RationalRose是一种比较现代的、比较受人青睐的建模工具。
###### Java MVC是什么？
问：Java MVC是什么？
- 答：mvc分别是模型视图和控zhidao制是一种设计模式，这种模式应用于应用程序分层开发。 
Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制专器。 
View（视图） - 视图代表模型包含的数据的可视化。 
Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离属开。
- 答："MVC是一个设计模式，它包括3类对象。 模型（Model）对象：是应用程序的主体部分，主要是进行数据和业务规则的处理，例如：EJB。 视图（View）对象：是应用程序中负责生成用户界面的部分，例如：MacromediaFlash、XHTML、XML/XSL、WML等一些标识语言和Web Services。 控制器（Control）对象：是根据用户的输入，控制用户界面数据显示及更新Model对象状态的部分。即要求在Application开发中把商业逻辑、界面显示、数据分离。例如：当单击Web页面中的超链接和发送HTML表单时，控制器本身不输出任何东西。也不做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后用确定用哪个视图来显示模型处理返回的数据。"
###### Java MVC处理过程是啥？
问：Java MVC处理过程是啥？
- 答：MVC的处理过程，首先控制器接收用户的请求，并决定应该调用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器用相应的视图格式化模型返回的数据，并通过表示层呈现给用户。
###### Java Servlet技术有什么优点？
问：Java Servlet技术有什么优点？
- 答："Servlet技术有很多自己特有的优点。 高效性：主要表现在Servlet处理客户端的请求响应的效率比CGI高。 功能强大：主要表现在Servlet能够直接和Web服务器交互，而普通的CGI却不能。 可移植性好：主要表现在Servlet无须任何实质上的改动即可移植到Apache、MicrosoftIIS或其他的Web服务器上。 使用方便：主要表现在自动地解析HTML表单数据、读取和设置HTTP响应头、处理Cookie、跟踪会话状态等。"
###### Java JVM中堆是有什么作用？
问：Java JVM中堆是有什么作用？
- 答：它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。
- 答："java堆是java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 java堆是垃圾收集器管理的主要区域，因此也被成为“GC堆”（Garbage Collected Heap）。从内存回收角度来看java堆可分为：新生代和老生代（当然还有更细致的划分，在下一章会讲到）。从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。无论怎么划分，都与存放内容无关，无论哪个区域，存储的都是对象实例，进一步的划分都是为了更好的回收内存，或者更快的分配内存。 根据Java虚拟机规范的规定，java堆可以处于物理上不连续的内存空间中。当前主流的虚拟机都是可扩展的（通过 -Xmx 和 -Xms 控制）。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。"
###### Java JVM中Java虚拟机栈有什么作用？
问：Java JVM中Java虚拟机栈有什么作用？
- 答："java虚拟机也是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 咱们常说的堆内存、栈内存中，栈内存指的就是虚拟机栈。局部变量表存放了编译期可知的各种基本数据类型（8个基本数据类型）、对象引用（地址指针）、returnAddress类型。 局部变量表所需的内存空间在编译期间完成分配。在运行期间不会改变局部变量表的大小。 这个区域规定了两种异常状态：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，在扩展是无法申请到足够的内存，就会抛出OutOfMemoryError异常。"
###### Java JVM中本地方法栈（Native Method Stack）有什么作用？
问：Java JVM中本地方法栈（Native Method Stack）有什么作用？
- 答：本地方法栈与虚拟机栈所发挥作用非常相似，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的native方法服务。本地方法栈也是抛出两个异常。
###### Java JVM中方法区（Method Area）有什么作用？
问：Java JVM中方法区（Method Area）有什么作用？
- 答：方法区与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。它有个别命叫Non-Heap（非堆）。当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。
###### Java JVM中直接内存（Direct Memory）有什么作用？
问：Java JVM中直接内存（Direct Memory）有什么作用？
- 答：直接内存不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。但这部分区域也被频繁使用，而且也可能导致OutOfMemoryError异常 在JDK1.4中新加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。
###### Java JVM中运行时常量池有什么作用？
问：Java JVM中运行时常量池有什么作用？
- 答：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在加载后进入方法区的运行时常量池中存放。
###### Java JVM中程序计数器有什么作用？
问：Java JVM中程序计数器有什么作用？
- 答：程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。称之为“线程私有”的内存。程序计数器内存区域是虚拟机中唯一没有规定OutOfMemoryError情况的区域。
###### Java JVM中执行引擎有什么作用？
问：Java JVM中执行引擎有什么作用？
- 答：虚拟机核心的组件就是执行引擎，它负责执行虚拟机的字节码，一般会先进行编译成机器码后执行。
###### Java JVM中垃圾回收机制原理是啥？
问：Java JVM中垃圾回收机制原理是啥？
- 答：不定时去堆内存中清理不可达对象。不可达的对象并不会马上就会直接回收， 垃圾收集器在一个Java程序中的执行是自动的，不能强制执行，即使程序员能明确地判断出有一块内存已经无用了，是应该回收的，程序员也不能强制垃圾收集器回收该内存块。程序员唯一能做的就是通过调用System.gc 方法来"建议"执行垃圾收集器，但其是否可以执行，什么时候执行却都是不可知的。
###### Java中finalize方法作用是啥？
问：Java中finalize方法作用是啥？
- 答：Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在Object类中定义的，因此所有的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。
###### Java JVM中新生代与老年代是指什么？
问：Java JVM中新生代与老年代是指什么？
- 答："Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。 在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。 这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。 堆的内存模型大致为： image 默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。 默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。 根据垃圾回收机制的不同，Java堆有可能拥有不同的结构，最为常见的就是将整个Java堆分为 新生代和老年代。其中新生带存放新生的对象或者年龄不大的对象，老年代则存放老年对象。 新生代分为den区、s0区、s1区，s0和s1也被称为from和to区域，他们是两块大小相等并且可以互相角色的空间。 绝大多数情况下，对象首先分配在eden区，在新生代回收后，如果对象还存活，则进入s0或s1区，之后每经过一次 新生代回收，如果对象存活则它的年龄就加1，对象达到一定的年龄后，则进入老年代。"
###### Java JVM如何判断对象是否存活？
问：Java JVM如何判断对象是否存活？
- 答：JVM判断对象是否存活有两种算法：引用计数法和根搜索算法。
###### Java JVM 引用计数法是什么？
问：Java JVM 引用计数法是什么？
- 答：引用计数法就是如果一个对象没有被任何引用指向，则可视之为垃圾。这种方法的缺点就是不能检测到环的存在。 首先需要声明，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存。 什么是引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加１；当引用失效时，计数器值减１.任何时刻计数器值为０的对象就是不可能再被使用的。那为什么主流的Java虚拟机里面都没有选用这种算法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题。
###### Java JVM根搜索算法是什么？
问：Java JVM根搜索算法是什么？
- 答：根搜索算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。
###### Java JVM垃圾回收机制策略有哪些？
问：Java JVM垃圾回收机制策略有哪些？
- 答：Java JVM垃圾回收机制策略有四种：标记清除算法、复制算法、标记压缩算法和分代算法。
###### Java JVM标记清除算法是什么？
问：Java JVM标记清除算法是什么？
- 答："该算法有两个阶段。 标记阶段：找到所有可访问的对象，做个标记 清除阶段：遍历堆，把未被标记的对象回收 该算法一般应用于老年代,因为老年代的对象生命周期比较长。 标记清除算法的优点和缺点 优点 是可以解决循环引用的问题 必要时才回收(内存不足时) 缺点： 回收时，应用需要挂起，也就是stop the world。 标记和清除的效率不高，尤其是要扫描的对象比较多的时候 会造成内存碎片(会导致明明有内存空间,但是由于不连续,申请稍微大一些的对象无法做到),"
###### Java JVM复制算法是什么？
问：Java JVM复制算法是什么？
- 答："如果jvm使用了coping算法，一开始就会将可用内存分为两块，from域和to域， 每次只是使用from域，to域则空闲着。当from域内存不够了，开始执行GC操作，这个时候，会把from域存活的对象拷贝到to域,然后直接把from域进行内存清理。 coping算法一般是使用在新生代中，因为新生代中的对象一般都是朝生夕死的，存活对象的数量并不多，这样使用coping算法进行拷贝时效率比较高。jvm将Heap 内存划分为新生代与老年代，又将新生代划分为Eden(伊甸园) 与2块Survivor Space(幸存者区) ,然后在Eden –>Survivor Space 以及From Survivor Space 与To Survivor Space 之间实行Copying 算法。 不过jvm在应用coping算法时，并不是把内存按照1:1来划分的，这样太浪费内存空间了。一般的jvm都是8:1。也即是说,Eden区:From区:To区域的比例是 始终有90%的空间是可以用来创建对象的,而剩下的10%用来存放回收后存活的对象。 1、当Eden区满的时候,会触发第一次young gc,把还活着的对象拷贝到Survivor From区；当Eden区再次触发young gc的时候,会扫描Eden区和From区域,对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。 2、当后续Eden又发生young gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。 3、可见部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代 注意: 万一存活对象数量比较多，那么To域的内存可能不够存放，这个时候会借助老年代的空间。 优点:在存活对象不多的情况下，性能高，能解决内存碎片和java垃圾回收算法之-标记清除 中导致的引用更新问题。 缺点: 会造成一部分的内存浪费。不过可以根据实际情况，将内存块大小比例适当调整；如果存活对象的数量比较大，coping的性能会变得很差。"
###### Java JVM标记压缩算法是什么？
问：Java JVM标记压缩算法是什么？
- 答："标记清除算法和标记压缩算法非常相同，但是标记压缩算法在标记清除算法之上解决内存碎片化 压缩算法简单介绍 任意顺序 : 即不考虑原先对象的排列顺序，也不考虑对象之间的引用关系，随意移动对象； 线性顺序 : 考虑对象的引用关系，例如a对象引用了b对象，则尽可能将a和b移动到一块； 滑动顺序 : 按照对象原来在堆中的顺序滑动到堆的一端。 优缺点 优点:解决内存碎片问题，缺点压缩阶段，由于移动了可用对象，需要去更新引用。"
###### Java JVM分代算法是什么？
问：Java JVM分代算法是什么？
- 答："这种算法，根据对象的存活周期的不同将内存划分成几块，新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。可以用抓重点的思路来理解这个算法。 新生代对象朝生夕死,对象数量多，只要重点扫描这个区域，那么就可以大大提高垃圾收集的效率。另外老年代对象存储久，无需经常扫描老年代，避免扫描导致的开销。 新生代 在新生代，每次垃圾收集器都发现有大批对象死去，只有少量存活，采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；可以参看我之前写的java垃圾回收算法之-coping复制 老年代 而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须“标记－清除-压缩”算法进行回收。参看java垃圾回收算法之-标记_清除压缩 新创建的对象被分配在新生代，如果对象经过几次回收后仍然存活，那么就把这个对象划分到老年代。 老年代区存放Young区Survivor满后触发minor GC后仍然存活的对象，当Eden区满后会将存活的对象放入Survivor区域，如果Survivor区存不下这些对象，GC收集器就会将这些对象直接存放到Old区中，如果Survivor区中的对象足够老，也直接存放到Old区中。如果Old区满了，将会触发Full GC回收整个堆内存。"
###### Java JVM参数配置有哪些？
问：Java JVM参数配置有哪些？
- 答："‘-XX:+PrintGC 每次触发GC的时候打印相关日志 -XX:+UseSerialGC 串行回收 -XX:+PrintGCDetails 更详细的GC日志 -Xms 堆初始值 -Xmx 堆最大可用值 -Xmn 新生代堆最大可用值 -XX:SurvivorRatio 用来设置新生代中eden空间和from/to空间的比例. -XX:NewRatio 配置新生代与老年代占比 1:2 含以-XX:SurvivorRatio=eden/from=den/to 总结:在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等， 这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。 -XX:SurvivorRatio 用来设置新生代中eden空间和from/to空间的比例."
###### Java堆溢出应该如何处理？
问：Java堆溢出应该如何处理？
- 答：错误原因: java.lang.OutOfMemoryError: Java heap space 堆内存溢出 解决办法:设置堆内存大小 // -Xms1m -Xmx10m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError // -Xms1m -Xmx10m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError
###### Java虚拟机栈溢出应该如何处理？
问：Java虚拟机栈溢出应该如何处理？
- 答：错误原因: java.lang.StackOverflowError 栈内存溢出 栈溢出 产生于递归调用，循环遍历是不会的，但是循环方法里面产生递归调用， 也会发生栈溢出。 解决办法:设置线程最大调用深度 -Xss5m 设置最大调用深度
###### Java内存溢出与内存泄漏区别在哪？
问：Java内存溢出与内存泄漏区别在哪？
- 答：Java内存泄漏就是没有及时清理内存垃圾，导致系统无法再给你提供内存资源（内存资源耗尽）； 而Java内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 内存溢出，这个好理解，说明存储空间不够大。就像倒水倒多了，从杯子上面溢出了来了一样。 内存泄漏，原理是，使用过的内存空间没有被及时释放，长时间占用内存，最终导致内存空间不足，而出现内存溢出。
###### Java Volatile与Synchronized区别在哪？
问：Java Volatile与Synchronized区别在哪？
- 答："（1）从而我们可以看出volatile虽然具有可见性但是并不能保证原子性。 （2）性能方面，synchronized关键字是防止多个线程同时执行一段代码，就会影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized。 但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。"
###### Java重排序是啥？
问：Java重排序是啥？
- 答："如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型： 名称 代码示例 说明 写后读 a = 1;b = a; 写一个变量之后，再读这个位置。 写后写 a = 1;a = 2; 写一个变量之后，再写这个变量。 读后写 a = b;b = 1; 读一个变量之后，再写这个变量。"
###### Java内存模型是啥？
问：Java内存模型是啥？
- 答："共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入时,能对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 定义了一个线程对另一个线程可见。共享变量存放在主内存中，每个线程都有自己的本地内存，当多个线程同时访问一个数据的时候，可能本地内存没有及时刷新到主内存，所以就会发生线程安全问题。"
###### Java多线程三大特性是啥？
问：Java多线程三大特性是啥？
- 答：原子性，可见性，有序性
- 答："原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。、 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性：程序执行的顺序按照代码的先后顺序执行。 一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的 显然重排序对单线程运行是不会有任何问题，而多线程就不一定了，所以我们在多线程编程时就得考虑这个问题了。"
###### Java如何解决多线程之间线程安全问题？
问：Java如何解决多线程之间线程安全问题？
- 答：使用多线程之间同步synchronized或使用锁(lock)。
###### Java为什么使用线程同步或使用锁能解决线程安全问题呢？
问：Java为什么使用线程同步或使用锁能解决线程安全问题呢？
- 答：将可能会发生数据冲突问题(线程不安全问题)，只能让当前一个线程进行执行。代码执行完成后释放锁，让后才能让其他线程进行执行。这样的话就可以解决线程不安全问题。
###### Java中多线程之间同步是什么？
问：Java中多线程之间同步是什么？
- 答：因 为 多 线 程 给 你 提 ?copy; 了 程 序 的 异 步 执 行 的 功 能， 所 以 在 必 要 时 必 须 还 提 ?copy; 一 种e799bee5baa6e58685e5aeb931333238653361 同 步 机 制。 例 如， 你 想 两 个 线 程 通 讯 并 共 享 一 个 复 杂 的 数 据 结 构， 你 需 要 一 种 机 制 让 他 们 相 互 牵 制 并 正 确 执 行。 为 这 个 目 的，Java用 一 种 叫 监 视 器(monitor)的 机 制 实 现 了 进 程 间 的 异 步 执 行。 可 以 将 监 视 器 看 作 是 一 个 很 小 的 盒 子， 它 只 能 容 纳 一 个 线 程。 一 ?copy; 一 个 线 程 进 入 一 个 监 视 器， 所 有 其 他 线 程 必 须 等 到 第 一 个 线 程 退 出 监 视 器 后 才 能 进 入。 这 ?copy; 监 视 器 可 以 设 计 成 保 护 共 享 的 数 据 不 被 多 个 线 程 同 时 操 作。 大 多 数 多 线 程 系 统 将 这 ?copy; 监 视 器 设 计 成 对 象，Java提 ?copy; 了 一 种 更 清 晰 的 解 决 方 案。 没 有Monitor类； 每 个 对 象 通 过 将 他 们 的 成 员 函 数 定 义 成synchronized来 定 义 自 己 的 显 式 监 视 器， 一 ?copy; 一 个 线 程 执 行 在 一 个synchronized函 数 里， 其 他 任 何 线 程 都 不 能 调 用 同 一 个 对 象 的 synchronized函 数。
- 答：当多个线程共享同一个资源,不会受到其他线程的干扰。
###### Java 计数器 CountDownLatch有啥作用？
问：Java 计数器 CountDownLatch有啥作用？
- 答：CountDownLatch 类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。
###### Java 屏障 CyclicBarrier有啥作用？
问：Java 屏障 CyclicBarrier有啥作用？
- 答：CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续。 CyclicBarrier就象它名字的意思一样，可看成是个障碍， 所有的线程必须到齐后才能一起通过这个障碍。 CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到后，所有其它线程被唤醒前被执行。
###### Java 计数信号量 Semaphore有啥作用？
问：Java 计数信号量 Semaphore有啥作用？
- 答：Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。
###### Java在并发队列上JDK提供了你哪些实现？
问：Java在并发队列上JDK提供了你哪些实现？
- 答：在并发队列上JDK提供了两套实现，一个是以ConcurrentLinkedQueue为代表的高性能队 列非阻塞队列，一个是以BlockingQueue接口为代表的阻塞队列，无论哪种都继承自Queue。
###### Java阻塞队列与非阻塞队列的区别在哪？
问：Java阻塞队列与非阻塞队列的区别在哪？
- 答：阻塞队列与普通队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来
###### Java并发队列ConcurrentLinkedQueue如何使用？
问：Java并发队列ConcurrentLinkedQueue如何使用？
- 答：ConcurrentLinkedQueue : 是一个适用于高并发场景下的队列，通过无锁的方式，实现 了高并发状态下的高性能，通常ConcurrentLinkedQueue性能好于BlockingQueue.它 是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则。头是最先 加入的，尾是最近加入的，该队列不允许null元素。 ConcurrentLinkedQueue重要方法: add 和offer() 都是加入元素的方法(在ConcurrentLinkedQueue中这俩个方法没有任何区别) poll() 和peek() 都是取头元素节点，区别在于前者会删除元素，后者不会。
###### Java并发队列ArrayBlockingQueue如何使用？
问：Java并发队列ArrayBlockingQueue如何使用？
- 答：ArrayBlockingQueue是一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。 ArrayBlockingQueue是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。
###### Java并发队列LinkedBlockingQueue如何使用？
问：Java并发队列LinkedBlockingQueue如何使用？
- 答：LinkedBlockingQueue阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为Integer.MAX_VALUE的容量 。它的内部实现是一个链表。 和ArrayBlockingQueue一样，LinkedBlockingQueue 也是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。
###### Java并发队列PriorityBlockingQueue如何使用？
问：Java并发队列PriorityBlockingQueue如何使用？
- 答：PriorityBlockingQueue是一个没有边界的队列，它的排序规则和 java.util.PriorityQueue一样。需要注意，PriorityBlockingQueue中允许插入null对象。 所有插入PriorityBlockingQueue的对象必须实现 java.lang.Comparable接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。 另外，我们可以从PriorityBlockingQueue获得一个迭代器Iterator，但这个迭代器并不保证按照优先级顺序进行迭代。 下面我们举个例子来说明一下，首先我们定义一个对象类型，这个对象需要实现Comparable接口：
###### Java并发队列SynchronousQueue如何使用？
问：Java并发队列SynchronousQueue如何使用？
- 答：SynchronousQueue队列内部仅允许容纳一个元素。当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。
###### Java如何使用BlockingQueue模拟生产者与消费者？
问：Java如何使用BlockingQueue模拟生产者与消费者？
- 答：
```
" package com.stardust.study.demo.se.multithread; 
import org.apache.commons.lang3.StringUtils; 
import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; 
public class ProductDemo { public static void main(String[] args) { BlockingQueue
 
   blockingQueue = new LinkedBlockingQueue<>(3); ProductThread productThread = new ProductThread(blockingQueue); ConsumerThread consumerThread = new ConsumerThread(blockingQueue); Thread p = new Thread(productThread); Thread c = new Thread(consumerThread); p.start(); c.start(); try { Thread.sleep(2 * 1000); productThread.stop(); } catch (InterruptedException e) { e.printStackTrace(); } } }
  
class ProductThread implements Runnable{ private BlockingQueue
 
   blockingQueue; private AtomicInteger atomicInteger = new AtomicInteger(); private volatile boolean flag = true;
  
ProductThread(BlockingQueue<String> blockingQueue){
    this.blockingQueue = blockingQueue;
}

@Override
public void run() {
    System.out.println(""线程："" + Thread.currentThread().getName() + ""，生产者开始执行"");
    while (flag){
        String count = atomicInteger.incrementAndGet() + """";
        try {
            boolean offer = blockingQueue.offer(count, 2, TimeUnit.SECONDS);
            if(offer) {
                System.out.println(""线程："" + Thread.currentThread().getName() + ""，生产者添加元素成功"");
            }else {
                System.out.println(""线程："" + Thread.currentThread().getName() + ""，生产者添加元素失败"");
            }
        } catch (Exception e) {

        }
    }
    System.out.println(""线程："" + Thread.currentThread().getName() + ""，生产者结束执行"");
}
public void stop(){
    this.flag = false;
}
 
} 
class ConsumerThread implements Runnable{ private BlockingQueue
 
   blockingQueue; private volatile boolean flag = true;
  
ConsumerThread(BlockingQueue<String> blockingQueue){
    this.blockingQueue = blockingQueue;
}

@Override
public void run() {
    System.out.println(""线程："" + Thread.currentThread().getName() + ""，消费者开始执行"");
    while (flag){
        try {
            String count = blockingQueue.poll(2, TimeUnit.SECONDS);
            if(StringUtils.isBlank(count)) {
                this.flag = false;
                System.out.println(""线程："" + Thread.currentThread().getName() + ""，消费者超过两秒没有获取消息"");
                return;
            }
            System.out.println(""线程："" + Thread.currentThread().getName() + ""，消费者成功获取消息："" + count);
        } catch (Exception e) {

        }
    }
}
 
}"
```
###### Java线程池有哪些创建方式？
问：Java线程池有哪些创建方式？
- 答："线程池四种创建方式 newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor:创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。"
###### Java线程池原理是啥？
问：Java线程池原理是啥？
- 答：java中的线程池是运用场景最多的并发框架。在开发过程中，合理的使用线程池能够带来下面的一些好处： 1、降低资源的消耗。 2、提高响应速度。 3、提高线程的可管理型。
- 答：提交一个任务到线程池中，线程池的处理流程如下： 1、判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。 2、线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。 3、判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。
###### Java如何自定义线程线程池？
问：Java如何自定义线程线程池？
- 答："如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务； 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务； 如果队列已经满了，则在总线程数不大于maximumPoolSize的前提下，则创建新的线程 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理； 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。 ThreadPoolExecutor executor = new ThreadPoolExecutor(1,2,60L, TimeUnit.MINUTES, new ArrayBlockingQueue<>(3)); for(int i = 0;i<10;i++){ executor.execute(() -> {<!-- --> 
});
 
} executor.shutdown();"
###### Java如何合理配置线程池?
问：Java如何合理配置线程池?
- 答："CPU密集:CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。 CPU密集任务只有在真正的多核CPU上才可能得到加速(通过多线程)，而在单核CPU上，无论你开几个模拟的多线程，该任务都不可能得到加速，因为CPU总的运算能力就那些。 IO密集:IO密集型，即该任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。所以在IO密集型任务中使用多线程可以大大的加速程序运行，即时在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。"
###### Java中一个典型的SpringBoot应用长什么样子呢？
问：Java中一个典型的SpringBoot应用长什么样子呢？
- 答："如果我们使用http://start.spring.io/创建一个最简单的依赖Web模块的SpringBoot应用，一般情况下，我们会得到一个SpringBoot应用的启动类，如下面代码所示： @SpringBootApplication public class StudyApplication { public static void main(String[] args) { SpringApplication.run(StudyApplication.class, args); } }"
###### Java @SpringBootApplication应该如何理解？
问：Java @SpringBootApplication应该如何理解？
- 答："@SpringBootApplication是一个“三体”结构，实际上它是一个复合Annotation：虽然它的定义使用了多个Annotation进行元信息标注，但实际上对于SpringBoot应用来说，重要的只有三个Annotation，而“三体”结构实际上指的就是这三个Annotation：@Configuration@Enable Auto Configuration@Component Scan所以，如果我们使用如下的SpringBoot启动类，整个SpringBoot应用依然可以与之前的启动类功能对等： @Configuration @EnableAutoConfiguration @ComponentScan"
###### Java @Configuration应该如何理解？
问：Java @Configuration应该如何理解？
- 答：这里的@Configuration对我们来说并不陌生，它就是JavaConfig形式的Spring IoC容器的配置类使用的那个@Configuration，既然SpringBoot应用骨子里就是一个Spring应用，那么，自然也需要加载某个IoC容器的配置，而SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，很明显，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类！很多SpringBoot的代码示例都喜欢在启动类上直接标注@Configuration或者@SpringBootApplication。
###### Java @EnableAutoConfiguration应该如何理解？
问：Java @EnableAutoConfiguration应该如何理解？
- 答：@EnableAutoConfiguration其实也没啥“创意”，各位是否还记得Spring框架提供的各种名字为@Enable开头的Annotation定义？比如@EnableScheduling、@EnableCaching、@EnableMBeanExport等，@EnableAutoConfiguration的理念和“做事方式”其实一脉相承，简单概括一下就是，借助@Import的支持，收集和注册特定场景相关的bean定义：@Enable Scheduling是通过@Import将Spring调度框架相关的bean定义都加载到IoC容器。@Enable M Bean Export是通过@Import将JMX相关的bean定义加载到IoC容器。而@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，仅此而已！
###### Java @ComponentScan应该如何理解？
问：Java @ComponentScan应该如何理解？
- 答：为啥说@Component Scan是可有可无的？因为原则上来说，作为Spring框架里的“老一辈革命家”, @Component Scan的功能其实就是自动扫描并加载符合条件的组件或bean定义，最终将这些bean定义加载到容器中。加载bean定义到Spring的IoC容器，我们可以手工单个注册，不一定非要通过批量的自动扫描完成，所以说@Component Scan是可有可无的。
###### Java Spring Application执行流程有哪些？
问：Java Spring Application执行流程有哪些？
- 答："1）如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先需要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例run方法。在SpringApplication实例初始化的时候，它会提前做几件事情：根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型，还是应该创建一个标准Standalone应用使用的ApplicationContext类型。使用Spring Factories Loader在应用的classpath中查找并加载所有可用的ApplicationContext Initializer。使用Spring Factories Loader在应用的classpath中查找并加载所有可用的ApplicationListener。推断并设置main方法的定义类。 2）SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener，调用它们的started()方法，告诉这些SpringApplicationRunListener, “嘿，SpringBoot应用要开始执行咯！”。 3）创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。 4）遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉它们：“当前SpringBoot应用使用的Environment准备好咯！”。 5）如果SpringApplication的showBanner属性被设置为true，则打印banner（SpringBoot1.3.x版本，这里应该是基于Banner.Mode决定banner的打印行为）。这一步的逻辑其实可以不关心，我认为唯一的用途就是“好玩”（Just For Fun）。 6）根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。 7）ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize (applicationContext)方法来对已经创建好的ApplicationContext进行进一步的处理。 8）遍历调用所有SpringApplicationRunListener的contextPrepared()方法，通知它们：“SpringBoot应用使用的ApplicationContext准备好啦！” 9）最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。 10）遍历调用所有SpringApplicationRunListener的contextLoaded()方法，告知所有SpringApplicationRunListener, ApplicationContext""装填完毕""！ 11）调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。 12）查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。 13）正常情况下，遍历执行SpringApplicationRunListener的finished()方法，告知它们：“搞定！”。（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）。 至此，一个完整的SpringBoot应用启动完毕！"
###### Java SpringBoot应用如何添加自定义的ApplicationListener？
问：Java SpringBoot应用如何添加自定义的ApplicationListener？
- 答："如果我们要为SpringBoot应用添加自定义的ApplicationListener，有两种方式： 1）通过SpringApplication.addListeners(..)或者SpringApplication.setListeners(..)方法添加一个或者多个自定义的ApplicationListener； 2）借助SpringFactoriesLoader机制，在META-INF/spring.factories文件中添加配置；"
###### Java SpringBoot如何实现基于条件的自动配置？
问：Java SpringBoot如何实现基于条件的自动配置？
- 答：SpringBoot的核心就是自动配置，自动配置又是基于条件判断来配置Bean。关于自动配置的源码在spring-boot-autoconfigure-2.0.3.RELEASE.jar SpringBoot运行原理 先看@SpringBootApplication 
@SpringBootConfiguration：标记当前类为配置类 @EnableAutoConfiguration：开启自动配置 @ComponentScan：扫描主类所在的同级包以及下级包里的Bean 关键是@EnableAutoConfiguration 接下来解读下吧。。
- 答："基于条件的自动配置来源于Spring框架中“基于条件的配置”这一特性。在Spring框架中，我们可以使用@Conditional这个Annotation配合@Configuration或者@Bean等Annotation来干预一个配置或者bean定义是否能够生效，其最终实现的效果或者语义类似于如下伪代码： if(符合@Conditional规定条件){ 加载当前配置或者注册当前bean定义; } 要实现基于条件的配置，我们只要通过@Conditional指定自己的Condition实现类就可以了（可以应用于类型Type的标注或者方法Method的标注）： @Conditional({MyCondition1.class, MyCondition2.class}) 最主要的是，@Conditional可以作为一个Meta Annotation用来标注其他Annotation实现类，从而构建各色的复合Annotation，比如SpringBoot的autoconfigure模块就基于这一优良的革命传统，实现了一批这样的Annotation （位于org.springframework.boot.autoconfigure.condition包下）：@Conditional On Class@Conditional On Bean@Conditional On Missing Class@Conditional On Missing Bean@Conditional On Property……有了这些复合Annotation的配合，我们就可以结合@EnableAuto-Configurationn实现基于条件的自动配置了。SpringBoot能够风靡，很大一部分功劳需要归功于它预先提供的一系列自动配置的依赖模块，而这些依赖模块都是基于以上@Conditional复合Annotation实现的，这也意味着所有的这些依赖模块都是按需加载的，只有符合某些特定条件，这些依赖模块才会生效，这也就是我们所谓的“智能”自动配置。"
###### Java SpringBoot如何调整自动配置的顺序？
问：Java SpringBoot如何调整自动配置的顺序？
- 答："在实现自动配置的过程中，除了可以提供基于条件的配置，我们还可以对当前要提供的配置或者组件的加载顺序进行相应调整，从而让这些配置或者组件之间的依赖分析和组装可以顺利完成。我们可以使用@org.springframework.boot.autoconfigure.AutoConfigureBefore或者@org.springframework.boot.autoconfigure.AutoConfigureAfter让当前配置或者组件在某个其他组件之前或者之后进行，比如，假设我们希望某些JMX操作相关的bean定义在MBeanServer配置完成之后进行，那么我们就可以提供一个类似如下的配置： @Configuration @AutoConfigureAfter(JmxAutoConfiguration.class) public class AfterMBeanServerReadyConfiguration(){ @Autowired JmxMBeanServer mBeanServer; // 通过@Bean添加必要的bean定义 }"
###### Java SpringBoot对开发者有哪些影响？
问：Java SpringBoot对开发者有哪些影响？
- 答：Spring Boot继承了Spring的优点，并新增了一些新功能和特性： 
（1）SpringBoot是伴随着Spring4.0诞生的，一经推出，引起了巨大的反向； 
（2）从字面理解，Boot是引导的意思，因此SpringBoot帮助开发者快速搭建Spring框架； 
（3）SpringBoot帮助开发者快速启动一个Web容器； 
（4）SpringBoot继承了原有Spring框架的优秀基因； 
（5）SpringBoot简化了使用Spring的过程； 
（6）Spring Boot为我们带来了脚本语言开发的效率，但是Spring Boot并没有让我们意外的新技术，都是Java EE开发者常见的额技术。
- 答："SpringBoot微框架从两个主要层面影响Spring社区的开发者们： 1）基于Spring框架的“约定优先于配置（COC）”理念以及最佳实践之路。 2）提供了针对日常企业应用研发各种场景的spring-boot-starter自动配置依赖模块，如此多“开箱即用”的依赖模块，使得开发各种场景的Spring应用更加快速和高效。"
###### 对SpringBoot的行为进行干预的配置方式有哪些？
问：对SpringBoot的行为进行干预的配置方式有哪些？
- 答："简单来讲，我们可以将对SpringBoot的行为可以进行干预的配置方式划分为几类： 命令行参数（Command Line Args）。 系统环境变量（Environment Variables）。 位于文件系统中的配置文件。 位于classpath中的配置文件。 固化到代码中的配置项。 为了简化，其他比较少见场景的配置方式不在这里罗列。总的来说，以上几种方式按照优先级从高到低排列，高优先级方式提供的配置项可以覆盖或者优先生效，比如通过命令行参数传入的配置项会覆盖通过环境变量传入的同一配置项，当然也会覆盖其他后面几种方式给出的同一配置项。"
###### Java 正则表达式是什么?
问：Java 正则表达式是什么?
- 答：正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。在众多语言中都可以支持正则表达式，如Perl、PHP、Java、Python、Ruby等。当然在Java中也可以通过处理字符串的方式达到检索，替换文本字符串的目的，但是有了正则表达式写代码更加简洁，通常两三行代码就可以达到目的，当然这也是建立在熟悉正则表达式的基础之上的。
- 答：正则表达式是一串字符，它描述了一个文本模式，利用它可以方便地处理文本，包括文本的查找、替换、验证、切分等。正则表达式中的字符有两类：一类是普通字符，就是匹配字符本身；另一类是元字符，这些字符有特殊含义，这些元字符及其特殊含义构成了正则表达式的语法。
###### Java正则表达式的语法组成部分有哪些？
问：Java正则表达式的语法组成部分有哪些？
- 答："❑ 单个字符； ❑ 字符组； ❑ 量词； ❑ 分组； ❑ 特殊边界匹配； ❑ 环视边界匹配。"
###### Java正则表达式单个字符如何使用？
问：Java正则表达式单个字符如何使用？
- 答：
```
"大部分的单个字符就是用字符本身表示的，比如字符'0'、'3'、'a'、'马'等，但有一些单个字符使用多个字符表示，这些字符都以斜杠''开头，比如： 1）特殊字符，比如tab字符'\t'、换行符'\n'、回车符'\r'等。 2）八进制表示的字符，以\0开头，后跟1～3位数字，比如\0141，对应的是ASCII编码为97的字符，即字符'a'。 3）十六进制表示的字符，以\x开头，后跟两位字符，比如\x6A，对应的是ASCII编码为106的字符，即字符'j'。 4）Unicode编号表示的字符，以\u开头，后跟4位字符，比如\u9A6C，表示的是中文字符'马'，这只能表示编号在0xFFFF以下的字符，如果超出0ⅩFFFF，使用\x{...}形式，比如\x{1f48e}。 5）斜杠\本身，斜杠\是一个元字符，如果要匹配它自身，使用两个斜杠表示，即'\'。 6）元字符本身，除了''，正则表达式中还有很多元字符，比如．、*、? 、+等，要匹配这些元字符自身，需要在前面加转义字符''，比如'.'。"
```
###### Java正则表达式字符组如何使用？
问：Java正则表达式字符组如何使用？
- 答：
```
"字符组有多种，包括任意字符、多个指定字符之一、字符区间、排除型字符组、预定义的字符组等，下面具体介绍。 点号字符'.'是一个元字符，默认模式下，它匹配除了换行符以外的任意字符。 在单个字符和任意字符之间，有一个字符组的概念，匹配组中的任意一个字符，用中括号[]表示。 为方便表示连续的多个字符，字符组中可以使用连字符'-' 字符组支持排除的概念，在[后紧跟一个字符^ 在字符组中，除了^、-、[ ]、\外，其他在字符组外的元字符不再具备特殊含义，变成了普通字符，比如字符'.'和'＊', [.*]就是匹配'.'或者'*'本身。"
```
###### Java正则表达式量词如何使用？
问：Java正则表达式量词如何使用？
- 答：
```
"量词指的是指定出现次数的元字符，有三个常见的元字符：+、<em>、? ： 1）+：表示前面字符的一次或多次出现，比如正则表达式ab+c，既能匹配abc，也能匹配abbc，或abbbc。 2）</em>：表示前面字符的零次或多次出现，比如正则表达式ab*c，既能匹配abc，也能匹配ac，或abbbc。 3）? ：表示前面字符可能出现，也可能不出现，比如正则表达式ab? c，既能匹配abc，也能匹配ac，但不能匹配abbc。"
```
###### Java正则表达式分组如何使用？
问：Java正则表达式分组如何使用？
- 答："表达式可以用括号()括起来，表示一个分组，比如a(bc)d, bc就是一个分组。分组可以嵌套，比如a(de(fg))。分组默认都有一个编号，按照括号的出现顺序，从1开始，从左到右依次递增，比如表达式：a(bc)((de)(fg)) 字符串abcdefg匹配这个表达式，第1个分组为bc，第2个为defg，第3个为de，第4个为fg。分组0是一个特殊分组，内容是整个匹配的字符串，这里是abcdefg。分组匹配的子字符串可以在后续访问，好像被捕获了一样，所以默认分组称为捕获分组。关于如何在Java中访问和使用捕获分组，我们下节再介绍。可以对分组使用量词，表示分组的出现次数，比如a(bc)+d，表示bc出现一次或多次。"
###### Java正则表达式特殊边界匹配如何使用？
问：Java正则表达式特殊边界匹配如何使用？
- 答：在正则表达式中，除了可以指定字符需满足什么条件，还可以指定字符的边界需满足什么条件，或者说匹配特定的边界，常用的表示特殊边界的元字符有^、$、\A、\Z、\z和\b。默认情况下，^匹配整个字符串的开始，^abc表示整个字符串必须以abc开始。需要注意的是^的含义，在字符组中它表示排除，但在字符组外，它匹配开始，比如表达式^[^abc]，表示以一个不是a、b、c的字符开始。默认情况下，$匹配整个字符串的结束，不过，如果整个字符串以换行符结束，$匹配的是换行符之前的边界，比如表达式abc$，表示整个表达式以abc结束，或者以abc\r\n或abc\n结束。以上^和$的含义是默认模式下的，可以指定另外一种匹配模式：多行匹配模式，在此模式下，会以行为单位进行匹配，^匹配的是行开始，$匹配的是行结束，比如表达式是^abc$，字符串是"abc\nabc\r\n"，就会有两个匹配。
###### Java正则表达式环视边界匹配如何使用？
问：Java正则表达式环视边界匹配如何使用？
- 答："对于边界匹配，除了使用上面介绍的边界元字符，还有一种更为通用的方式，那就是环视。环视的字面意思就是左右看看，需要左右符合一些条件，本质上，它也是匹配边界，对边界有一些要求，这个要求是针对左边或右边的字符串的。根据要求不同，分为4种环视： 1）肯定顺序环视，语法是(? =...)，要求右边的字符串匹配指定的表达式。比如表达式abc(?=def), (? =def)在字符c右面，即匹配c右面的边界。对这个边界的要求是：它的右边有def，比如abcdef，如果没有，比如abcd，则不匹配。 2）否定顺序环视，语法是(? ! ...)，要求右边的字符串不能匹配指定的表达式。比如表达式s(? !ing)，匹配一般的s，但不匹配后面有ing的s。注意：避免与排除型字符组混淆，比如s[^ing],s[^ing]匹配的是两个字符，第一个是s，第二个是i、n、g以外的任意一个字符。 3）肯定逆序环视，语法是(? <=...)，要求左边的字符串匹配指定的表达式。比如表达式(?<=\s)abc, (? <=\s)在字符a左边，即匹配a左边的边界。对这个边界的要求是：它的左边必须是空白字符。 4）否定逆序环视，语法是(? <! ...)，要求左边的字符串不能匹配指定的表达式。比如表达式(?<! \w)cat, (? <! \w)在字符c左边，即匹配c左边的边界。对这个边界的要求是：它的左边不能是单词字符。"
###### Java中如何表示正则表达式？
问：Java中如何表示正则表达式？
- 答：正则表达式由元字符和普通字符组成，字符''是一个元字符，要在正则表达式中表示''本身，需要使用它转义，即'\'。在Java中，没有什么特殊的语法能直接表示正则表达式，需要用字符串表示，而在字符串中，''也是一个元字符，为了在字符串中表示正则表达式的''，就需要使用两个''，即'\'，而要匹配''本身，就需要4个''，即'\\'。
###### Java中如何进行正则表达式切分？
问：Java中如何进行正则表达式切分？
- 答：
```
"文本处理的一个常见需求是根据分隔符切分字符串，比如在处理CSV文件时，按逗号分隔每个字段，这个需求听上去很容易满足，因为String类有如下方法：sprint()。 不过，有一些重要的细节，我们需要注意。split将参数regex看作正则表达式，而不是普通的字符，如果分隔符是元字符，比如． $ | ( ) [ {^ ? * + \，就需要转义。比如按点号'.'分隔，需要写为： str.split(""\.""); Pattern也有split方法，与String方法的定义类似： 与String方法的区别如下。 1）Pattern接受的参数是CharSequence，更为通用，我们知道String、StringBuilder、StringBuffer、CharBuffer等都实现了该接口。 2）如果regex长度大于1或包含元字符，String的split方法必须先将regex编译为Pattern对象，再调用Pattern的split方法，这时，为避免重复编译，应该优先采用Pattern的方法。 3）如果regex就是一个字符且不是元字符，String的split方法会采用更为简单高效的实现，所以，这时应该优先采用String的split方法。"
```
###### Java中如何进行正则表达式验证？
问：Java中如何进行正则表达式验证？
- 答："验证就是检验输入文本是否完整匹配预定义的正则表达式，经常用于检验用户的输入是否合法。String有如下方法：matches() String的matches实际调用的是Pattern的如下方法： public static boolean matches(String regex, CharSequence input) 这是一个静态方法，它的代码为： public static boolean matches(String regex, CharSequence input) { Pattern p = Pattern.compile(regex); Matcher m = p.matcher(input); return m.matches(); } 就是先调用compile编译regex为Pattern对象，再调用Pattern的matcher方法生成一个匹配对象Matcher, Matcher的matches方法返回是否完整匹配。"
###### Java中如何进行正则表达式查找？
问：Java中如何进行正则表达式查找？
- 答："查找就是在文本中寻找匹配正则表达式的子字符串，，看个例子： public static void main(String[] args) { String regex = ""\d{4}-\d{2}-\d{2}""; Pattern pattern = Pattern.compile(regex); String str = ""today is 2017-06-02, yesterday is 2017-06-01""; Matcher matcher = pattern.matcher(str); while (matcher.find()) { System.out.println(""find "" + matcher.group() + "" position："" + matcher.start()+""-""+matcher.end()); } } 代码寻找所有类似""2017-06-02""这种格式的日期，输出为： find 2017-06-02 position：9-19 find 2017-06-01 position：34-44 Matcher的内部记录有一个位置，起始为0, find方法从这个位置查找匹配正则表达式的子字符串，找到后，返回true，并更新这个内部位置，匹配到的子字符串信息可以通过如下方法获取： public String group():匹配到的完整子字符串 public int start():子字符串的起始位置 public int end():子字符串的结束位置"
###### Java中如何进行正则表达式替换？
问：Java中如何进行正则表达式替换？
- 答："查找到子字符串后，一个常见的后续操作是替换。String有多个替换方法： public String replace(char oldChar, char newChar) public String replace(CharSequence target, CharSequence replacement) public String replaceAll(String regex, String replacement) public String replaceFirst(String regex, String replacement) 第一个replace方法操作的是单个字符，第二个是CharSequence，它们都是将参数看作普通字符。而replaceAll和replaceFirst则将参数regex看作正则表达式，它们的区别是， replaceAll替换所有找到的子字符串，而replaceFirst则只替换第一个找到的。"
###### Java8 Lambda表达式是什么？
问：Java8 Lambda表达式是什么？
- 答："Lambda 是一个匿名函数，我们可以把 Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。 将 Lambda 表达式拆分成两部分： 左侧：Lambda 表达式的参数列表 右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体"
###### Java8 Lambda表达式语法有哪些？
问：Java8 Lambda表达式语法有哪些？
- 答："语法格式一：无参数，无返回值 () -> System.out.println(“Hello Lambda!”); 语法格式二：有一个参数，并且无返回值 (x) -> System.out.println(x) 语法格式三：若只有一个参数，小括号可以省略不写 x -> System.out.println(x) 语法格式四：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句 Comparator com - (x, y) -> { System.out.println(“函数式接口”); return Integer.compare(x, y); }; 语法格式五：若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写 - omparator com = (x, y) -> Integer.compare(x, y); 语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下- 文推断出，数据类型，即“类型推断” (Integer x, Integer y) -> Integer.compare(x, y);"
###### Java如何检查是否是函数式接口？
问：Java如何检查是否是函数式接口？
- 答：Lambda 表达式需要“函数式接口”的支持 函数式接口：接口中只有一个抽象方法的接口，称为函数式接口。 可以使用注解 @FunctionalInterface 修饰 可以检查是否是函数式接口
###### Java8接口中默认方法是啥？
问：Java8接口中默认方法是啥？
- 答："Java 8 还允许我们给接口添加一个非抽象的方法实现，只需要使用 default 关键字即可，这个特征又叫做扩展方法。在实现该接口时，该默认扩展方法在子类上可以直接使用，它的使用方式类似于抽象类中非抽象成员方法。但扩展方法不能够重载 Object 中的方法。例如：toString、equals、 hashCode 不能在接口中被重载。 例如，下面接口中定义了一个默认方法 count()，该方法可以在子类中直接使用。 public interface DefaultFunInterface { //定义默认方法 count default int count(){ return 1; } } public class SubDefaultFunClass implements DefaultFunInterface { public static void main(String[] args){ //实例化一个子类对象，改子类对象可以直接调用父接口中的默认方法 count SubDefaultFunClass sub = new SubDefaultFunClass(); sub.count(); } }"
- 答：
```
在java8之前，接口中的所有方法都是abstract public的，java8引入了default关键字用来定义接口中的普通的有方法体的方法。所有实现了这个接口的类的实例都能直接执行这个普通方法，类似于继承。 
// A simple program to Test Interface default // methods in java interface TestInterface { // abstract method public void square(int a); 
// default method 
default void show() 
{ 
System.out.println("Default Method Executed"); 
} 
 
} 
class TestClass implements TestInterface { // implementation of square abstract method public void square(int a) { System.out.println(a*a); } 
public static void main(String args[]) 
{ 
	TestClass d = new TestClass(); 
	d.square(4); 

	// default method executed 
	d.show(); 
} 
 
}
```
###### Java8接口中允许定义静态方法吗？
问：Java8接口中允许定义静态方法吗？
- 答："在接口中，还允许定义静态的方法。接口中的静态方法可以直接用接口来调用。 例如，下面接口中定义了一个静态方法 find，该方法可以直接用 StaticFunInterface .find() 来调用。 public interface StaticFunInterface { public static int find(){ return 1; } } public class TestStaticFun { public static void main(String[] args){ //接口中定义了静态方法 find 直接被调用 StaticFunInterface.fine(); } }"
###### Java8集合之流式操作是啥？
问：Java8集合之流式操作是啥？
- 答："Java 8 引入了流式操作（Stream），通过该操作可以实现对集合（Collection）的并行处理和函数式操作。根据操作返回的结果不同，流式操作分为中间操作和最终操作两种。最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。根据流的并发性，流又可以分为串行和并行两种。流式操作实现了集合的过滤、排序、映射等功能。 Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。"
###### Java8流式操作中串行和并行的流有啥区别？
问：Java8流式操作中串行和并行的流有啥区别？
- 答：流有串行和并行两种，串行流上的操作是在一个线程中依次完成，而并行流则是在多个线程上同时执行。并行与串行的流可以相互切换：通过 stream.sequential() 返回串行的流，通过 stream.parallel() 返回并行的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。
- 答：并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。
###### Java8流式操作中中间操作有哪些？
问：Java8流式操作中中间操作有哪些？
- 答："该操作会保持 stream 处于中间状态，允许做进一步的操作。它返回的还是的 Stream，允许更多的链式操作。常见的中间操作有： filter()：对元素进行过滤； sorted()：对元素排序； map()：元素的映射； distinct()：去除重复元素； subStream()：获取子 Stream 等。"
- 答：中间操作（Intermediate Operations）：中间操作会返回一个新的流，一个流可以后面跟随零个或多个intermediate操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后会返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。而是在终端操作开始的时候才真正开始执行。
终端操作（Terminal Operations）：是指返回最终的结果。一个流只能有一个terminal操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。
