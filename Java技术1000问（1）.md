###### 作为一个java学习者，重复写轮子是否必要
问：当前各种功能组件越来越全，许多通用逻辑都被封装，那么重复写轮子是否有必要呢，还是说更应该专注研究如何更好的使用组件？
- 答：不求重复造轮子，但必须要知道轮子是怎么造的。
- 答：对于初学者,还是需要造一下轮子,理解轮子构造的.这是为了以后不再重复造轮子打基础!
- 答：重复写不是什么大问题，关键你要掌握轮子是咋造出来的，然后自己写轮子
- 答：看是什么阶段了，如果是初学者，那非常有必要造轮子，多造轮子，才能熟练掌握，才能知道别人的轮子好在哪里
- 答：不要。应该研究如何更好的使用组件，了解组件的原理，为啥需要这样封装，优缺点。例如spring 为什么好； 高手就学会封装，解决他现有的问题，然后不断完善 开源 集成民间高手的智慧，技术不断完善 科技改变世界
- 答：有必要，轮子都不熟练，咋能造
###### 自学三个月java能到什么程度
问：自学三个月java能到什么程度
- 答：看三个月划不划水;完整的三个月学习的话,一般的开发助理工程师程度
- 答：因人而异，强的贼强、菜的贼菜
- 答：掌握java基本语法,、了解Javaweb,熟悉一款经典框架
- 答：按个人计划，每天安排多少时间学习java 有付出必有收获，加油
- 答：这得看付出多少辛苦，脑子里有多少知识
###### 自学java看什么书
问：自学java看什么书
- 答：疯狂java讲义不错
- 答：先来基础语法，建立世界观
找个实战项目练手
练手的过程中，遇到不懂的就回过头来翻书，推荐《Java编程思想》
- 答：初学--疯狂java讲义，spring框架(spring boot)+mybatis,mysql 中级--java编程思想，java并发编程,spring源码，spring boot源码，redis,消息队列，UML 高级--java虚拟机，spring cloud微服务，docker,k8s。 等等！
- 答：推荐，java疯狂讲义把，还不错的书
- 答：Java编程思想
###### 怎么学好 java
问：怎么学好 java
- 答：多编程,多思考,程序能力在实践中变强
- 答：初期多动手，多提问 中期多看书，多总结 后期多思考 晚期快跑路
- 答：求知若渴，虚心若愚
- 答：疯狂敲代码and再疯狂敲，敲到熟悉为止
- 答：多思多看多动手
###### 怎么学java手机游戏开发软件
问：怎么学java手机游戏开发软件
- 答：勤能补拙！
- 答：有一定基础找个开源项目看实现;啥都不会 可以培训班走起~
- 答：上网查资料跟着打
- 答：java很少用来写游戏，基本上都是用Unityhe cocos比较多
- 答：首先采用java开发的少，引擎基本上很少采用java的。
###### 怎么学java
问：怎么学java
- 答：多练习,多写是王道
- 答：多敲多练习
- 答：多思多看多动手
- 答：敲得多了，自然就会了
- 答：看书学习  编码实践
###### 用什么方式学java
问：用什么方式学java
- 答：多敲代码,最好找个结伴一起讨论的!
- 答：实践出真知
- 答：疯狂敲代码，理解了，敲，反复敲
- 答：多思多看多动手
- 答：看视频，视频中老师讲解会比较形象，便于理解
###### 学习java可以做什么
问：学习java可以做什么
- 答：赚钱!!!
- 答：做网站后端和大数据平台、游戏、、、、、、
- 答：可以成就自己的人生
- 答：前后端都可以做
- 答：互联网Java可以做很多事，发挥重大作用。
###### 学完java怎么开发
问：学完java怎么开发
- 答：找工作,实践出真知
- 答：找份工作，熟练运用后就可以进一步了解框架，用不如造，争取造个框架
- 答：学完？？永远学不完的，有无穷无尽的知识，在等你
- 答：写个GUI应用程序吧
- 答：学一下java开发工具IDEA，对着教材中的一些示例写一下
###### 学完java基础后然后学什么
问：学完java基础后然后学什么
- 答：spring框架搞起
- 答：学javaee、数据库、基本前端
- 答：<img src="https://ucc.alicdn.com/pic/developer-ecology/4c61767032a0482698d09b6427e73dd3.png" alt="图片.png" /> <img src="https://ucc.alicdn.com/pic/developer-ecology/ddd25394264b4c1baa6597c0fb08cc80.png" alt="图片.png" /> <img src="https://ucc.alicdn.com/pic/developer-ecology/8847a98bc7834206a36518f354c038eb.png" alt="图片.png" /> <img src="https://ucc.alicdn.com/pic/developer-ecology/b272b1a5c0c24b46af05ac95d6e9c4a8.png" alt="图片.png" />
- 答：数据库相关、网页相关、框架相关
- 答：数据库，Java ee
###### 学了java能干什么的
问：学了java能干什么的
- 答：悄悄告诉你,淘宝曾经80%都是java代码. 只要用的好,无所不能
- 答：做javaweb,大数据平台
- 答：因为java虚拟机的功劳，用java编写的程序可以跨平台使用，用途广泛，用来建网站、做服务器、搭游戏都是可以的
- 答：学会一种思想指导人生，学会一种工具带领人生
- 答：学习java最好是先注重过程，在学习过程中思考为什么语言或框架作者要这么实现，从过程中学习到编程思想，总结一些使用方法
###### 学好java需要看什么书
问：学好java需要看什么书
- 答：疯狂java讲义 java编程思想
- 答：java核心卷一
- 答：可以看java疯狂讲义把，很不错
- 答：java编程思想
###### 学java最重要的是什么
问：学java最重要的是什么
- 答：实践出真知
- 答：耐心、恒心
- 答：敲代码，不停地敲代码
- 答：心态，坚持不懈的努力
- 答：钻研精神，学习其他的东西也一样
###### 学java之前要学什么东西吗
问：学java之前要学什么东西吗
- 答：理解计算机基础大有裨益;计算机组成原理很有用
- 答：操作系统、数据结构、计算机网络、数据库
- 答：学习java，无需先决条件，只需要懂电脑基础知识
###### 学java怎么多练啊
问：学java怎么多练啊
- 答：练项目!!不停地练项目
- 答：学完写一个小项目，例如学生关系系统
- 答：写代码，使劲多写代码
###### 学java有什么好书
问：学java有什么好书
- 答：疯狂java讲义,java编程思想
- 答：Effective Java Programming Language Guide
###### 学java需要下载什么软件
问：学java需要下载什么软件
- 答：vs code 很好用
- 答：IDEA、前期你用记事本就好了
- 答：先安装JDK，学习怎么配环境变量
准备一个普通的文本编辑器 Sublime Text 或者 VS Code
等到基础学完了，熟练掌握了，再用IDE，推荐Intellij IDEA
- 答：刚开始的时候直接用记事本敲就行了，后面建议直接上IDEA，eclipse
- 答：必备的肯定是jdk.开始可以直接尝试用文本手敲代码，熟悉熟悉环境。学习差不多了可以下载集成编程工具例如：eclipse.
###### 学java买什么电脑
问：学java买什么电脑
- 答：一般的电脑就可以,有钱可以买MacBook Pro 很好用
- 答：macbook pro吧。13寸就行，如果有充足的资金，建议15寸（大屏的舒服些）。本人使用MacBookPro敲代码接近5年了，机子不卡。没有出现过机器坏的问题。而且MacBookPro对眼睛好。长时间敲代码舒服。很多的开发类型软件都可以一个命令行安装好。不需要去管什么环境、路径杂七杂八的。舒服。
- 答：举个栗子，英雄联盟能跑的，IDE都能跑
- 答：8G起步，不需要太高的配置，但也不能太低。ThinkPad，Dell都。
- 答：顶配
###### 学java框架看什么书
问：学java框架看什么书
- 答：<<深入浅出Spring Boot2.x>>
- 答：Java权威指南
- 答：什么框架？可以先看看Spring 相关的书籍
###### 学java可以考什么证书吗
问：学java可以考什么证书吗
- 答：可以参加软考高级架构师~
- 答：全国软考软件设计师
- 答：阿里巴巴编程规范
- 答：java高级软件工程师
###### 学java可以干什么的
问：学java可以干什么的
- 答：当程序员赚钱养家,买房
- 答：JAVA程序员
###### 学java干安卓怎么样
问：学java干安卓怎么样
- 答：安卓现在大部分就是java语言开发的,OK的
- 答：现象学安卓跟49年入国军没啥区别
- 答：不好，红利期已经过了
- 答：这是什么意思
###### 学java 用什么系统电脑
问：学java 用什么系统电脑
- 答：windows,mac,linux系统都可以的
- 答：java是跨平台编程语言，在Linux和mac、windows等平台都可以使用，但推荐mac,别问，问就是爽
- 答：推荐用mac，连环境变量都不用配
- 答：java是一门跨平台的开发语言，使用windows、linux、mac都可以，各个平台都有对应的java安装包。不过个人建议使用linux、mac。因为java生产环境基本上都是linux。
###### 学java web看什么书
问：学java web看什么书
- 答：疯狂java讲义可以当入门书看
- 答：java核心卷二
- 答：基础的看 轻量级Java EE企业应用实战 
要深入的看 
深入分析Java Web技术内幕（修订版）
###### 新手自学java看什么书
问：新手自学java看什么书
- 答：疯狂java讲义
- 答：think in java
###### 小白学java看什么书
问：小白学java看什么书
- 答：疯狂java讲义
- 答：java核心技术
- 答：java编程思想
- 答：Java编程思想 Java从入门到精通 深入理解Java虚拟机
- 答：
```
head first java，图文并茂的书，而且比较符合人的认知规律，会唤起学习的本能。强烈***不建议***看 java编程思想，尤其是中文版的，翻译的不好，而且书页很沉，而且这本书已经很久没更新了，最新只到java 1.6
```
###### 为什么这么多人学java
问：为什么这么多人学java
- 答：学习门槛低,可以养家糊口
- 答：因为工作岗位高，最根本的原因就是免费、好用
- 答：可移植性高、语法规范、面向对象、功能强大
- 答：好学，易用，职位多
###### 为什么要学java web
问：为什么要学java web
- 答：做网站后端有用处
- 答：java主要就是被广泛应用于网站后端
- 答：因为Java的基本应用就是在javaweb上
- 答：从java走到java web

我们刚开始学习java的时候自娱自乐，开发的都是单机的，无论是单机游戏还是系统，在你qq聊得飞起的时候，你还能不嫌弃你开发的软件么，不考虑前期市场调查运营部分，不考虑一堆隐藏式bug和扔出的Thread，不考虑测试和UI这些令人沮丧的问题，能不能让更多人分享到你的软件，问不是搬着你的电脑到处求分享，那么web是你不二的选择
###### 为什么28岁不能学java
问：为什么28岁不能学java
- 答：当然可以学!!!
- 答：因为程序员35岁就退休了
- 答：这问题都是谁问的？
- 答：可以学，年龄不是问题
- 答：可以学的  不用害怕
###### 什么都不会怎么学java
问：什么都不会怎么学java
- 答：自律能力不强,就找个培训班.最好找人结伴学习
- 答：先学习Java基础语法，
在看看JavaWeb编程。
MySQL数据库。
看看Java高级编程，设计模式、分布式。最新的Spring Boot、Cloud、MongoDB、Redis，、微服务、大数据等。
欢迎加入阿里巴巴Java群，阿里高级专家直播，群内，超过2700人了，年后3000人。
最新《阿里巴巴Java Spring Boot 2.0开发实战课程》持续更新 完全免费
第1课：Spring Boot2.0新特性和入门实战,<a href="https://yq.aliyun.com/live/583">https://yq.aliyun.com/live/583</a> 
第2课：Spring Boot2.0开发MVC网站并显示图片,<a href="https://yq.aliyun.com/live/592">https://yq.aliyun.com/live/592</a>
第3课：Spring Boot2.0实战MySQL和3个高级面试题，<a href="https://yq.aliyun.com/live/612">https://yq.aliyun.com/live/612</a>
第4课：Spring Boot2.0实战MVC用户登录和注册和Java面试题<a href="https://yq.aliyun.com/live/644">https://yq.aliyun.com/live/644</a>
第5课：Spring Boot2.0实战三层MVC架构实战与架构分层误区(Java面试题)<a href="https://yq.aliyun.com/live/655">https://yq.aliyun.com/live/655</a>
第6课：Spring Boot2.0实战MyBatis与优化(Java面试题)<a href="https://yq.aliyun.com/live/687">https://yq.aliyun.com/live/687</a>
第7课：Spring Boot2.0安全机制、漏洞与MVC身份验证实战(Java面试题) <a href="https://yq.aliyun.com/live/712">https://yq.aliyun.com/live/712</a>
第8课：Spring Boot2.0自动化配置机制解析(Java面试题) 课件 PPT下载 <a href="https://yq.aliyun.com/live/729">https://yq.aliyun.com/live/729</a>
第9课：Spring Boot2.0实战MongoDB4.0(MongoDB面试题) <a href="https://yq.aliyun.com/live/782">https://yq.aliyun.com/live/782</a>
第10课：Spring Boot2.0实战高并发缓存Redis面试题) <a href="https://yq.aliyun.com/live/791">https://yq.aliyun.com/live/791</a>
第11课：Spring Boot2.0实战RabbitMQ中间件与API原理解析 <a href="https://yq.aliyun.com/live/806">https://yq.aliyun.com/live/806</a>
第12课：Spring Boot2.0性能监控实战与Actuator机制解析 <a href="https://yq.aliyun.com/live/815">https://yq.aliyun.com/live/815</a>
第13课：Spring Boot2.0性能监控实战ElasticSearch搜索引擎中间件 <a href="https://yq.aliyun.com/live/844">https://yq.aliyun.com/live/844</a>
第14课：Spring Boot 2.0实战MyBatis连接池阿里Druid与SQL性能监控 <a href="https://yq.aliyun.com/live/855">https://yq.aliyun.com/live/855</a>
最新《阿里巴巴Java Spring Boot 2.0开发实战课程》官方网站 完全免费
###### 女生学java有什么发展
问：女生学java有什么发展
- 答：好啊!!女程序员还是比较少的!
- 答：女生学这个，大有前途，你想那么多男的，就你一个女的，多有优势
- 答：大概率可以找到一个不抽烟、不喝酒、只挣钱不花钱又帅气就是有点呆的程序员老公
- 答：学习java不区分男女，目前java语言累计18年稳居编程语言榜首，学习java有利于未来就业
- 答：学Java不分男女，女士学习Java的优势是更细心，对技术细节更能刨根问底。
###### 你学习javaee的步骤是什么?
问：你学习javaee的步骤是什么?
- 答：敲代码->敲代码->敲代码
- 答：先了解dao等是啥意思，再了解spring,最后学框架
- 答：先jsp，再servlet，再spring
###### 面试你为什么要学java
问：面试你为什么要学java
- 答：因为要养家糊口
- 答：因为热爱所以学习，java是一门强大的编程语言
- 答：因为喜欢，java是一门很强大的语言，别人能做的他能做，别人不能做的，他也能做
- 答：因为java好找工作，工资高
###### 该怎么自学java
问：该怎么自学java
- 答：先看些网上的入门课程吧,自制力很差可以花钱找个培训机构入门
- 答：先在网上看简易的教程，主要是熟悉基本的语法，主流框架，知道Java能干什么，然后去尝试做一个项目，在项目中碰到不会的地方，再去网上或者身边的人寻找答案，对于初学者而言，这是最高效的学习方式。
然后要把技能沉淀下来，这时候看一些深入的书籍，《Java编程思想》、《Effective Java》，以及设计模式相关的书籍。
再进阶建议看Spring这种优秀框架的源码
###### 辞职去学java怎么样
问：辞职去学java怎么样
- 答：看你现在的工作了,程序员很辛苦的,超累的
- 答：选择当程序员，希望你考虑清楚，如果不是真的喜欢，有兴趣的话，还是不要进入这个行业，会很痛苦的
- 答：不建议辞职，完全可以一边工作一边学习啊，周末了，晚上了，都可以嘛
- 答：建议慎重考虑
###### 初学java买什么书
问：初学java买什么书
- 答：疯狂java讲义
- 答：《Java核心技术 卷Ⅰ》
- 答：thunk in java
- 答：Java 编程思想
###### java主要学什么
问：java主要学什么
- 答：java能做的事情可多了,游戏,后台,服务端应用
- 答：基本语法、面向对象编程、注解、jdbc
- 答：面向对象编程、循环、选择、嵌套等逻辑语句
- 答：一方面学习java自身的语法，另一方面学习java常用的框架和中间件
###### java之前学什么
问：java之前学什么
- 答：计算机基础之类的
- 答：可以学一下C语言
- 答：看 深入理解计算机系统
###### java怎么自学
问：java怎么自学
- 答：先找网上的入门视频,然后做一些简单的项目
- 答：先入门java的基本书籍，然后实战
- 答：1 看视频教程
2 看书籍
3 实践
- 答：java 语法自己百度，框架类看spring实战 基本就可以写一个小网站，如果要接触大型分布式系统，推荐 
大型分布式网站架构设计与实践
- 答：有本书《head first java》很不错，用这本书入门，然后多写demo，多上论坛交流
###### java怎么学比较快
问：java怎么学比较快
- 答：说实话,多敲代码才能提升
- 答：学习没有捷径，只有按部就班的敲代码，熟悉才能有进一步运用
- 答：我觉得可以看视频和看书一起，因为看书会有点枯燥，视频会有解析过程，看下去比较看的懂，当然初级阶段要多练多想。
- 答：多动脑，多动手
###### java怎么输出姓名学号
问：java怎么输出姓名学号
- 答：System.out.println("姓名学号")..
- 答：String name="姓名";
long num = 12456789899022L;
System.out.println(name+" " +num);
- 答：System.out.println("姓名学号")
###### java学徒出来做什么的
问：java学徒出来做什么的
- 答：现从工程师助理干起,一点点提升能力
- 答：学徒还能做啥，安心找个肯收留的公司好好学习基本应用
- 答：要有一定的技术储备，要不给人倒水都没人要
- 答：做开发，做售后，都是非常好的
###### java学什么数据结构
问：java学什么数据结构
- 答：不管什么语言,基础的数据结构都是一样的,栈,队列,链表等
- 答：堆、栈、队列、树。。。。
- 答：数据结构是计算机基础学科，跟语言无关 java中常见的数据结构：数组、链表、各种树(尤其红黑树)
- 答：数据结构 是基础，和语音没有关系 推荐清华大学那边 数据结构
- 答：数组 链表 hash表 红黑树
###### java学了能干什么
问：java学了能干什么
- 答：养家糊口!!
- 答：可以做网站后端、大数据平台、kuangpin、跨平台高兼容性软件等等
- 答：java是一种编程语言，让你能够利用计算机 与 互联网 达成你想做的事情，计算机和互联网结合能干什么，java就能干什么
- 答：可以做很多软件：手机软件，电脑软件，还可以做淘宝网
###### java学会能做什么
问：java学会能做什么
- 答：打工挣钱,养家糊口
- 答：可以做很多东西，有java语言基础转其他也很快
- 答：java主要干网站后台开发
- 答：从企业后台，到大型分布式系统，中间件系统，都可以用java来搞，甚至机器学习
- 答：java开发工程师
###### java学会了能干什么
问：java学会了能干什么
- 答：打工挣钱,养家糊口
- 答：做网站、做扩展高的跨平台软件、做大数据平台
- 答：目前Java 在软件界、互联网界还有着不可替代的作用，特别适合大型项目。
- 答：写代码编程
###### java学的是什么意思是什么意思是什么意思是什么意思
问：java学的是什么意思是什么意思是什么意思是什么意思
- 答：看到这个问题我有点迷茫
- 答：学的是如何搭建网站后端
- 答：java中文名叫爪哇，是跨平台面向对象编程的语言
- 答：真的不是很清楚这句话什么意思
###### java学出来可以做什么工作
问：java学出来可以做什么工作
- 答：做后端,有一定经验后可以做其他的
- 答：做你想做的，你也可以把java当成跳板，去学习人工智能，不能被一门语言给困住
- 答：软件工程师
- 答：安卓开发，后端开发，大数据开发
###### java学出来可以做什么
问：java学出来可以做什么
- 答：后台,游戏 都可以
- 答：java无非就是做网站后端
- 答：学完java算是对程序的入门了，相当于学会了英语，具体可以做啥，就好比学会了英语，你可以当翻译，做导游，做外贸，英语只是工具。java也是这样，java只是未来IT化的一个工具，可以做很多方向，比如说，电商网站，人工智能，大数据，云计算等。重要的是通过java培养和建立起来的思维方式，是无法替代的。
###### java学出来后怎么样
问：java学出来后怎么样
- 答：还可以,现在招java的岗位挺多的
- 答：还能咋样，打工是不可能打工的，只能搞间软件公司当老板
- 答：很有钱途，用途很广，可以去阿里巴巴，京东，百度，腾讯，这些公司赚钱的系统，很多都是java开发栈的
###### java需要什么都学
问：java需要什么都学
- 答：先学基础语法,然后做简单的小项目
- 答：Java是很杂，但没必要啥都会，javase的基础打好，剩下都好说
- 答：前端部分：html,css,js,ajax

数据处理: json,xml,gson

后台部分：java基础语言，junit单测，log4j,spring,springboot,mybatis,redis等中间件

版本控制：git,svn

WEB服务器：Tomcat

开发工具：IDEA, 最好用的，没有之一

数据库：MySQL,Hbase 一种关系型一种非关系型即可

Linux：基本命令，grep,sed,ssh等

chrome：各种web开发插件，各取所需，比如json插件等

进阶：缓存、架构、jvm调优等
###### java数学符号怎么表示
问：java数学符号怎么表示
- 答：复杂的建议使用开源的java类库
- 答：math类
- 答：用math类
- 答：/ 这些，复杂的请使用Math类，里面有很多数学运算
- 答：在java中”&&”是逻辑运算符，A&&B表达式，只有当A，B都为真的时候表达式结果为真，其他情况都为假。在执行过程中会出现“短路”的现象
###### java是什么好学吗
问：java是什么好学吗
- 答：是一门编程语言,入门容易,精通难
- 答：不好学，如果没兴趣的话
- 答：面向对象的编程语言。有编程语言基础的话很容易学会
###### java开发要先学什么软件
问：java开发要先学什么软件
- 答：不用先学什么软件..直接学java就行
- 答：额，应该是先学Java再学ide吧
- 答：eclipse或idea  工具
###### java开发要先学什么
问：java开发要先学什么
- 答：没有强制的前置流程,自己有兴趣就行
- 答：有一定的逻辑思维能力
- 答：有一定的数学基础、数据库、操作系统
- 答：先学Java语法，理解面向对象思想
###### java基础怎么学
问：java基础怎么学
- 答：看教学视频和教学书籍,比如疯狂java讲义
- 答：要嘛看视频，要嘛看书，多想多练
- 答：可以去网上看看视频
- 答：可以看看java编程思想
###### java基础学完了学什么
问：java基础学完了学什么
- 答：做项目,增加开发经验
- 答：最基础：计算机组成原理，操作系统，数据结构，数据库，软件工程
深层的：分布式中间件，大数据，AI相关。
- 答：实战，任何东西都要实战
###### java工程师学什么专业
问：java工程师学什么专业
- 答：计算机科学与技术 软件工程等
- 答：最好计算机相关专业科班出身最好，当然肯努力，这都不重要
- 答：说是不限专业，但其实为了以后发展着想，还在上计算机科学相关专业，数学专业也是可以的，混金融、混IT都很吃香
- 答：其实不限专业，只要你有兴趣，有耐心。 当然如果有条件的话，大学选择计算机相关专业，能让你的知识广度更好，有个良好的基础
- 答：不限专业，只要有兴趣
###### java初学者用什么书好
问：java初学者用什么书好
- 答：疯狂java讲义
- 答：《Head First Java》
《Java从入门到精通》
###### java初学者应该怎么学
问：java初学者应该怎么学
- 答：先看网上基础的教学视频,同时买一本入门书籍看着学语法
- 答：学习是一个由浅入深的过程，可以先看看别人怎么写代码的，看看网络上的视频，然后跟着视频边看边写，当对一门语言有一段时间的认知后，发现编写使不上力的时候，就到了瓶颈期，这时候就需要系统化的思维来学习了。1.如何做事？要想写清楚一个程序，则需要想清楚程序要解决一个问题？或者实现一个什么价值？然后才是如何解决问题或者实现价值？
2.如何编程？知道了如何解决问题，按照对应编程语言的语法把理解的思想写下来即可。总结：要想做事则需要知道自己要做什么，用什么去做？则需要理解计算机如何工作？ 然后才是如何去编程，编程语言怎么工作的？才能更好的使用编程语言
- 答：看 java编程思想
- 答：看java编程思想 这本书，然后动手实践。先入个门
###### java初学者看什么书
问：java初学者看什么书
- 答：<疯狂java讲义>不错
- 答：Java核心技术 Java编程思想 然后到慕课网上找一个实战项目练手
- 答：《Head First Java》 《Java 核心技术：卷1 基础知识》 《Java 编程思想》(英文名《Thinking In Java 》) 《Java开发实战经典》
- 答：java编程思想。
###### java程序员应该学什么
问：java程序员应该学什么
- 答：java语法;然后编程必备的基础知识,数据结构,算法导论,计算机组成原理
- 答：操作系统、数据库、数据结构、javase......
- 答：问题有点宽泛了。 1. 语言本身要掌握java基础、熟悉jvm 2. 学习数据库，基本的前端知识 3. 其他的，要学习操作系统原理，数据结构 4. 如果还有余力，学习一门其他的语言
- 答：这个问题太大了  应该学习java 基础知识 中间件 jvm 等等 语言只是其中很小的一部分，关键是要对计算机底层熟悉，数据结构熟悉
- 答：Mysql，j2ee，虚拟机
###### javase学完后怎么加深
问：javase学完后怎么加深
- 答：得做项目,实践出真知
- 答：这个过程是很艰辛的，应为学得快忘得也快。因此要重复练习
- 答：做项目，在实战中加深 看优秀的开源项目源码，在学习和膜拜中加深
- 答：做大型分布式项目
###### c  和java学什么
问：c  和java学什么
- 答：先学基本的语言规则,即语法;
- 答：语法和实际应用
- 答：首先是看语法，其次是锻炼编程思维，最后是灵活运用
- 答：语法和类库。
###### c   和 java 同时学会怎么样
问：c   和 java 同时学会怎么样
- 答：同时学没问题的,看你时间充不充足了
- 答：没必要，C很多都过时了，为啥不直接学java
- 答：百无禁忌，学习C，能让你更加了解Java的内存分配和其他底层原理，学习Java，能让你更好的理解什么是面向对象，同时学，绝对1+1>2
- 答：可以同时学 不冲突
- 答：张无忌，同时会乾坤大落移和九阳神功
###### StringBuffer和StringBuilder区别是什么？
问：StringBuffer和StringBuilder区别是什么？
- 答：stringbuffer是线程安全的,builder非线程安全
- 答：StringBuffer线程安全，StringBuilder非线程安全但是效率更高非并发场景使用。
- 答：stringBuffer效率太低啦，已经弃用了。
- 答：线程安全是两个最大的区别
- 答：StringBuffer是线程安全的，而StringBuilder是非线程安全的。
###### 什么是线程安全？
问：什么是线程安全？
- 答：提供的api,调用方在多线程任意次序的调用都不影响该api输出的结果,该api可称为线程安全
- 答：多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。 或者说：一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步的问题。 线程安全问题大多是由全局变量及静态变量引起的，局部变量逃逸也可能导致线程安全问题。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 类要成为线程安全的，首先必须在单线程环境中有正确的行为。如果一个类实现正确(这是说它符合规格说明的另一种方式)，那么没有一种对这个类的对象的操作序列(读或者写公共字段以及调用公共方法)可以让对象处于无效状态，观察到对象处于无效状态、或者违反类的任何不可变量、前置条件或者后置条件的情况。 此外，一个类要成为线程安全的，在被多个线程访问时，不管运行时环境执行这些线程有什么样的时序安排或者交错，它必须仍然有如上所述的正确行为，并且在调用的代码中没有任何额外的同步。其效果就是，在所有线程看来，对于线程安全对象的操作是以固定的、全局一致的顺序发生的。 正确性与线程安全性之间的关系非常类似于在描述 ACID(原子性、一致性、独立性和持久性)事务时使用的一致性与独立性之间的关系：从特定线程的角度看，由不同线程所执行的对象操作是先后(虽然顺序不定)而不是并行执行的。
- 答：什么叫线程安全： 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的， 就是线程安全的。 或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。 线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。
- 答：当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。
- 答：在多个线程并发环境下，多个线程共同访问同一共享内存资源时，其中一个线程对资源进行写操作的中途(写⼊入已经开始，但还没 结束)，其他线程对这个写了一半的资源进⾏了读操作，或者对这个写了一半的资源进⾏了写操作，导致此资源出现数据错误。
###### 什么是死锁？
问：什么是死锁？
- 答：死锁的产生是必须要满足一些特定条件的： 1.互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放 2.请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。 3.不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用 4.循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞
- 答：死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。
- 答：线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。当线程进入对象的synchronized代码块时，便占有了资源，直到它退出该代码块或者调用wait方法，才释放资源，在此期间，其他线程将不能进入该代码块。当线程互相持有对方所需要的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁。 
当然死锁的产生是必须要满足一些特定条件的： 1.互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放 2.请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。 3.不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用 4.循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。
- 答：竞争资源，导致线程都占用。
- 答：当两个或多个线程在等待彼此释放所需的资源(锁定)并陷入无限等待即是死锁。发生死锁的四个必要条件缺少一个就不会发生死锁： 
互斥条件：一个资源每次只能被一个进程使用。
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
###### synchronized的实现原理是什么？
问：synchronized的实现原理是什么？
- 答：通过信号量实现当前区块内的内容只能由唯一线程访问
- 答：线程安全两种，显式锁lock，同步关键字
- 答：Synchronized的作用主要有三个：（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。 
同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。 
方法级的同步是隐式，即无需通过字节码指令来控制的。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。
- 答：解决并发情况下数据同步访问的一个很重要的关键字。保证一个共享资源在同一时间只会被一个线程访问到时，可以在代码中使用synchronized关键字对类或者对象加锁
###### 有了synchronized，还需要volatile做什么事？
问：有了synchronized，还需要volatile做什么事？
- 答：因为volatile可以禁止指令重排序
- 答：一方面是因为synchronized是一种锁机制，存在阻塞问题和性能问题，而volatile并不是锁，所以不存在阻塞和性能问题。 另外一方面，因为volatile借助了内存屏障来帮助其解决可见性和有序性问题，而内存屏障的使用还为其带来了一个禁止指令重排的附件功能，所以在有些场景中是可以避免发生指令重排的问题的。
- 答：补充1楼，volatile保证了变量在多个线程间的可见性，可以有效避免脏读现象
- 答：volatile可以禁止指令重排序，在双重校验锁实现单例的时候，虽然使用了synchronized关键字，但是如果不用volatile修饰单例对象，就会存在问题。
###### synchronized的锁优化是怎么处理的？
问：synchronized的锁优化是怎么处理的？
- 答：https://www.cnblogs.com/xdyixia/p/9364247.html
- 答：JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 
自旋锁，就是让该线程等待一段时间，不会被立即挂起（就是不让前来获取该锁（已被占用）的线程立即阻塞），看持有锁的线程是否会很快释放锁。 
适应自旋锁就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 
在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。 
锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。 
轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 
当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。 
重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。
- 答：在加锁的时候使用synchronized，具体的锁的优化是虚拟机根据竞争情况自行决定的
###### JMM是什么？
问：JMM是什么？
- 答：java内存模型
- 答：Java内存模型——JMM
- 答：JMM你可以对比JDBC来理解,我们操作数据库,都是使用JDBC规范的,但是实际JDBC规范都是由各个厂商来自己实现.我们只需要使用JDBC中的相关知识,就可以直接操作数据库. 
JMM同理. 定义了一种规范,目的是解决多线程共享和通信问题. 我们使用volatile或者synchronize等关键字,底层是由各个JVM厂商去实现的,你只要知道volatile关键字是干什么的就可以. 
可以参照一下 masonwang 的回答.
- 答：JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。
- 答：在cpu计算能力飞速发展的情况下，cpu从内存中读取数据已经满足不了cpu的运算速度了，所以需要再引入一层高速缓存来作为内存和处理器之间的缓冲，在Java中，多线程的场景下，系统会为每个线程开辟一个单独的本地内存，同时存在一个存储共享变量的主内存，线程运行时，会将主内存中的数据拷贝到各自的工作内存中，每个工作内存之间对数据的修改是不可见的。使用volatile关键字可是使线程之间的数据修改可见。
###### Java并发包都有哪些，性能怎样？
问：Java并发包都有哪些，性能怎样？
- 答：提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。 各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的 ConcunrrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组 CopyOnWriteArrayList 等。 各种并发队列实现，如各种 BlockedQueue 实现，比较典型的 ArrayBlockingQueue、 SynchorousQueue 或针对特定场景的 PriorityBlockingQueue 等。 强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器
- 答：1、locks部分：包含在java.util.concurrent.locks包中，提供显式锁(互斥锁和速写锁)相关功能； 
2、atomic部分：包含在java.util.concurrent.atomic包中，提供原子变量类相关的功能，是构建非阻塞算法的基础； 
3、executor部分：散落在java.util.concurrent包中，提供线程池相关的功能； 
4、collections部分：散落在java.util.concurrent包中，提供并发容器相关功能； 
5、tools部分：散落在java.util.concurrent包中，提供同步工具类，如信号量、闭锁、栅栏等功能；
###### 什么是fail-fast？
问：什么是fail-fast？
- 答：fail-fast的字面意思是“快速失败”。当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，如果集合的结构被改变的话，就会抛出异常，防止继续遍历。这就是所谓的快速失败机制
- 答：fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时,就可能会产生fail-fast事件。
- 答：在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException。 
原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hasNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。 
场景：java.utl包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。
- 答：是Java集合的一种错误检测机制，当多个线程对部分集合进行结构上的改变的操作时，有可能会产生fail-fast机制，这个时候就会抛出ConcurrentModificationException。
###### 什么是fail-safe？
问：什么是fail-safe？
- 答：当我们对集合结构上做出改变的时候，fail-fast机制就会抛出异常。但是，对于采用fail-safe机制来说，就不会抛出异常(大家估计看到safe两个字就知道了)。 
这是因为，当集合的结构被改变的时候，fail-safe机制会在复制原集合的一份数据出来，然后在复制的那份数据遍历。 
因此，虽然fail-safe不会抛出异常，但存在以下缺点 
复制时需要额外的空间和时间上的开销。 不能保证遍历的是最新内容。
- 答：采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问，而是先复制原有集合内容，在拷贝的集合上进行遍历，所以在修改集合上层元素不会影响下层。在java.util.concurrent下都是安全的。
- 答：fail-safe是集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
###### 什么是CopyOnWrite？
问：什么是CopyOnWrite？
- 答：Copy-on-write (COW), sometimes referred to as implicit sharing or shadowing, is a resource management technique used in computer programming to efficiently implement a “duplicate” or “copy” operation on modifiable resources. If a resource is duplicated but not modified, it is not necessary to create a new resource; the resource can be shared between the copy and the original. Modifications must still create a copy, hence the technique: the copy operation is deferred to the first write. By sharing resources in this way, it is possible to significantly reduce the resource consumption of unmodified copies, while adding a small overhead to resource-modifying operations
- 答：就是写时复制， 在往集合中添加数据的时候，先拷贝存储的数组，然后添加元素到拷贝好的数组中，然后用现在的数组去替换成员变量的数组（就是get等读取操作读取的数组）。这个机制和读写锁是一样的，但是比读写锁有改进的地方，那就是读取的时候可以写入的 ，这样省去了读写之间的竞争，看了这个过程，你也发现了问题，同时写入的时候怎么办呢，当然果断还是加锁。
- 答：CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。
- 答：往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素
###### 什么是AQS呢？
问：什么是AQS呢？
- 答：AbstractQueueSynchronized的缩写，也叫抽象的队列式同步器。定义了一套多线程访问共享资源的同步器框架。 字如其名，他是一个抽象类，所以大部分同步类都是继承于它，然后重写部分方法即可。 比如说ReentrantLock/Sema phore/CountDownLatch都是AQS的具体实现类
- 答：AbstractQueuedSynchronizer:抽象同步队列,简称AQS主要依赖一个int成员变量来表示同步状态state,以及一个CLH等待队列
- 答： AQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架
- 答：AQS(AbstractQueuedSynchronizer)同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖一个int成员变量来表示同步状态以及通过一个FIFO队列构成等待队列。它的子类必须重写AQS的几个protected修饰的用来改变同步状态的方法，其他方法主要是实现了排队和阻塞机制。状态的更新使用getState,setState以及compareAndSetState这三个方法。 子类被推荐定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。 同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作。锁和同步器很好的隔离了使用者和实现者所需关注的领域。
- 答：AQS(AbstractQueuedSynchronizer）是实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器（信号量、事件，等等）提供一个框架，它是一个依靠单个原子 int 值来表示状态的大多数同步器的一个基础类
###### 什么是CAS呢？
问：什么是CAS呢？
- 答：CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。 
CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作
- 答：当多个线程同时对某个资源进行CAS操作，只能有一个线程操作成功，但是并不会阻塞其他线程,其他线程只会收到操作失败的信号。可见 CAS 其实是一个乐观锁。 
CAS的两个缺点： ABA 的问题，就是一个值从A变成了B又变成了A，使用CAS操作不能发现这个值发生变化了，处理方式是可以使用携带类似时间戳的版本AtomicStampedReference 性能问题，我们使用时大部分时间使用的是 while true 方式对数据的修改，直到成功为止。优势就是相应极快，但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。
- 答：乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试
###### 乐观锁是怎样的？
问：乐观锁是怎样的？
- 答：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
- 答：乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。
- 答：乐观锁顾名思义就是在操作时很乐观，认为操作不会产生并发问题(不会有其他线程对数据进行修改)，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS(compare and swap)算法实现。
- 答：对数据库进行处理的时候，不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。
###### 乐观锁悲观锁区别是什么？
问：乐观锁悲观锁区别是什么？
- 答：悲观锁 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。 
乐观锁 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
- 答：悲观锁(Pessimistic Lock) 在每次拿数据时都会上锁，传统的关系型数据库里边经常用到用到比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，主要依靠数据库提供的锁机制。 
乐观锁(Optimistic Lock) 每次拿数据的时候都不会上锁，在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于多读的应用类型，这样可以提高吞吐量。 
区别 两种锁各有优缺点，乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。悲观锁适用于经常产生冲突，上层应用会不断的进行retry。
- 答：实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。
###### 数据库如何实现悲观锁和乐观锁？
问：数据库如何实现悲观锁和乐观锁？
- 答：https://www.jianshu.com/p/f5ff017db62a
- 答：乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。 
通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。 
悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作。 
数据库有实现悲观锁，共享锁和排它锁就是两种实现方式。共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁，在执行语句后面加上lock in share mode就代表对某些资源加上共享锁了。排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁，在需要执行的语句后面加上for update就可以了
- 答：借助数据库锁机制在修改数据之前先锁定，再修改并发控制
###### 数据库锁和隔离级别有什么关系？
问：数据库锁和隔离级别有什么关系？
- 答：https://www.zhihu.com/question/285970182/answer/454844663
- 答：补充下上面的回答。现在用的大多数mysql数据库，这个数据库比标准四种隔离级别多了一个机制：可重复读级别可以消除幻读，因为该级别存在间隙锁。
- 答：数据库的四种隔离级别： 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读) 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞
- 答：层层递进，不可复读
###### 数据库锁和索引有什么关系？
问：数据库锁和索引有什么关系？
- 答：https://zhuanlan.zhihu.com/p/40396971 讲的很详细
- 答：索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。
###### 什么是聚簇索引？
问：什么是聚簇索引？
- 答：对于聚簇索引表来说，表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)。
- 答：聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
- 答：主键索引的节点存的是整行数据
###### 什么是非聚簇索引？
问：什么是非聚簇索引？
- 答：对于非聚簇索引表来说，表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据
- 答：非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因
- 答：非主键索引的节点的内容是主键的值
###### 索引最左前缀是什么？
问：索引最左前缀是什么？
- 答：最左前缀:顾名思义,就是最左优先,上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引,(lname,fname)组合索引
- 答：在创建多列索引时，根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则
###### 什么是B+树索引？
问：什么是B+树索引？
- 答：首先，B+ Tree是B Tree的升级版，其最大的特点便是中间节点只有链指针和key，而不存储数据，所有的value都会存储在B+Tree的叶子节点中，所以基于树的深度，B+Tree的查询时间复杂度很稳定，每次都要搜索到叶子节点。 
由此，因为中间文档小，B+Tree作为索引可以提升查找效率，同时在MySQL的索引中，叶子结点各有指针指向相邻的数据，便于范围查找
- 答：索引B+ Tree的叶子节点存储了整行数据的是主键索引
###### 什么是联合索引？
问：什么是联合索引？
- 答：对多个字段同时建立的索引(有顺序，ABC，ACB是完全不同的两种联合索引。)
- 答：对于查询概率比较高，经常作为where条件的字段设置索引
###### 什么是回表？
问：什么是回表？
- 答：MySQL中的回表查询,我的理解是二级索引无法直接查询所有列的数据,所以通过二级索引查询到聚簇索引后,再查询到想要的数据,
- 答：简单来说就是数据库根据索引找到了指定的记录所在行后,还需要根据rowid再次到数据块里取数据的操作。
- 答：当查到主键的值以后，还需要再通过主键的值再进行一次查询
###### 分布式锁有了解吗？
问：分布式锁有了解吗？
- 答：为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁。
- 答：我们可以认为获得排他锁的线程即可获得分布式锁,当获取到锁之后,可以执行方法的业务逻辑,执行完方法之后,通过connection.commit()操作来释放锁。
- 答：类似于jvm的锁，不过分布式锁是针对集群的，当某个机器需要对共享资源进行操作的时候，需要先获取到锁，然后进行操作，最后释放锁，如果在当前机器进行操作的时候，其他机器也有请求进来，此时需要等待当前锁释放之后才能尝试获取锁，获取成功后进行操作，分布式锁的实现可以使用数据库，redis,zk等实现
- 答：基于数据库实现分布式锁 基于Zookeeper实现分布式锁
###### Redis怎么实现分布式锁？
问：Redis怎么实现分布式锁？
- 答：setnx命令，存储数据时，如果当前key已经存在，则返回0，表示没有设置成功，否则返回1，表示设置成功。分布式锁的实现就可以通过是否设置成功某个key来判断是否获取到锁，为了防止死锁问题，还应该为该key设置超时时间，为了防止误删别人的锁，需要返回value,在释放锁时判断当前想要删除的锁是否是自己的锁
- 答：SETNX lock.foo
###### 为什么要用Redis？
问：为什么要用Redis？
- 答：Redis内存操作，速度快
Redis数据会同步保存到硬盘，数据有持久性(存在一定丢失可能)
支持分布式
用的人多，社区支持好，有问题能及时得到解决
- 答：分布式缓存，提升性能
###### Redis和memcache区别是什么？
问：Redis和memcache区别是什么？
- 答：数据类型：redis支持的数据类型更多
缓存值大小：redis支持的缓存值更大
数据持久性：redis支持数据持久，memcache数据只保存在内存中，容易丢失
- 答：存储方式不同，Redis支持数据的备份，Redis在数据支持上要比Memcache多得多。
###### Zookeeper怎么实现分布式锁？
问：Zookeeper怎么实现分布式锁？
- 答：使用临时节点：这里需要使用当zk的监听zk节点的变化，在请求进来时，尝试去创建一个约定名称的零时节点，如果创建成功，则表示能获取锁，可以进行操作，操作完成之后关闭连接，zk会自动删除该临时节点。如果创建临时节点失败，则等待，监听该节点名称，当该节点发生变化时，会通知到所有监听带节点的客户端，所以当服务器监听到该节点的删除事件时，可以尝试再次创建节点，重复之前的操作，知道获取锁成功，断开连接。使用有序节点时需要手动删除自己创建的节点，是否获取到锁就判断当前客户端节点在zk中是否排在第一位
- 答：zookeeper临时有序节点
###### 什么是Zookeeper？
问：什么是Zookeeper？
- 答：ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。
- 答：分布式协调工具，可以作为注册中心，分布式锁，分布式配置中心等
- 答：一个开放源码的分布式服务协调组件
###### 什么是CAP？
问：什么是CAP？
- 答：CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。
- 答：一个分布式系统最多只能同时满足一致性）、可用性和分区容错性中的两项。
###### 什么是BASE？和CAP什么区别？
问：什么是BASE？和CAP什么区别？
- 答：CAP: C: 一致性 A:可用性 P:分区容错性 
对于分布式系统而言，分区容错性是必须的，需要把精力花在如何根据业务特点在C和A之间寻求平衡。 
BASE: BA:基本可用 S:软状态，允许系统在不同节点的数据副本之间进行数据同步过程存在延时 E:最终一致性
- 答：BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性
###### CAP怎么推导？如何取舍？
问：CAP怎么推导？如何取舍？
- 答：在理论计算机科学中,CAP定理(CAP theorem),又被称作布鲁尔定理(Brewer’s theorem),它指出对于一个分布式计算系统来说,不可能同时满足
- 答：网络发生故障宁可停止服务也不能发生服务泄露
###### 分布式系统怎么保证数据一致性？
问：分布式系统怎么保证数据一致性？
- 答：对于同步的调用的方式,比较简单,我们能够及时获取结果;对于异步的通知,就必须采用请求,应答的方式进行
- 答：通过分布式事务
###### 什么是分布式事务？分布式事务方案？
问：什么是分布式事务？分布式事务方案？
- 答：分布式事务的核心是解决多机系统中的原子性和一致性(AC)问题,ID可由单机系统的事务保证。
- 答：将对同一库事务的概念扩大到了对多个库的事务 
必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果
###### 线程安全的单例？
问：线程安全的单例？
- 答：在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。
- 答：面试的时候，常常会被问到这样一个问题：请您写出一个单例模式（Singleton Pattern）吧。好吧，写就写，这还不容易。顺手写一个： 
复制代码 1 //饥饿模式 2 public final class EagerSingleton
 3 {<!-- -->
 4 private static EagerSingleton singObj = new EagerSingleton();
 5
 6 private EagerSingleton(){<!-- -->
 7 }
 8
 9 public static EagerSingleton getSingleInstance(){<!-- -->
 10 return singObj； 11 }
 12 }
 复制代码 这种写法就是所谓的饥饿模式，每个对象在没有使用之前就已经初始化了。这就可能带来潜在的性能问题：如果这个对象很大呢？没有使用这个对象之前，就把它加载到了内存中去是一种巨大的浪费。
- 答：public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}
###### 不用synchronized和lock能实现线程安全的单例吗？
问：不用synchronized和lock能实现线程安全的单例吗？
- 答：饿汉式单例模式天生线程安全，类加载的时候初始化一次对象即可
- 答：public class Singleton {
    private static final AtomicReference<Singleton> INSTANCE = new AtomicReference<Singleton>(); 

    private Singleton() {}

    public static Singleton getInstance() {
        for (;;) {
            Singleton singleton = INSTANCE.get();
            if (null != singleton) {
                return singleton;
            }

            singleton = new Singleton();
            if (INSTANCE.compareAndSet(null, singleton)) {
                return singleton;
            }
        }

 
}
 
}
###### 什么是Paxos算法？
问：什么是Paxos算法？
- 答：Paxos算法是用来解决分布式系统中,如何就某个值达成一致的算法。
- 答：Paxos算法是基于消息传递且具有高度容错特性的一致性算法,是目前公认的解决分布式一致性问题最有效的算法之一
- 答：一种基于消息传递且具有高度容错特性的一致性算法
###### ArrayList和LinkedList和Vector的区别
问：ArrayList和LinkedList和Vector的区别
- 答：ArrayList和Vector底层是数据结构实现，LinkedList是双向链表，ArrayList和Vector查询快，删除慢，LinkedList与之相反，ArrayList是线程不安全的，性能优于Vector，Vector是线程安全的，能解决线程安全问题
- 答：ArrayList 是一个可改变大小的数组 
LinkedList 是一个双链表 
Vector 和ArrayList类似,但属于强同步类
###### SynchronizedList和Vector的区别
问：SynchronizedList和Vector的区别
- 答：SynchronizedList采用的同步代码块方式，vector采用的同步方法实现。所以主要区别： 1.SynchronizedList有很好的扩展和兼容功能。可以将所有的List的子类转成线程安全的类 2.使用SynchronizedList的时候，进行遍历时要手动进行同步处理。3.SynchronizedList可以指定锁定的对象。
###### Arrays.asList获得的List使用时需要注意什么
问：Arrays.asList获得的List使用时需要注意什么
- 答：asList 得到的只是一个 Arrays 的内部类，一个原来数组的视图 List，因此如果对它进行增删操作会报错，用 ArrayList 的构造器可以将其转变成真正的 ArrayList
###### List和原始类型List之间的区别?
问：List和原始类型List之间的区别?
- 答：在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查。
###### List<?>和List之间的区别是什么?
问：List<?>和List之间的区别是什么?
- 答：一个是已知的，一个是未知的
- 答：List 是一个未知类型的List，而List 其实是任意类型的List
###### synchronized是如何实现的？
问：synchronized是如何实现的？
- 答：synchronized. 在Java中,synchronized关键字是用来控制线程同步的
- 答：@author Hollis 18/08/04.

public class SynchronizedDemo {

    public synchronized void doSth(){
        System.out.println("Hello World");
    }

    public void doSth1(){
        synchronized (SynchronizedDemo.class){
            System.out.println("Hello World");
        }
    }
}
###### BIO、NIO和AIO的区别、三种IO的用法与原理
问：BIO、NIO和AIO的区别、三种IO的用法与原理
- 答：IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。 
一、BIO 
 在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端会线程会等待请求结束后才继续执行。
 
二、NIO 
NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题： 在使用同步I/O的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个线程来单独处理。这样做虽然可以达到我们的要求，但同时又会带来另外一个问题。由于每创建一个线程，就要为这个线程分配一定的内存空间（也叫工作存储器），而且操作系统本身也对线程的总数有一定的限制。如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，甚至服务器可能会因此而瘫痪。

NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。  也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。
 
BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。 
  NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。

  在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。
 
　　HTTP/1.1出现后，有了Http长连接，这样除了超时和指明特定关闭的http header外，这个链接是一直打开的状态的，这样在NIO处理中可以进一步的进化，在后端资源中可以实现资源池或者队列，当请求来的话，开启的线程把请求和请求数据传送给后端资源池或者队列里面就返回，并且在全局的地方保持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求，而后端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的.当后端处理完，到全局地方得到现场，产生响应，这个就实现了异步处理。 
三、AIO 
 与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。  在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：
 
AsynchronousSocketChannel AsynchronousServerSocketChannel AsynchronousFileChannel AsynchronousDatagramChannel 其中的read/write方法，会返回一个带回调函数的对象，当执行完读取/写入操作后，直接调用回调函数。 
BIO是一个连接一个线程。 
NIO是一个请求一个线程。 
AIO是一个有效请求一个线程。 
先来个例子理解一下概念，以银行取款为例： 
同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）； 异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）； 阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）； 非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）
- 答：BIO：BIO即Block I/O ， 同步并阻塞的IO NIO：NIO 与原来的 I/O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。 AIO：AIO即Async非阻塞，是异步非阻塞的IO 如果想更详细的了解和使用异步IO，推荐《Netty实战》这本书
- 答：BIO ：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。 
NIO ：同时支持阻塞与非阻塞模式 
AIO ：异步非阻塞I/O模型
###### ConcurrentSkipListMap
问：ConcurrentSkipListMap
- 答：ConcurrentSkipListMap是线程安全的有序的哈希表,适用于高并发的场景。
- 答：一个内部使用跳表，支持排序和并发的一个Map
###### String.valueOf和Integer.toString的区别
问：String.valueOf和Integer.toString的区别
- 答：String.valueOf 当值为null 返回字符null 否则调起tostring
- 答：创建一个StringBuilder对象，然后再调用append方法，再调用toString方法。
###### Integer的缓存机制
问：Integer的缓存机制
- 答：<img src="https://ucc.alicdn.com/pic/developer-ecology/5fc26a585df14844835472f41ec3ef64.png" alt="image.png" /> 
        static final int low = -128;
        static final int high;
        static final Integer cache[];
 
Integer会有个常量数组，缓存 -128 到 127的值。 与此类似的还有Long
- 答：一、Integer类的缓存机制 二、其它具有缓存机制的类 面试题回到顶部我们查看Integer的源码,就会发现里面有个静态内部类。
- 答：
```
* Returns an {@code Integer} instance representing the specified
     * {@code int} value.  If a new {@code Integer} instance is not
     * required, this method should generally be used in preference to
     * the constructor {@link #Integer(int)}, as this method is likely
     * to yield significantly better space and time performance by
     * caching frequently requested values.
     *
     * This method will always cache values in the range -128 to 127,
     * inclusive, and may cache other values outside of this range.
     *
     * @param  i an {@code int} value.
     * @return an {@code Integer} instance representing {@code i}.
     * @since  1.5
     */
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
```
###### Set如何保证元素不重复?
问：Set如何保证元素不重复?
- 答：HashSet底层使用的是hashMap的key来保证元素不重复的，hashMap中的key通过equals方法比较key是否相等
- 答：通过HashSet和TreeSet
###### Java中如何保证线程安全？
问：如何保证线程安全？
- 答：在Java语言里面,不可变(Immutable)的对象一定是线程安全的,无论是对象的方法实现还是方法的调用者,都不需要再进行任何的线程安全保障措施。
- 答：单体服务线程安全可使用Synchronized和ReentrantLock锁住相关代码，锁对象或是块必须是多线程共享的。 
unsafe提供的CAS或是手动定义的乐观锁在并发较小但是有并发可能的情况下可以使用。 
确保共享变量和对象的访问是串行的，或整体操作是原子的（例如不并发使用SimpleDataFormat）；并发的数据修改要选择使用线程安全的静态类，如JUC包下的ConsurrentHashMap等。
- 答：Java中可以使用synchronized关键保证线程安全，也可以使用jdk提供的Lock锁，或者使用cas乐观锁来实现线程安全
- 答：使用synchronized和Lock
###### 请教一个Java并发的问题：volatile变量的读取每次都是从主内存中获取么？
问：请教一个Java并发的问题：volatile变量的读取每次都是从主内存中获取么？
- 答：不是，读取的是最新的值，是主线程的值
- 答：volatile修饰的变量，读取时会从主存刷新最新的值，写入后也会立即同步到主存中，这样才能保证数据一致
- 答：读取的是最新的值，是主线程的值
- 答：根据Java内存模型，volatile变量在每次读取、更新时 都会同步到 主内存中，而不会读写CPU寄存器缓存
- 答：volatile 变量，每次读取前必须先从主内存刷新最新的值，每次写入后必须立即同步回主内存当中。
###### java开发的网站和PHP相比是不是不利于搜索优化？
问：java开发的网站和PHP相比是不是不利于搜索优化？
- 答：虽然php是世界上最好的语言，但是，这个跟编程语言真的没有特别大的关系。语言只是实现逻辑的一种手段
那说到搜索，那肯定是用Elasticsearch啊，直接用阿里云的技术吧：<a href="https://data.aliyun.com/product/elasticsearch?spm=5176.10695662.1130970.1.3ba3505aj2ny2d">https://data.aliyun.com/product/elasticsearch?spm=5176.10695662.1130970.1.3ba3505aj2ny2d</a>
- 答：如果是全站搜索，和java、php无关的，本身都是用搜索引擎来做的，且很多搜索引擎数据都是写到文件里面的
- 答：搜索引擎索引的是页面数据。前后端分离，动态加载的数据索引不到等会对搜索优化产生一定影响。编程语言与搜索引擎没有直接关系。
- 答：搜索优化跟语言是没有关系的，常规的大数量高频度搜索都会依赖专门的搜索引擎，小数据量的搜索直接依赖于数据库就好了
- 答：前后端分离,动态加载等会对搜索优化产生一定影响。编程语言与搜索引擎没有直接关系。
###### java 1.8 jstack不成功，什么办法解决？谢谢。
问：java 1.8 jstack不成功，什么办法解决？谢谢。
- 答：有多种可能，需要你看下具体异常情况：
1.jstack命令没找到
2.没有足够权限执行
3.jstack语法错误
你要学会自己定位问题和学会提问
- 答：可以尝试用-F命令，如果还不行检查是否运行jstack命令的用户和运行java进程的用户不是一个linux用户。
- 答：不成功先试试加-F命令， 如果还不成功可能是hung住了， 试试kill -3
- 答：jstack不成功是什么意思，楼主可以贴图出来看看，一般只要用法没问题，并且权限是对的，应该都可以把线程的stack dump下来，如果真是说线程死锁了或卡住了那可以用-F强制dump
- 答：亲，麻烦你看下用法说明：
jstack
Usage:jstack [-l] <pid>
    (to connect to running process)
jstack -F [-m] [-l] <pid>
    (to connect to a hung process)
jstack [-m] [-l] <executable> <core>
    (to connect to a core file)
jstack [-m] [-l] [server_id@]<remote server IP or hostname>
    (to connect to a remote debug server)
Options:-F  to force a thread dump. Use when jstack <pid> does not respond (process is hung)
可以尝试使用-F强制dump哦。。
###### 在spring boot2.0中，一个controller中同时调用多个接口，能异步实现吗？ 我有个页面需要调用7个左右的接口，想用异步方式请求这个几个接口，获取数据 请问可以做到吗?
问：在spring boot2.0中，一个controller中同时调用多个接口，能异步实现吗？
我有个页面需要调用7个左右的接口，想用异步方式请求这个几个接口，获取数据
请问可以做到吗
- 答：List> futures = executorService.invokeAll(list, 3000, TimeUnit.MILLISECONDS);
起多个线程提交即可，这种是最简单的方式
- 答：可以，使用Future就可以了。
private static final ThreadFactory THREAD_FACTORY =
        new ThreadFactoryBuilder().setNameFormat("task-pool-%d").build();

private static ExecutorService FUTURE_TASK_EXECUTOR = new ThreadPoolExecutor(
        3, 10, 60L, TimeUnit.SECONDS,new LinkedBlockingDeque<>(), THREAD_FACTORY
);

public static <V> Future<V> submit(Callable<V> task) {
    return FUTURE_TASK_EXECUTOR.submit(task);
}
然后使用 Future.get 就可以拿到结果了
- 答：用HSF是可以的，结合HSFResponseCallback来做异步调用
###### mybatis insert 是异步吗?
问：mybatis insert 是异步吗?本问题及下方已被采纳的回答均来自云栖社区【阿里Java技术进阶2群】。<a href="https://yq.aliyun.com/articles/690084">https://yq.aliyun.com/articles/690084</a> 点击链接欢迎加入社区大社群。
- 答：是异步的
- 答：应该是异步的
- 答：提出的问题没有限定条件，我认为是同步的
###### 什么的服务器可以抗10万并发？
问：本问题及下方已被采纳的回答均来自云栖社区【阿里Java技术进阶2群】。<a href="https://yq.aliyun.com/articles/690084">https://yq.aliyun.com/articles/690084</a> 点击链接欢迎加入社区大社群。
- 答：阿里云的服务器，才10万并发，双11的时候远远大于这个数字
- 答：还没有
- 答：如果只是简单的 socket 连接,少量类似心跳之类的活动的话,中配机器即可.
- 答：大规模并发服务器只是众多衡量服务器性能指标中的一项，10w并发，除了看数量外，更多的要看每个并发请求背后执行了什么？ 如何业务少，一台普通32c128G服务器即可，甚至更少；
###### 如何统计系统qps？
问：本问题来自云栖社区【阿里Java技术进阶2群】。<a href="https://yq.aliyun.com/articles/690084">https://yq.aliyun.com/articles/690084</a> 点击链接欢迎加入社区大社群。
- 答：对QPS的统计,通常是对一秒内各线程通过数据处理链中某一个切入点的次数进行累加.
- 答：对QPS的统计,通常是对一秒内各线程通过数据处理链中某一个切入点的次数进行累加计数。且不论采用何种方式都绕不开锁
- 答：网关日志分析统计
- 答：通过分析网关日志,或者链路追踪工具
- 答：通过分析Nginx日志可以做到：
统计一段时间内的有效请求的日志行数（记为N），这段时间的总时长（秒）记为T，那么这段时间内的QPS就是：
QPS=N/T
###### 问一下各位大神，用h5做小程序的时候，前后台不分离可以不？
问：本问题来自云栖社区【阿里Java技术进阶2群】。<a href="https://yq.aliyun.com/articles/690084">https://yq.aliyun.com/articles/690084</a> 点击链接欢迎加入社区大社群。
- 答：基本上都是前后端分离
- 答：小程序是前后端分离的，建议所有的应用都前后端分离，json交互
- 答：小程序 肯定前后端分离吧；h5可以不分离
###### spring boot开发的微服务，存在相互间的调用通信。用什么方式保证安全
问：spring boot开发的微服务，存在相互间的调用通信。用什么方式保证安全。（没有用户账号密码认证）比如一个开户注册的场景，用户申请开通试用环境。A服务做一些校验及记录信息等的工作，由B服务进行进行环境的开通服务。 A调用B服务
- 答：一.背景
微服务架构下，我们的系统根据业务被拆分成了多个职责单一的微服务。
每个服务都有自己的一套API提供给别的服务调用，那么如何保证安全性呢？
不是说你想调用就可以调用，一定要有认证机制，是我们内部服务发出的请求，才可以调用我们的接口。
需要注意的是我们这边讲的是微服务之间调用的安全认证，不是统一的在API官网认证，需求不一样，API网关处的统一认证是和业务挂钩的，我们这边是为了防止接口被别人随便调用。
二.方案
OAUTH2
Spring Cloud可以使用OAUTH2来实现多个微服务的统一认证授权
通过向OAUTH2服务进行集中认证和授权，获得access_token
而这个token是受其他微服务信任的，在后续的访问中都把access_token带过去，从而实现了微服务的统一认证授权。
JWT
JWT是一种安全标准。基本思路就是用户提供用户名和密码给认证服务器，服务器验证用户提交信息信息的合法性；如果验证成功，会产生并返回一个Token，用户可以使用这个token访问服务器上受保护的资源。
感觉这2种好像没多大区别呀，其实是有区别的：OAuth2是一种授权框架 ，JWT是一种认证协议
无论使用哪种方式切记用HTTPS来保证数据的安全性。
三.用哪种
我个人建议用JWT,轻量级，简单，适合分布式无状态的应用
用OAUTH2的话就麻烦点，各种角色，认证类型，客户端等等一大堆概念
四.怎么用
首先呢创建一个通用的认证服务，提供认证操作，认证成功后返回一个token
@RestController
@RequestMapping(value="/oauth")
public class AuthController {

@Autowired
private AuthService authService;

@PostMapping("/token")
public ResponseData auth(@RequestBody AuthQuery query) throws Exception {
    if (StringUtils.isBlank(query.getAccessKey()) || StringUtils.isBlank(query.getSecretKey())) {
        return ResponseData.failByParam("accessKey and secretKey not null");
    }
    
    User user = authService.auth(query);
    if (user == null) {
        return ResponseData.failByParam("认证失败");
    }
    
    JWTUtils jwt = JWTUtils.getInstance();
    return ResponseData.ok(jwt.getToken(user.getId().toString()));
}

@GetMapping("/token")
public ResponseData oauth(AuthQuery query) throws Exception {
    if (StringUtils.isBlank(query.getAccessKey()) || StringUtils.isBlank(query.getSecretKey())) {
        return ResponseData.failByParam("accessKey and secretKey not null");
    }

    User user = authService.auth(query);
    if (user == null) {
        return ResponseData.failByParam("认证失败");
    }

    JWTUtils jwt = JWTUtils.getInstance();
    return ResponseData.ok(jwt.getToken(user.getId().toString()));
}

}
JWT可以加入依赖,然后写个工具类即可,建议写在全局的包中，所有的服务都要用，具体代码请参考：JWTUtils
GITHUB地址：<a href="https://github.com/jwtk/jjwt">https://github.com/jwtk/jjwt</a>
JWT提供了很多加密的算法，我这边用的是RSA,目前是用的一套公钥以及私钥，这种做法目前来说是不好的，因为万一秘钥泄露了，那就谈不上安全了，所以后面会采用配置中心的方式来动态管理秘钥。
类里主要逻辑是生成token,然后提供一个检查token是否合法的方法，以及是否过期等等判断。

<groupId>io.jsonwebtoken</groupId>
<artifactId>jjwt</artifactId>
<version>0.7.0</version>

统一认证的服务有了，我们只需要将认证服务注册到注册中心即可给别的服务消费。
那么我们如何使用刚刚的认证服务来做认证呢，最简单的办法就是用Filter来处理
比如说我现在有一个服务fangjia-fsh-house-service，之前是随便谁都能调用我提供的接口，现在我想加入验证，只有验证通过的才可以让它调用我的接口
那就在fangjia-fsh-house-service中加一个过滤器来判断是否有权限调用接口，我们从请求头中获取认证的token信息，不需要依赖Cookie
这个过滤器我也建议写在全局的项目中，因为也是所有服务都要用,代码请参考：HttpBasicAuthorizeFilter
主要逻辑就是获取token然后通过JWTUtils来验证是否合法,不合法给提示，合法则放过
这边需要注意的地方是解密的秘钥必须跟加密时是相同的，不然解密必然失败，就是bug了
//验证TOKEN
if (!StringUtils.hasText(auth)) {
PrintWriter print = httpResponse.getWriter();
print.write(JsonUtils.toJson(ResponseData.fail("非法请求【缺少Authorization信息】", 
             ResponseCode.NO_AUTH_CODE.getCode())));
return;
}
JWTUtils.JWTResult jwt = jwtUtils.checkToken(auth);
if (!jwt.isStatus()) {
PrintWriter print = httpResponse.getWriter();
print.write(JsonUtils.toJson(ResponseData.fail(jwt.getMsg(), jwt.getCode())));
return;
}
chain.doFilter(httpRequest, response);
到这步为止，只要调用方在认证通过之后，通过认证服务返回的token,然后塞到请求头Authorization中，就可以调用其他需要认证的服务了。
这样看起来貌似很完美，但是用起来不方便呀，每次调用前都需要去认证，然后塞请求头，如何做到通用呢，不需要具体的开发人员去关心，对使用者透明，下篇文章，我们继续探讨如何实现方便的调用。
具体代码可以参考我的github:
<a href="https://github.com/yinjihuan/spring-cloud">https://github.com/yinjihuan/spring-cloud</a>
###### mysql java设计简易书店管理系统，希望能有源代码，参考一下，初学者，赐教
问：初学者，希望可以有个参考，学习一下
- 答：书店管理，其实也是电商网站，只不过卖的是书 这个商品。直接淘宝 Java 电商网站，书店源码。可以了。或者你自己修改Logo或者图片。
###### 消息队列的使用场景有哪些？
问：本问题来自云栖社区【阿里Java技术进阶2群】。<a href="https://yq.aliyun.com/articles/690084">https://yq.aliyun.com/articles/690084</a> 点击链接欢迎加入社区大社群。
- 答：主要的使用场景就是将比较耗时而且不需要立即生效返回结果的操作，我们把这种操作作为一个消息，放到消息队列中。处理方可以在任何时候去获取并处理这条消息。这里我们只要保证消息的格式不变，消息的发送方和接收处理方都认识这个消息，那么双方就不需要彼此通信，即可以完成一件事
- 答：异步处理、应用解耦、流量削峰（解决分布式下流量调度）、消息通讯（点对点/广播）
- 答：消息队列中间件是分布式系统中重要的组件,主要解决应用解耦,异步消息,流量削锋等问题
- 答：异步处理，应用解耦，流量削锋和消息通讯四个场景
###### spring data es 怎么连接阿里云提供的ES服务
问：如果是自己在服务器上的搭建的ES 可以直接连接， 但是如果用阿里云的提供的ES服务怎么用spring data es 来操作ES呢
- 答：参考网友的解决方案： https://blog.csdn.net/qq_27617675/article/details/99670507
- 答：需要使用阿里云的es，首先，需要去开通对应服务，然后获取相关连接参数，然后配置就好了
- 答：Spring Data链接 Elastic Search使用了统一的ElasticsearchRepository接口。简化了接口定义，直接支持CRUD操作。如果你之前看过MySQL、MongoDB、Redis的链接，你会发现相似的地方。 1、https://start.spring.io/里创建一个Spring Boot项目 2、Java Spring Boot 2.0实战ElasticSearch分布式搜索引擎中间件Linux。ES如何安装可以参考之前的视频课程 https://yq.aliyun.com/articles/688632?spm=a2c4e.11155435.0.0.69233312FbUBUf 3、application.properties加参数，链接ES服务器的。 elasticsearch.clustername = es-cluster elasticsearch.host = localhost elasticsearch.port = 9300 4、ElasticsearchRepository接口的实现 public interface OrderRepository extends ElasticsearchRepository<Order, String> {<!-- --> 
Page<Order> findByAuthor(String id, Pageable pageable);

List<Order> findByTitle(String title);
 
} 5、注入 private OrderRepository orderRepository; 找个地方注入orderRepository，然后调用就可以了。
###### Windows JDK的安装与配置
问：Windows如何安装与配置JDK
- 答：先安装JDK，在配置环境变量
- 答：本文介绍 Windows Server 2008系统下 JDK 的安装与配置 
环境： Windows Server 2008 JDK: jdk_8u60_windows_i586_V8.0.600.27.1440040557.exe 
 下载 JDK: 到 Oracle 官方网站下载：https://www.oracle.com/downloads/index.html 选择合适的版本下载。 
 点击安装程序，进行 JDK 安装  
<img src="https://ucc.alicdn.com/pic/developer-ecology/0bd33e7b413e415eadd4a3feb89a9079.png" alt="image.png" /> 
选择 JDK 的安装路径 
<img src="https://ucc.alicdn.com/pic/developer-ecology/b439f643c69642e6a1d7b3c5b425ed02.png" alt="image.png" /> 
选择 JRE 的安装路径 
<img src="https://ucc.alicdn.com/pic/developer-ecology/a6278ef825a54318b88465f4a9558238.png" alt="image.png" /> 
<img src="https://ucc.alicdn.com/pic/developer-ecology/10221df46ca6433e85c40fa0ade1afd5.png" alt="image.png" /> 
 至此 JDK 安装完成 
 配置环境变量：  
在系统变量中需要新建2个变量，大小写不区分，如果存在相同变量名，请使用编辑修改变量值。 1)JAVA_HOME，变量值为：C:\Java\jdk1.8.0_60（具体请根据你安装的 JDK 路径而定） 2)CLASSPATH，变量值为.;%JAVA_HOME%\lib; 
<img src="https://ucc.alicdn.com/pic/developer-ecology/5d2472bac2ba4ac5bfcd542c1fa3c6bf.png" alt="image.png" /> 
<img src="https://ucc.alicdn.com/pic/developer-ecology/2e1431c67aa446b7b8c731770c2baa58.png" alt="image.png" /> 
<img src="https://ucc.alicdn.com/pic/developer-ecology/f22697e0123c456a8602442c0df327e9.png" alt="image.png" /> 
<img src="https://ucc.alicdn.com/pic/developer-ecology/e3ca7bcf5e39488b9b8889c457709c90.png" alt="image.png" /> 
<img src="https://ucc.alicdn.com/pic/developer-ecology/84c51597d90b45f89fe430a7fb2714d0.png" alt="image.png" /> 
3)在已有的 Path变量后添加如下内容 ;%JAVA_HOME%\bin;%JAVA_HOME%/jre/bin; 
<img src="https://ucc.alicdn.com/pic/developer-ecology/009ac85ad33a4b7e9fc398303012076e.png" alt="image.png" /> 
至此完成了 JDK 的环境配置，请在 cmd 命令行界面下输入 java -version 测试是否安装成功。 
<img src="https://ucc.alicdn.com/pic/developer-ecology/a9919302a4c34a3c90d499f0c0eb591c.png" alt="image.png" />
###### preparedStatement接口下，setNString，setString的区别
问：setNString(int parameterIndex, String value) 将指定参数设置为给定 String 对象。 setString(int parameterIndex, String x) 将指定参数设置为给定 Java String 值。 
这两个方法有什么区别吗，JDK 1.8版本
- 答：您好，这样的：  预编译的语句 preparedStatement setString（index，values）用于编写将要输入的列以及值 下面的是我写的一个例子 希望对你有用   //发送请求  String sql = "INSERT INTO EMPLOYEE VALUE(?,?,?,?)";  PreparedStatement stmt = conn.prepareStatement(sql);  //返回结果  stmt.setString(1,"1007");  stmt.setString(2,"www");  stmt.setString(3,"www");  stmt.setString(4,"www");  stmt.executeUpdate();
 
“答案来源于网络，供您参考” 希望以上信息可以帮到您！
###### 如何在业务中发现有技术价值的问题？
问：1.如何在业务中发现有技术价值的问题？ 
2.发现问题后如何思考和发起再到解决？ 
3.最后的技术结果跟业务结果如何衔接？ 
来看看阿里高级前端技术专家是如何解决这三个问题的！ 
<a href="https://developer.aliyun.com/article/716095?utm_content=g_1000074007">https://developer.aliyun.com/article/716095?utm_content=g_1000074007</a> 
问题来自：钉钉群：阿里Java技术进阶2群 部门
- 答：碰到具体问题时，先查阅相关资料，看看别人怎么解决问题的，分析其缺陷，然后自己尝试着提出新的解决办法并验证，看看能否消除这些缺陷。“大胆假设，小心求证。”坚持这个习惯，久而久之会提出有价值问题的。当然，需要做很多努力，平常人不大可能几天就“顿悟”，长期大量积累是必要的。
###### 如何将现有的java工程迁移到k8s？
问：本问题来自阿里云开发者社区的【11大垂直技术领域开发者社群】。https://developer.aliyun.com/article/706511 点击链接欢迎加入感兴趣的技术领域群。
- 答：Java应用迁移到 k8s集群，主要涉及应用容器化、k8s容器编排以及java应用访问并不是一个简单宽泛的问题。 
在迁移之前需要考虑如下问题： 
之前java应用是否有容器化，没有的话需要先将之容器化，将应用制作为docker镜像，存储到镜像仓库
镜像仓库选择，因为业务镜像都是私有镜像，而且dockerhub与国内还有网络延迟问题，如果应用k8s集群在阿里云，推荐使用阿里云镜像仓库，可以直接使用VPC内网地址拉取镜像；或者自己搭建harbor镜像仓库
k8s集群的选择，是阿里云容器服务，还是在ECS上自己搭建K8S集群，这里推荐阿里云容器服务托管版，master节点是免费提供的
使用的java框架，是使用的Spring Cloud 还是 dubbo ，还是其他的，这步很重要，涉及到容器环境下的网络调用模式及服务访问方式
服务的资源分配、Java应用很吃内存，需要确定JVM配置，根据JVM配置来手动配置K8S资源，或者设置JVM自动获取，但是要升级java版本，使其可以正确获取容器内的资源
服务的访问方式，是http访问还是RPC调用，K8S自动服务发现，但是像dubbo这样的框架也都带有服务发现，这里就要确定是使用K8S自带的还是使用框架的，这里推荐使用原来的，这样代码修改量想，更好迁移
如何访问集群，这里推荐使用nginx-ingress来统一接受k8s集群外的访问，nginx-ingress使用的很广泛并且配置简单，易于使用 
上面介绍的都只是迁移之前需要考虑的问题，具体迁移的问题有很多，并不是一个问答能解决的，同时也需要开发和运维人员去适应K8S下的开发模式，淌坑也是必须的。
###### 请问表格存储和日志服务包冲突要怎么处理，使用哪个版本的jar
问：<img src="https://ucc.alicdn.com/pic/developer-ecology/6c22be83d2394105a8aacac66dbb68cd.png" alt="image.png" /> 本问题来自阿里云开发者社区的【11大垂直技术领域开发者社群】。https://developer.aliyun.com/article/706511 点击链接欢迎加入感兴趣的技术领域群。
- 答：可以订阅日志服务中的日志库,以秒级的延时将日志数据从日志服务中读出并转换成结构化数据存储在表格存储中,以满足实时在线
- 答：由于，lib目录中的 struts.jar 和 struts-core-1.3.8.jar 存在冲突 导致部分服务器上应用启动报错，或访问后台JSP页面时报TILES标签错误， 经排查，其实struts.jar中的class文件在 struts-core-1.3.8.jar struts-taglib-1.3.8.jar struts-tiles-1.3.8.jar 中均已存在，且版本要高于struts.jar中的class struts.jar为version1.0 而struts-core-1.3.8.jar，truts-taglib-1.3.8.jar，struts-tiles-1.3.8.jar为version1.2 在struts1.2中引用tiles tld的写法发生变化 故解决办法如下： 1.去掉原strtus.jar 2.去掉struts-tiles.tld 3.将所有JSP页面中的 <%@ taglib uri="/WEB-INF/struts-tiles.tld" prefix="tiles"%> 改为 <%@ taglib uri=" http://struts.apache.org/tags-tiles" prefix="tiles"%> 
答案来源于网络
###### 项目启动成功为何会报java.sql.SQLException: The url cannot be null，数据连接也是可以正常使用的
问：本问题来自云栖社区【阿里Java技术进阶2群】。<a href="https://yq.aliyun.com/articles/690084">https://yq.aliyun.com/articles/690084</a> 点击链接欢迎加入社区大社群。
- 答：在调用自生成增删改查时可以正常访问数据库,调用自己写的方法后就会报SQL错误,The url cannot be null
- 答：查看下数据库连接地址中有没有空格键！
###### Spring由哪些模块组成？
问：Spring由哪些模块组成？
- 答：组成Spring框架的每个模块（或组件）可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 
1) 核心容器：核心容器提供Spring框架的基本功能。核心容器的主要组件式BeanFactory，它是工厂模式的实现。BeanFactory使用控制反转（IOC）模式将应用程序的配置和依赖性规范与实际应用程序代码分开。 
2) Spring上下文：Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校检和调度功能。 
3) Spring AOP：通过配置管理特性，Spring AOP模块直接将面向方面的编程功能集成到了Spring框架中。所以，可以很容易地使Spring框架管理的任何对象支持AOP。Spring AOP模块为基于Spring的应用程序中的对象提供了事务管理服务。通过使用Spring AOP，不用依赖EJB组件，就可以声明性事务管理集成到应用程序中。 
4) Spring DAO：JDBC DAO抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次机构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO的面向JDBC的异常遵从通用的DAO异常层次结构。 
5) Spring ORM：Spring 框架插入了若干个ORM框架，从而提供了ORM的对象关系工具，其中包括JDO、Hibernate和iBatis SQL Map。所欲这些都遵从Spring的通用事务和DAO异常层次结构。 
6) Spring Web模块：Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。所以，Spring框架支持与Jakarta Struts的集成。Web模块还简化了处理多部分请求参数绑定到域对象的工作。 
7) Spring MVC框架：MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的,MVC容纳了大量视图技术,其中包括JSP、Velocity、Titles、iText和POI。
- 答：Spring AOP 面相切面编程 
 Spring ORM Hibernate|mybatis|JDO 
 Spring Core 提供bean工厂 IOC 
 Spring Dao JDBC支持 
 Spring Context 提供了关于UI支持,邮件支持等 
 Spring Web 提供了web的一些工具类的支持 
 Spring MVC 提供了web mvc , webviews , jsp ,pdf ,export
###### Java随机返回负数吗？
问：我想知道，如果我尝试使用以下方法获取随机整数，它应该返回负值吗？ 
int value = new Random().nextInt(bound);
- 答：不应该
- 答：
```
否，Random().nextInt(bound)只会产生0到您指定的数字之间的正数。如果您想使用负数，则需要将随机数相乘 
int number = new Random().nextInt(bound) * -1; Random().nextInt() 可以为您返回负数。
```
###### 有sql和Java代码混合开发的例子吗？
问：本问题来自阿里云开发者社区的【11大垂直技术领域开发者社群】。https://developer.aliyun.com/article/706511 点击链接欢迎加入感兴趣的技术领域群。
- 答：我第一印象就是JDBC
- 答：如果你用的是Mybatis的话，是可以实现的。Mybatis 有 @Insert、@Update、@Delete 和 @Select，这四种注解方式，分别实现了新增、修改、删除和查询。 
代码示例如下： 
@Select("select id, username, password from user")
List<UserVO> getUserInfo();
 
你也可以了解一下 Mybatis Plus ,在不写SQL语句的情况下，实现单表的增删改查操作。 
代码示例如下： 
public void deleteUser(List<Integer> idList) {
    int result = userMapper.delete(new QueryWrapper<User>().lambda().in(User::getId, idList));
    System.out.println(result);
}
###### java技术进阶？从哪方面入手？
问：java技术进阶？从哪方面入手？
- 答：技术进阶的最好办法还是实战，遇到技术瓶颈还是需要实战一下取得突破
- 答：首先java基础很多人都说《think in java》，我觉得还有个途径，ocjd的认证考试，如果去考过jdkse6-8的认证，那么很多坑点都会绕开，比如最基础的多太，重载，重写，集合应用等，然后再看下think in java，开下一些经典的设计套路，或者套路用法
- 答：告诉你，实战，多写代码
- 答：知识清单


常见模式与框架

设计模式
开发框架，比如 spring, springMVC, mybatis



工程化与工具
软件开发流程&规范


分布式架构

负载均衡，高可用
rpc，消息队列
分布式存储


微服务架构

性能优化

应用层：JVM 结构 & 调优
web 服务器层：tomcat 等服务器结构 & 调优
存储层：MySQL 结构 & sql 优化，搜索引擎结构 & 查询优化



底层知识

对 JDK 的包结构，模块深入学习功能&使用场景
围绕数据结构&性能优化学习组织
对于 Java 开发来讲，JDK 几乎就是最底层和基础的知识了。对 JVM, MySQL等非 Java 程序了解结构，原理，调优基本就差不多了。但是 JDK 是要深入了解掌握的，这是你自己开发，学习 Java 程序的基础



从开发到架构师
我理解，1, 2, 5, 6 是高级开发就需要掌握的知识，到架构师级别 3, 4 要理解得比较深入，5, 6 的要求也更高。
技术上是从单体技术 -> 分布式，微服务
局部 -> 整体
简单 -> 深入
因为架构师是一个更宏观的角色，单体系统的时候，单体系统划分、设计功能模块的也是架构师。随着分布式的兴起，架构师需要从分布式角度看整体系统，而到了微服务时代，架构师又要关注微服务，docker 等技术。
- 答：java狭义上说只是这个语言，包括语言的特性和基础库的功能、原理。广义上的java，是以java网络应用为核心的分布式系统所涉及的一系列知识和工具。题主所谓的进阶，应该就是广义的java技术。大致分几类，通信，包括网络层通信涉及的netty、分布式通信涉及的zookeeper；存储，nosql的redis、各种本地缓存，mysql以及相应的持久层框架mybatis、hibernate之类；应用框架，主要是跟java几乎完全绑定的springs。这些方向都可以作为进阶的选择。
###### Java有什么可以比较方便地提取表达式中的变量名吗？
问：Java有什么可以比较方便地提取表达式中的变量名吗？ 
求大神帮忙解答
- 答：
```
一般现在java使用spel表达式多一些.其他的提取变量名多数需要反射,如果是spel.以下可以借鉴. 
@Test
public void testParse() {
    //表达式解析
    ExpressionParser expressionParser = new SpelExpressionParser();
    Expression expression = expressionParser.parseExpression("#itemId");
    EvaluationContext context = new StandardEvaluationContext();
    context.setVariable("itemId", "100");
    log.info("[SpELTest - testParse ] {} ", expression.getValue(context));
    //获取方法参数名
    LocalVariableTableParameterNameDiscoverer discoverer = new LocalVariableTableParameterNameDiscoverer();
    for (Method method : new StringUtils().getClass().getDeclaredMethods()) {
        for (String s : discoverer.getParameterNames(method)) {
            System.out.print("parm: "+s+"  ");
        }
        System.out.println("methodName:  "+method.getName());
    }
}
 
org.springframework.core.LocalVariableTableParameterNameDiscoverer也是Spring解析Controller方法参数使用的类，原理就是读取class字节码，解析其中中的LocalVariableTable，得到方法的参数名称。 注：如果是动态代理出来的类，是拿不到方法参数名的
```
###### 使用Spring框架的好处是什么？
问：使用Spring框架的好处是什么？
- 答：spring翻译过来就是春天的意思，他的出现对Java来说就是春天来了。 1方便解耦，简化开发 2AOP编程的支持 3声明式事务的支持 4方便程序的测试 5方便集成各种优秀框架 6降低JavaEE API的使用难度
###### Java中运算符 |是做什么的？
问：我看了一些Java代码，发现了运算符|，在以下这种情况是做什么的？ 
for (int i=0; i<8; i++) { x[i] = hexBytes[i*4] << 24 | hexBytes[i*4+1] << 16 | hexBytes[i*4+2] << 8 | hexBytes[i*4+3]; }
- 答：按位操作符OR
- 答：按位操作符OR（和AND）可用于位处理。AND可以提取一组位：int lowest8bits = 0xFFFFF & 0xFF;。 
用OR可以插入位。在上面的代码中，int通过将4个字节移到正确的位置并将其OR对齐，将4个字节插入相同的int。 
                       10010010 byte
              10010010          << 8
 
00000000 00000000 00000000 00010110 The int we're building 00000000 00000000 10010010 00010110 End result in int after OR
- 答：| 这是位位运算符
###### 在tomcat中分别为多个war文件配置Java代理
问：我需要在tomcat中配置Java代理。基本上在catalina.sh文件中JAVA_OPT=-javaagent:/agentPath/。但是webapp文件夹中有三个应用程序，例如app1.war，app2.war，app3.war。我需要为每个war文件分别配置Java代理。 
我该怎么做？
- 答：对于初次使用tomcat的程序员，可能会犯一个错，如何在一个tomcat中部署多个war，其实很简单，就是在web项目中的web.xml中加如下配置： 

  

 
  webAppRootKey
  

 
  singel
  
 
注：
 
  webAppRootKey
 可以一样； 

 
  singel
  唯一，可以是项目名
- 答：Java代理附加到正在运行的JVM，而不是Webapp，因此在这种情况下，您需要具有三个正在运行的Tomcat实例。
###### Java：如何验证自然语言文本
问：我正在使用OCR识别图像中的（德语）文本。它运作良好，但并不完美。有时候，一个单词变得一团糟。因此，我想实现某种形式的验证。当然，我可以仅使用单词列表来查找与混乱单词相似的单词，但是有没有一种方法可以检查句子是否适合这些单词？
- 答：你需要寻找自然语言处理（NLP）解决方案。有了它们，您就可以在语法上验证词汇（整个文本可能更好，因为其中一些可能考虑上下文，也可能逐词）。
###### 使用Java开发oss存储项目
问：公司要做一个存储，选择oss,那么使用Java开发oss存储项目，是根据他的api调用他的接口，然后做成一个网站的链接，让公司全员都可以上传下载吗，还是什么样的一个形式。求指导。
- 答：<div class="bbs-subject">
 Re使用Java开发oss存储项目
- 答：可以实现，建议参考oss java的sdk


<a href="https://help.aliyun.com/document_detail/32008.html?spm=a2c4g.11174283.6.655.bc5a7da20leeC9" target="_blank" rel="noopener noreferrer">https://help.aliyun.com/document_detail/32008.html?spm=a2c4g.11174283.6.655.bc5a7da20leeC9</a>
###### 有没有阿里云OSS java的实例？
问：有没有阿里云OSS java的实例？
- 答：可以参考此文章：<a href="https://yq.aliyun.com/articles/704400?spm=a2c4e.11155435.0.0.442433120NPgA2">点击前往</a>
- 答：关于OSS JAVA SDK 代码示例，详情请参考官网说明文档
<a href="https://help.aliyun.com/document_detail/32011.html?spm=a2c4g.11174283.6.662.79ea7da2MRqye0">https://help.aliyun.com/document_detail/32011.html?spm=a2c4g.11174283.6.662.79ea7da2MRqye0</a>
- 答：关于OSS JAVA SDK 代码示例，详情请参考官网说明文档
<a href="https://help.aliyun.com/document_detail/32011.html?spm=a2c4g.11174283.6.662.79ea7da2MRqye0">https://help.aliyun.com/document_detail/32011.html?spm=a2c4g.11174283.6.662.79ea7da2MRqye0</a>

关于OSS Java示例代码，详情可参考官网的JAVA SDK示例：
<a href="https://help.aliyun.com/document_detail/32011.html?spm=a2c4g.11174283.6.662.79ea7da2MRqye0">https://help.aliyun.com/document_detail/32011.html?spm=a2c4g.11174283.6.662.79ea7da2MRqye0</a>
###### JVM参数配置，Maximum memory Pool无法超过1604M
问：JVM参数配置，Maximum memory Pool无法超过1604M？
- 答：之前就有人遇到这个问题啦，您可以现在阿里云开发者社区进行搜索。 以下是帮助相关文档： <a href="https://developer.aliyun.com/ask/54488?spm=a2c6h.13159736">https://developer.aliyun.com/ask/54488?spm=a2c6h.13159736</a> 希望对您有帮助。
###### 镜像可以同时安装不同公司的吗
问：<div>
 你好，我的ECS目前安装一个公共镜像，但是由于后期需要JAVA程序的加入，我怎么使用不同的程序支持呢，目前 只能支持ASP .NET PHP这三种。
- 答：应该可以吧
- 答：<div>
 亲~  公用镜像只是为你先打包好了ASP.NET和PHP环境，
###### weblogic能部署到阿里云的java版服务器上么
问：<div>
 weblogic能部署到阿里云的java版服务器上么
- 答：工具（集成开发工具） jsp是在服务器运行 所以，你只要有像tomcat，jboss，weblogic，resin这样的web应用服务器就可以运行jsp网页 你的jsp网页要放在项目里面，将你的项目部署到服务器上启动服务器就可以访问jsp页面了 tomcat的部署目录是tomcat安装目录/webapps/ jboss的部署目录是jboss安装目录/server/default/deploy/另外两个不是太了解，你可以上网搜搜 在/bin/目录下有个start.bat文件 运行就可以启动服务器 在地址栏里面输入这是访问服务器的根目录，8080是tomcat和jboss的默认端口，想修改的话可以上网查查，或者看看有相关介绍的书籍。访问你的项目就加入你的项目名称比如就可以访问了，jboos和tomcat都是基于java开发的免费web应用服务器，所以前提是你的机子上要安装有jdk环境，以保证服务器的正常运行 
答案来源于网络
###### Java中这个Python列表的等价性是什么样的？
问：我正在尝试学习Java，更具体地说，我正在尝试学习使用数组和列表时的一些差异。现在我正试图了解如何list += [i]*i 在Java中实现这一行。
Sum = 5000
list = [0, 0]
x = 1
while len(list) < Sum:
list += [x]*x
x += 1
我尝试了很多不同的方法，但我似乎无法找到方法。我用Java尝试的方法得到的结果都是错误的。
- 答：填充容器
Collections.nCopies()和Collection.fill()都可以用单个对象的引用来填充Collection，并且所有引用都被设置为指向相同的的对象。 
fill()方法的用处更为有限，它只能替换已经在List中存在的元素，而不能添加新的元素。
- 答：楼上回答的很好
- 答：
```
直接翻译（使用有用的实用程序功能java.util.Collections.nCopies）它变成类似于：
import java.util.*;
int Sum = 5000;  //Following the naming convention in Java (and Python) "Sum" should be lowercase
ArrayList list = new ArrayList();
//Alternatively: List list = new ArrayList();
list.add(0);
list.add(0);
int x = 1;
while (list.size() < Sum) {
list.addAll(Collections.nCopies(x, x));
x += 1;
}
```
###### java能不能直接远程操作flink sql
问：转自钉钉群21789141：java能不能直接远程操作flink sql
- 答：可以的
- 答：徐骁：这边有文档可以看下 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/table/sql.html">https://ci.apache.org/projects/flink/flink-docs-release-1.7/dev/table/sql.html</a>
###### java值传递和址传递？
问：java值传递和址传递？
- 答：函数的参数都是形参，只有在函数调用的时候系统才会为形参分配空间和地址，形参和实参不会是同一个内存地址 
函数传参的值传递和地址传递 例：int a = 1; a在内存中的地址假设是0x001 值传递：传递的变量的值，就是传递的是1这个值 地址传递：传递的是变量的地址，就是传递的是0x001这个地址
- 答：8个基础数据类型+string为值传递，其它为引用传递。
- 答：除了对象都是值传递
- 答：基本类型作为参数传递时，是传递值的拷贝，无论你怎么改变这个拷贝，原值是不会改变的，对象作为参数传递时，是把对象在内存中的地址拷贝了一份传给了参数。
- 答：例如int、double等基本类型是值传递，其它都是址传递，注意基本类型对应的Integer、Double都是对象，也是址传递。
###### 如何模拟道路驾驶情况？JAVA或者其他语言
问：道路驾驶遇到堵车情况，让人头疼，如何模拟道路驾驶，模拟自然驾驶情况？为堵车路况做出改善，提高通行率
- 答：java一般都是用来搭后台软件
- 答：自动驾驶的话， nvidia出了一个模拟器。 自动驾驶相关可以用；
- 答：这个关键在于你首先需要有交通运转的大数据，然后再是算法。本质是一个动态规划，偏预测的算法。
- 答：路过
###### 有没有JAVA开发OSS实例
问：各位大佬，有没有JAVA开发oss的实体，分享一下，小白一个想学习
- 答：这里给出官方的OSS API：OSS API 官方SDK：点击打开链接 官方帮助文档：点击打开链接 OSS GitHub地址：点击打开链接 OSS java 依赖jar包地址：点击下载 参考文章：http://blog.csdn.net/github_36086968/article/details/53113274
- 答：可以参考此文章：<a href="https://yq.aliyun.com/articles/704400?spm=a2c4e.11155435.0.0.442433120NPgA2">点击前往</a>
- 答：这里有示例工程： <a href="https://help.aliyun.com/document_detail/32011.html">https://help.aliyun.com/document_detail/32011.html</a>
###### 想实现一个消息推送服务，该用什么技术？
问：后端服务是 java
- 答：我先假定你要推送给客户端，因为移动互联网时代嘛
如果你自研一套消息推送，你将面临如下难题：
1、客户端的保活机制
2、服务端的消息通道建设
3、客户端的接入通道：小米、华为、oppo有自己的通道、tcp长链接等，都很差异化
以上，等等
推荐直接用阿里的技术：
<a href="https://help.aliyun.com/product/30047.html?spm=a2c4g.11186623.6.540.2c783cdesarXGe">https://help.aliyun.com/product/30047.html?spm=a2c4g.11186623.6.540.2c783cdesarXGe</a>
- 答：可以基于netty和mina做一个推送的程序，netty和mina是基于原生socket封装的nio框架，并且又屏蔽了很多工程同学不需要完全关注的底层细节，可以很好的帮助业务开发同学实现自己的功能
- 答：看场景 websocket, netty 都是很好的选择
- 答：基于rocketMQ 或者kafaka
- 答：推荐使用 websocket 来实现，这是消息推送服务的不二选择， spring 就可以支持
###### Hibernate 和 mybatis 哪个好用？
问：如题，该怎么选择
- 答：个人理解： 大中项目，很规范的，多表联合查询相对少的，速度要快的，选H， 中小项目，上手简单的，SQL文比较复杂的，有可能会多次改动的，选M
- 答：开发对比开发速度Hibernate的真正掌握要比Mybatis来得难些。Mybatis框架相对简单很容易上手，但也相对简陋些。个人觉得要用好Mybatis还是首先要先理解好Hibernate。     
Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。换句话说，使用 Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。这部分细节已经由 Hibernate 掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。而MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。
先从大多数的大型工程会选择mybatis，在灵活度和扩展性方面会更胜一筹
- 答：两者都是现在流行的持久层的开发框架，各有优劣，主要参考项目规模，维护程度，开发人员组成，项目交付时间，数据量规模，表之间关系的复杂度等综合而定，还有就是对于性能方面是否有特定要求。
- 答：这两个都挺好用的，Hibernate 可以不用写 xml，查询更灵活。mybatis 一般使用 xml 来定义映射文件，以及查询规则，用起来也更可控
类比的话，Hibernate 像自动档汽车，mybatis 像手动档汽车

都挺好用的，Hibernate 自动化程度更高一些，一般不用写 xml； mybatis 一般通过 xml 来定义表映射和查询语句
###### hibernate 里面怎么用自定义的 sql 来查询？
问：rt，通过自定义 sql 来查询，而且映射到实体
- 答：SQLQuery query = session.createSQLQuery(sql);映射到实体的话使用： query.setResultTransformer(Transformers.aliasToBean(YourEntity.class));YourEntity.class是你要映射的Bean
- 答：在使用Session来执行save()、update()、delete()操作的时候会通过映射标记来重载Hibernate默认的语句,因此我们可以使用这些标记来让Hibernate加载我们自定义的SQL语句
1).实体类映射文件配置
<hibernate-mapping>
    <class name="com.bc.demo03.pojo.Emp" table="emp" catalog="hibernate_data" lazy="true">
        <id name="empno" type="java.lang.Integer">
            <column name="EMPNO" />
            <generator class="identity"></generator>
        </id>
        <property name="ename" type="java.lang.String">
            <column name="ENAME" length="10" />
        </property>
        <!--因为自定义update语句不涉及此字段,必须设置update="false"-->
        <property name="job" type="java.lang.String" update="false">
            <column name="JOB" length="9" />
        </property>
        <!--因为自定义insert语句不涉及此字段,必须设置insert="false"-->
        <property name="mgr" type="java.lang.Integer" insert="false">
            <column name="MGR" />
        </property>
        <!--其余属性配置同理略-->

        <!--自定义SQL语句-->
        <sql-insert>
            <!--insert和update没有涉及的字段要在字段配置上添加insert="false"-->
            insert into Emp (ename,job) values(?,?)
        </sql-insert>
        <sql-update>
            <!--insert和update没有涉及的字段要在字段配置上添加update="false"-->
            update Emp set ename = ?,mgr = ? where empno = ?
        </sql-update>
        <sql-delete>
            <!--没有涉及的字段要在字段配置上添加delete="false"-->
            delete from Emp where empno = ?
        </sql-delete>
    </class>
</hibernate-mapping>

程序代码
<!--正常调用save() update() delete()就会调用自定义SQL，这里就不写了-->
- 答：SQLQuery sqlQuery = session.createSQLQuery(sql); 即可
###### 服务端 api sdk只看到python2的，什么时候出python3的呢？
问：如题，看到文档中：
环境依赖
JAVA SDK 需要依赖 Java SE/EE 1.5及以上。
.NET SDK 需要依赖 .NET Framework 2.0及以上 （不支持Windows Phone平台）。
Python SDK需要依赖python2
- 答：首先sdkcore是有v3版本的：<a href="https://pypi.org/project/aliyun-python-sdk-core-v3/">https://pypi.org/project/aliyun-python-sdk-core-v3/</a>
其次 官方 <a href="https://github.com/aliyun/aliyun-openapi-python-sdk">https://github.com/aliyun/aliyun-openapi-python-sdk</a>不少是兼容Python3的，不知道你具体使用哪个SDK？
###### 关系型数据库中插入数据时会影响查询吗，就是说插入的时候，如果插入未完成，这个时候可不可以查询？
问：本问题来自云栖社区【阿里Java技术进阶2群】。<a href="https://yq.aliyun.com/articles/690084">https://yq.aliyun.com/articles/690084</a> 点击链接欢迎加入社区大社群。
- 答：一般不会影响
- 答：不影响。
即使配置不同的事务等级，也只是会造成“脏读”和“幻读”而已，不会禁止查询。
###### 有没有前辈遇到过APP地区性的闪退？在做一个项目，其他地区正常，但是新疆地区在调用某个接口的时候，就会导致APP闪退
问：本问题及下方已被采纳的回答均来自云栖社区【阿里Java技术进阶2群】。<a href="https://yq.aliyun.com/articles/690084">https://yq.aliyun.com/articles/690084</a> 点击链接欢迎加入社区大社群。
- 答：这肯定是先要追踪日志的, 大可能是因为网络限制原因导致请求数据不完整
- 答：对比下新疆地区和其他地区调用这个接口拿到的数据是否一直？看其中某些字段是否存在null值
###### Java对接api打成jar包
问：一个完整的项目应该包含业务代码和api，如果我想把api打成jar包，服务端对接的时候，别的项目只需要直接引入jar包，在jar包里面找相应的api即可，那么这样的jar项目该怎么建立？怎么进行打包呢？
- 答：把项目拆解成多个子项目，然后maven走一波
- 答：可以把项目建成多模块项目呀，每个模块引用对应需要的模块就可以了
- 答：可以搜索 maven 多module的关键字学习一下这部分内容
###### Web服务用啥语言？
问：Web服务用啥开发语言做比较合适？比如Java，C++？
- 答：java
- 答：java、 php
- 答：根据业务场景、团队能力选择。 Java、nodejs、Python、golang都可以
- 答：看应用场景和自己擅长的，java，node.js， php都可以
- 答：Java、PHP、Node.js等
###### 什么是线程?
问：本问题来自云栖社区【阿里Java技术进阶2群】。<a href="https://yq.aliyun.com/articles/690084">https://yq.aliyun.com/articles/690084</a> 点击链接欢迎加入社区大社群。
- 答：线程包含于进程中，是操作系统能够进行运算调度的最小单位
- 答：线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位。
- 答：线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。
- 答：线程是进程内部的控制序列，是进程的一个实体，是进程的一条执行路径。线程也就是一个轻量级进程，每个线程都有自己的线程控制块，即一个进程至少有一个轻量级进程。
###### 请教下，Java的项目，都使用哪些自动化方式部署到TOMCAT？
问：本问题来自云栖社区【阿里Java技术进阶2群】。<a href="https://yq.aliyun.com/articles/690084">https://yq.aliyun.com/articles/690084</a> 点击链接欢迎加入社区大社群。
- 答：部署到生产环境的话还是要自己写脚本的，ant使用的比较多社区也比较成熟
- 答：目前的ide基本都支持自动集成了，推荐使用intellij
- 答：java的程序，部署到tomcat上相对简单，只需要将打好的war包，放到tomcat的webapps目录下，启动tomcat就可以自动解压并发布。 
如果要实现自动化的话，可以用shell命令写一个自动脚本。
- 答：常用的CI/CD工具Jenkins
- 答：帮助与文档
###### 有用过spring cloud config吗？
问：有用过spring cloud config吗？ 我配置好了之后，请求 refresh 接口报404错误，这个接口是要在哪里配置的吗？ 
本问题来自阿里云开发者社区的【11大垂直技术领域开发者社群】。https://developer.aliyun.com/article/706511 点击链接欢迎加入感兴趣的技术领域群。
- 答：
```
Spring Cloud 学习笔记（一）——入门、特征、配置 0 放在前面 0.1 参考文档 http://cloud.spring.io/spring-cloud-static/Brixton.SR7/ https://springcloud.cc/ http://projects.spring.io/spring-cloud/ 0.2 maven配置 
  
  
   org.springframework.boot
   
  
   spring-boot-starter-parent
   
  
   1.5.2.RELEASE
   
  
  
   
    
    
     org.springframework.cloud
     
    
     spring-cloud-dependencies
     
    
     Dalston.RELEASE
     
    
     pom
     
    
     import
     
    
   
  
  
   
   
    org.springframework.cloud
    
   
    spring-cloud-starter-config
    
   
   
   
    org.springframework.cloud
    
   
    spring-cloud-starter-eureka
    
   
  0.3 简介 Spring Cloud为开发人员提供了快速构建分布式系统中的一些通用模式（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁，领导选举，分布式 会话，群集状态）。 分布式系统的协调引出样板模式（boiler plate patterns），并且使用Spring Cloud开发人员可以快速地实现这些模式来启动服务和应用程序。 它们可以在任何分布式环境中正常工作，包括开发人员自己的笔记本电脑，裸机数据中心和受管平台，如Cloud Foundry。 Version: Brixton.SR7 1 特征 Spring Cloud专注于为经典用例和扩展机制提供良好的开箱即用 分布式/版本配置 服务注册与发现 路由选择 服务调用 负载均衡 熔断机制 全局锁 领导人选举和集群状态 分布式消息 2 原生云应用程序 原生云是应用程序开发的一种风格，鼓励在持续交付和价值驱动领域的最佳实践。 Spring Cloud的很多特性是基于Spring Boot的。更多的是由两个库实现：Spring Cloud Context and Spring Cloud Commons。 2.1 Spring Cloud Context: 应用上下文服务 Spring Boot关于使用Spring构建应用有硬性规定：通用的配置文件在固定的位置，通用管理终端，监控任务。建立在这个基础上，Spring Cloud增加了一些额外的特性。 2.1.1 引导应用程序上下文 Spring Cloud会创建一个“bootstrap”的上下文，这是主应用程序的父上下文。对应的配置文件拥有最高优先级，并且，默认不能被本地配置文件覆盖。对应的文件名bootstrap.yml或bootstrap.properties。 可通过设置spring.cloud.bootstrap.enabled=false来禁止bootstrap进程。 2.1.2 应用上下文层级结构 当用SpringApplication或SpringApplicationBuilder创建应用程序上下文时，bootstrap上下文将作为父上下文被添加进去，子上下文将继承父上下文的属性。 子上下文的配置信息可覆盖父上下文的配置信息。 2.1.3 修改Bootstrap配置文件位置 spring.cloud.bootstrap.name（默认是bootstrap），或者spring.cloud.bootstrap.location（默认是空） 2.1.4 覆盖远程配置文件的值 spring.cloud.config.allowOverride=true spring.cloud.config.overrideNone=true spring.cloud.config.overrideSystemProperties=false 2.1.5 定制Bootstrap配置 在/META-INF/spring.factories的key为org.springframework.cloud.bootstrap.BootstrapConfiguration，定义了Bootstrap启动的组件。 在主应用程序启动之前，一开始Bootstrap上下文创建在spring.factories文件中的组件，然后是@Beans类型的bean。 2.1.6 定制Bootstrap属性来源 关键点：spring.factories、PropertySourceLocator 2.1.7 环境改变 应用程序可通过EnvironmentChangedEvent监听应用程序并做出响应。 2.1.8 Refresh Scope Spring的bean被@RefreshScope将做特殊处理，可用于刷新bean的配置信息。 注意 需要添加依赖“org.springframework.boot.spring-boot-starter-actuator” 目前我只在@Controller测试成功 需要自己发送POST请求/refresh 修改配置文件即可 2.1.9 加密和解密 Spring Cloud可对配置文件的值进行加密。 如果有"Illegal key size"异常，那么需要安装JCE。 2.1.10 服务点 除了Spring Boot提供的服务点，Spring Cloud也提供了一些服务点用于管理，注意都是POST请求 /env：更新Environment、重新绑定@ConfigurationProperties跟日志级别 /refresh重新加载配置文件，刷新标记@RefreshScope的bean /restart重启应用，默认不可用 生命周期方法：/pause、/resume 2.2 Spring Cloud Commons:通用抽象 服务发现、负载均衡、熔断机制这种模式为Spring Cloud客户端提供了一个通用的抽象层。 2.2.1 RestTemplate作为负载均衡客户端 通过@Bean跟@LoadBalanced指定RestTemplate。注意URI需要使用虚拟域名（如服务名，不能用域名）。 如下： @Configuration public class MyConfiguration { @LoadBalanced @Bean RestTemplate restTemplate() { return new RestTemplate(); } } public class MyClass { @Autowired private RestTemplate restTemplate; public String doOtherStuff() { String results = restTemplate.getForObject(" http://stores/stores", String.class); return results; } } 2.2.2 多个RestTemplate对象 注意@Primary注解的使用。 @Configuration public class MyConfiguration { @LoadBalanced @Bean RestTemplate loadBalanced() { return new RestTemplate(); } @Primary @Bean RestTemplate restTemplate() { return new RestTemplate(); } } public class MyClass { @Autowired private RestTemplate restTemplate; @Autowired @LoadBalanced private RestTemplate loadBalanced; public String doOtherStuff() { return loadBalanced.getForObject(" http://stores/stores", String.class); } public String doStuff() { return restTemplate.getForObject(" http://example.com", String.class); } } 2.2.3 忽略网络接口 忽略确定名字的服务发现注册，支持正则表达式配置。 3 Spring Cloud Config Spring Cloud Config提供服务端和客户端在分布式系统中扩展配置。支持不同环境的配置（开发、测试、生产）。使用Git做默认配置后端，可支持配置环境打版本标签。 3.1 快速开始 可通过IDE运行或maven运行。 默认加载property资源的策略是克隆一个git仓库(at spring.cloud.config.server.git.uri')。 HTTP服务资源的构成： /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties application是SpringApplication的spring.config.name,(一般来说'application'是一个常规的Spring Boot应用),profile是一个active的profile(或者逗号分隔的属性列表),label是一个可选的git标签(默认为"master")。 3.1.1 客户端示例 创建以Spring Boot应用即可，添加依赖“org.springframework.cloud:spring-cloud-starter-config”。 配置application.properties，注意URL为配置服务端的地址 spring.cloud.config.uri: http://myconfigserver.com 3.2 Spring Cloud Config 服务端 针对系统外的配置项(如name-value对或相同功能的YAML内容),该服务器提供了基于资源的HTTP接口。使用@EnableConfigServer注解,该服务器可以很容易的被嵌入到Spring Boot 系统中。使用该注解之后该应用系统就是一个配置服务器。 @SpringBootApplication @EnableConfigServer public class ConfigApplicion { public static void main(String[] args) throws Exception { SpringApplication.run(ConfigApplicion.class, args); } } 3.2.1 资源库环境 {application} 对应客户端的"spring.application.name"属性 {profile} 对应客户端的 "spring.profiles.active"属性(逗号分隔的列表) {label} 对应服务端属性,这个属性能标示一组配置文件的版本 如果配置库是基于文件的，服务器将从application.yml和foo.yml中创建一个Environment对象。高优先级的配置优先转成Environment对象中的PropertySource。 3.2.1.1 Git后端 默认的EnvironmentRepository是用Git后端进行实现的，Git后端对于管理升级和物理环境是很方便的,对审计配置变更也很方便。也可以file:前缀从本地配置库中读取数据。 这个配置库的实现通过映射HTTP资源的{label}参数作为git label(提交id,分支名称或tag)。如果git分支或tag的名称包含一个斜杠 ("/"),此时HTTP URL中的label需要使用特殊字符串"(_)"来替代(为了避免与其他URL路径相互混淆)。如果使用了命令行客户端如 curl，请谨慎处理URL中的括号(例如：在shell下请使用引号''来转义它们)。 Git URI占位符 Spring Cloud Config Server支持git库URL中包含针对{application}和 {profile}的占位符(如果你需要,{label}也可包含占位符, 不过要牢记的是任何情况下label只指git的label)。所以，你可以很容易的支持“一个应用系统一个配置库”策略或“一个profile一个配置库”策略。 模式匹配和多资源库 spring: cloud: config: server: git: uri: https://github.com/spring-cloud-samples/config-repo repos: simple: https://github.com/simple/config-repo special: pattern: special*/dev*,<em>special</em>/dev* uri: https://github.com/special/config-repo local: pattern: local* uri: file:/home/configsvc/config-repo 如果 {application}/{profile}不能匹配任何表达式，那么将使用“spring.cloud.config.server.git.uri”对应的值。在上例子中，对于 "simple" 配置库, 匹配模式是simple/* (也就说,无论profile是什么，它只匹配application名称为“simple”的应用系统)。“local”库匹配所有application名称以“local”开头任何应用系统，不管profiles是什么(来实现覆盖因没有配置对profile的匹配规则，“/<em>”后缀会被自动的增加到任何的匹配表达式中)。 Git搜索路径中的占位符 spring.cloud.config.server.git.searchPaths 3.2.1.2 版本控制后端文件系统使用 伴随着版本控制系统作为后端(git、svn)，文件都会被check out或clone 到本地文件系统中。默认这些文件会被放置到以config-repo-为前缀的系统临时目录中。在Linux上，譬如应该是/tmp/config-repo-
  
   目录。有些操作系统routinely clean out放到临时目录中，这会导致不可预知的问题出现。为了避免这个问题，通过设置spring.cloud.config.server.git.basedir或spring.cloud.config.server.svn.basedir参数值为非系统临时目录。 3.2.1.3 文件系统后端 使用本地加载配置文件。 需要配置：spring.cloud.config.server.native.searchLocations跟spring.profiles.active=native。 路径配置格式：classpath:/, classpath:/config,file:./, file:./config。 3.2.1.4 共享配置给所有应用 基于文件的资源库 在基于文件的资源库中(i.e. git, svn and native)，这样的文件名application
  </em>命名的资源在所有的客户端都是共享的(如 application.properties, application.yml, application-*.properties,etc.)。 属性覆盖 “spring.cloud.config.server.overrides”添加一个Map类型的name-value对来实现覆盖。 例如 spring: cloud: config: server: overrides: foo: bar 会使所有的配置客户端应用程序读取foo=bar到他们自己配置参数中。 3.2.2 健康指示器 通过这个指示器能够检查已经配置的EnvironmentRepository是否正常运行。 通过设置spring.cloud.config.server.health.enabled=false参数来禁用健康指示器。 3.2.3 安全 你可以自由选择任何你觉得合理的方式来保护你的Config Server（从物理网络安全到OAuth2 令牌），同时使用Spring Security和Spring Boot 能使你做更多其他有用的事情。 为了使用默认的Spring Boot HTTP Basic 安全，只需要把Spring Security 增加到classpath中(如org.springframework.boot.spring-boot-starter-security)。默认的用户名是“user”，对应的会生成一个随机密码，这种情况在实际使用中并没有意义，一般建议配置一个密码（通过 security.user.password属性进行配置）并对这个密码进行加密。 3.2.4 加密与解密 如果远程属性包含加密内容(以{cipher}开头),这些值将在通过HTTP传递到客户端之前被解密。 使用略 3.2.5 密钥管理 配置服务可以使用对称(共享)密钥或者非对称密钥(RSA密钥对)。 使用略 3.2.6 创建一个测试密钥库 3.2.7 使用多密钥和循环密钥 3.2.8 加密属性服务 3.3 可替换格式服务 配置文件可加后缀".yml"、".yaml"、".properties" 3.4 文本解释服务 /{name}/{profile}/{label}/{path} 3.5 嵌入配置服务器 一般配置服务运行在单独的应用里面，只要使用注解@EnableConfigServer即可嵌入到其他应用。 3.6 推送通知和总线 添加依赖spring-cloud-config-monitor，激活Spring Cloud 总线，/monitor端点即可用。 当webhook激活，针对应用程序可能已经变化了的，配置服务端将发送一个RefreshRemoteApplicationEvent。 3.7 客户端配置 3.7.1 配置第一次引导 通过spring.cloud.config.uri属性配置Config Server地址 3.7.2 发现第一次引导 如果用的是Netflix，则用eureka.client.serviceUrl.defaultZone进行配置。 3.7.3 配置客户端快速失败 在一些例子里面，可能希望在没有连接配置服务端时直接启动失败。可通过spring.cloud.config.failFast=true进行配置。 3.7.4 配置客户端重试 添加依赖spring-retry、spring-boot-starter-aop，设置spring.cloud.config.failFast=true。默认的是6次重试，初始补偿间隔是1000ms，后续补偿为1.1指数乘数，可通过spring.cloud.config.retry.*配置进行修改。 3.7.5 定位远程配置资源 路径：/{name}/{profile}/{label} "name" = ${spring.application.name} "profile" = ${spring.profiles.active} (actually Environment.getActiveProfiles()) "label" = "master" label对于回滚到之前的版本很有用。 3.7.6 安全 通过spring.cloud.config.password、spring.cloud.config.username进行配置。 
答案来源于网络
```
###### 什么是Java中的非法自引用？
问：当我尝试编译以下类时 
class C1 { Integer v1 = v1; } Illegal Self Reference出错了。现在考虑下面的另一个类。 
class C2 { Integer v1; { v1 = v1; } } 并编译。这两个类之间有什么区别，为什么一个编译而一个不编译。 
更新： 
如果v1上课没有可用C1，那么为什么下面的类也能工作？ 
class C3 { Integer v1 = v1 = 1; } 在上述C3类中，v1可用于计算表达式v1=1，但它在c1中的工作方式不同。你能解释一下吗？
- 答：比如你要使用一个对象的成员方法,但那个对象本身是null,无法提供正确的成员方法的服务。那个时候就会抛出一个空引用异常。
- 答：v1 定义后开始存在，因此当你尝试将值保存到自身时尚不存在： 
class C1 { Integer v1 = v1; //declaring-^ ^-doesn't exist yet } 这是等效的代码： 
public class SomeClass { Integer v1; //声明.... ^ 
public SomeClass() {
    this.v1 = v1;
 
// ^-----^ // | // both exist } } 在您的示例中，实例变量代码在声明变量之后执行，就像构造函数一样： 
class C2 { Integer v1; { v1 = v1; // instance block executed after variable declaration } }
###### Java-使用http协议通过网络发送数百万条记录的最佳方法
问：我需要使用http协议通过有线传输近一百万条记录，目前我正在使用apachehttp池rest client n逐个发送。有没有更好更快的方法来实现这个目标？Java中有框架或其他方式吗？有什么方法可以在java中实现多编写器概念吗？
- 答：如果服务器可以处理大请求，那么我将在一个请求中将它们全部发送出去。过去，我已经使用Java HTTP客户端和Java HTTP服务器测试了这种情况，在这些情况下，我发送的最大请求大小为500MB，没有问题。
###### java rocketmq 生产者如何取得消费者的消费结果
问：java rocketmq 生产者如何取得消费者的消费结果？
- 答：这属于消费回执，目前是没有这个功能的。
- 答：RocketMQ第一阶段发送Prepared消息时，会拿到消息的地址,第二阶段执行本地事物，第三阶段通过第一阶段拿到的地址去访问消息，并修改消息的状态。当RocketMQ确认消息发送失败时，RocketMQ会定期扫描消息集群中的事物消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认.
- 答：生产者、消费者，都是经过消息队列，来实现通信。生产者，可以生产消息，消费者去消费，完成之后，将结束消息传递给生产者
- 答：每个消费者处理完成请求，再发送消息到消息队列中，你的生产者那方再实现消费者来消费这些处理结果信息；然后处理你的逻辑，将处理结果存于缓存等高性能组件中，通过轮询的方式获取任务处理结果
###### rocketmq发送消息遇到system busy怎么处理？
问：rocketmq发送消息遇到system busy怎么处理？
- 答：这个是解决broker busy的 
waitTimeMillsInSendQueue=3000 
这个是解决system busy的 
osPageCacheBusyTimeOutMills=3000
###### RocketMQ 是什么
问：RocketMQ 是什么
- 答：rocketmq提供了master/slave的结构,salve定时从master同步数据,如果master宕机,则slave提供消费服务,但是不能写入消息,
- 答：RocketMQ是阿里巴巴的自研开发的一款纯java、分布式、队列模型的开源消息中间件，他参考了Java的JMS规范，但是它并没有遵循JMS的规范，经历了淘宝双十一的洗礼，在功能和性能上据说是远超ActiveMQ。它具有高性能、高可靠、高实时、分布式特点
- 答：RcoketMQ 是一款低延迟、高可靠、可伸缩、易于使用的消息中间件。具有以下特性： 
支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型 在一个队列中可靠的先进先出（FIFO）和严格的顺序传递 支持拉（pull）和推（push）两种消息模式 单一队列百万消息的堆积能力 支持多种消息协议，如 JMS、MQTT 等 分布式高可用的部署架构,满足至少一次消息传递语义 提供 docker 镜像用于隔离测试和云集群部署 提供配置、指标和监控等功能丰富的 Dashboard
###### producer
问：Producer
- 答：如果用户有定义就进行处理并返回处理后的ProducerRecord,否则直接返回本身。 然后②中doSend真正发送消息,并且是异步的(源码太长只保留关键)
- 答：在消息中间件中，有producer/consumer的概念，producer就是消息生产者，作用是生产消息并想消息中间件中发消息，consumer是消费消息队列中的消息，消费方式可能是主动pull或者消息中间件push到consumer端
- 答：消息生产者，生产者的作用就是将消息发送到 MQ，生产者本身既可以产生消息，如读取文本信息等。也可以对外提供接口，由外部应用来调用接口，再由生产者将收到的消息发送到 MQ。
###### Producer Group
问：Producer Group
- 答：生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。
###### Consumer
问：Consumer
- 答：消费者在消费的过程中需要记录自己消费了多少数据，即消费位置信息。在Kafka中这个位置信息有个专门的术语：位移(offset)。很多消息引擎都把这部分信息保存在服务器端(broker端)。这样做的好处当然是实现简单
- 答：对consumer有个问题。 设置properties.put(PropertyKeyConst.ConsumeThreadNums, 4); 实际线程数是68。 想知道线程数都与什么有关系。 使用的是 com.aliyun.openservices.ons.api.ONSFactory
- 答：Consumer：消费生产者生产的消息，rocketmq中有两种方式消费消息，一种是PullConsumer主动从消息队列中pull消息，另一种PushConsumer，是消息队列服务器主动推送到consumer端进行消费。
- 答：消息消费者，简单来说，消费 MQ 上的消息的应用程序就是消费者
###### Consumer Group
问：Consumer Group
- 答：每一个consumer实例都属于一个consumer group,每一条消息只会被同一个consumer group里的一个consumer实例消费。
- 答：消费同一类消息的多个 consumer 实例组成一个消费者组
###### Topic
问：Topic
- 答：物联网平台中,服务端和设备端通过Topic来实现消息通信。Topic是针对设备的概念,Topic类是针对产品的概念。
- 答：Topic 是一种消息的逻辑分类，比如说你有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。
###### Tag
问：Tag
- 答：<a href="https://yq.aliyun.com/articles/715069?spm=a2c4e.11155435.0.0.30e64c85TnJWSf">标签最佳实践 </a> 
<a href="https://yq.aliyun.com/articles/717310?spm=a2c4e.11155435.0.0.30e64c85E1lvZu">标记您的阿里云资源</a>
- 答：标签可以被认为是对 Topic 进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。
###### Name Server
问：Name Server 
本问题来自阿里云开发者社区的【11大垂直技术领域开发者社群】。 <a href="https://developer.aliyun.com/article/713951"> 点击链接</a>欢迎加入感兴趣的技术领域群。
- 答：NameServer的主要功能是为整个MQ集群提供服务协调与治理,具体就是记录维护Topic、Broker的信息,及监控Broker的运行状态。
- 答：Name Server 为 producer 和 consumer 提供路由信息
###### 单 master 模式
问：单 master 模式
- 答：RocketMQ 单机部署(单master模式)
- 答：就是只有一个 master 节点，称不上是集群，一旦这个 master 节点宕机，那么整个服务就不可用，适合个人学习使用。
###### 多 master 模式
问：多 master 模式
- 答：一个集群全部都是Master，没有Slave 　　优点：配置简单，单个Master宕机或者是重启维护对应用没有什么影响的，在磁盘配置为RAID10时，即使机器宕机不可恢复的情况下，消息也不会丢失（异步刷盘丢失少量消息，同步刷盘则是一条都不会丢失），性能最高 　　缺点：当单个Broker宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息的实时性会受到影响
- 答：多个 master 节点组成集群，单个 master 节点宕机或者重启对应用没有影响。
###### 多 master 多 slave 异步复制模式
问：多 master 多 slave 异步复制模式
- 答：在多 master 模式的基础上，每个 master 节点都有至少一个对应的 slave。master 节点可读可写，但是 slave 只能读不能写，类似于 mysql 的主备模式。
###### 多 master 多 slave 同步双写模式
问：多 master 多 slave 同步双写模式
- 答：master-slave Master/Slave master slave 多主同步 多表同步 同步模式 多设备同步 多仓库同步 多线程同步 多线程 同步 Master-Slave master-slave
- 答：同多 master 多 slave 异步复制模式类似，区别在于 master 和 slave 之间的数据同步方式。
###### RocketMq各个角色间的关系
问：RocketMq各个角色间的关系
- 答：RocketMq中每个Broker（master和slave）与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。 Name Server之间不会有任何信息交互，各自独立。 producer和consumer随机从一个name server即可获得全部topic的路由信息。 producer根据得到的路由信息，同master建立长连接。 consumer根据路由信息，同master个salve都建立长连接。然后根据设置的订阅规则，选择从master或者slave订阅消息
###### 同步刷盘和异步刷盘
问：同步刷盘和异步刷盘
- 答：同步刷盘和异步刷盘的区别如下: 
同步刷盘:当数据写如到内存中之后立刻刷盘(同步)，在保证刷盘成功的前提下响应client。
异步刷盘:数据写入内存后，直接响应client。异步将内存中的数据持久化到磁盘上。
- 答：同步刷盘是说，broker在收到每个消息后，都是先要保存到硬盘上，然后再给producer确认。异步刷盘就是先回复确认，然后批量保存到硬盘上。异步刷盘有更好的性能，当然也有更大的丢失消息的风险。
###### 同步复制和异步复制
问：同步复制和异步复制
- 答：同步是说在salve也存储了消息后再答复producer。 异步复制是先答复producer，再去向salve复制。
###### MQPullConsumer
问：MQPullConsumer
- 答：push方式里，consumer把轮询过程封装了，并注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉消息是被推送（push）过来的。
###### Push（推模式）
问：Push（推模式）
- 答：推模型需要开发人员编写代码以连接到数据库，执行 SQL 命令以创建与报表中的字段匹配的记录集或数据集，并且将该对象传递回给报表。该方法使您可以将连接共享置入应用程序中，并在 Crystal Reports 收到数据之前先将数据筛选出来。此时开发报表不得不自己编写代码连接数据并组装DataSet，同时将它传送至报表。在这种情况下，通过使用连接共享以及答限制记录集合的大小，可以使用报表性能最大化。
- 答：Broker主动向Consumer推消息，它Consumer的一种，应用通常向对象注册一个Listener接口，一旦接收到消息，Consumer对象立刻回调Linstener接口方法。Push方式里,consumer把轮询过程封装了,并注册MessageListener监听器,取到消息后,唤醒MessageListener的consumeMessage()来消费,对用户而言,感觉消息是被推送过来的。 缺点是：慢消费无疑是Push模式最大的致命伤,如果消费者的速度比发送者的速度慢很多,势必造成消息在broker的堆积。假设这些消息都是有用的无法丢弃的,消息就要一直在broker端保存。当然这还不是最致命的,最致命的是broker给consumer推送一堆consumer无法处理的消息,consumer不是reject就是error,然后来回踢皮球。所以push适合于没有慢消费情况的场景下
- 答：推模式指的是客户端与服务端建立好网络长连接，服务方有相关数据，直接通过长连接通道推送到客户端。其优点是及时，一旦有数据变更，客户端立马能感知到；另外对客户端来说逻辑简单，不需要关心有无数据这些逻辑处理。缺点是不知道客户端的数据消费能力，可能导致数据积压在客户端，来不及处理。
###### Pull（拉模式）
问：Pull（拉模式）
- 答：Consumer主动的从Broker拉取消息，主动权由应用控制，可以实现批量的消费消息。Pull方式里,取消息的过程需要用户自己写,首先通过打算消费的Topic拿到MessageQueue的集合,遍历MessageQueue集合,然后针对每个MessageQueue批量取消息,一次取完后,记录该队列下一次要取的开始offset,直到取完了,再换另一个MessageQueue。 　　反观Pull模式,consumer可以按需消费,不用担心自己处理不了的消息来骚扰自己,而broker堆积消息也会相对简单,无需记录每一个要发送消息的状态,只需要维护所有消息的队列和偏移量就可以了。所以对于慢消费,消息量有限且到来的速度不均匀的情况,pull模式比较合适消息延迟与忙等。 
　
- 答：拉模式指的是客户端主动向服务端发出请求，拉取相关数据。其优点是此过程由客户端发起请求，故不存在推模式中数据积压的问题。缺点是可能不够及时，对客户端来说需要考虑数据拉取相关逻辑，何时去拉，拉的频率怎么控制等等。
###### 长轮询
问：长轮询
- 答：基于HTTP的长连接,是一种通过长轮询方式实现"服务器推"的技术,它弥补了HTTP简单的请求应答模式的不足,极大地增强了程序的实时性和交互性。
- 答：服务端如果此时没有数据，保持连接。等到有数据返回（相当于一种push），或者超时返回。
###### 消息堆积
问：消息堆积
- 答：消息堆积的能力是评价一个消息中间件的重要方面。因为使用消息中间件有一部分功能是为了为后端系统挡住数据洪峰。在产生消息堆积时，消息中间件对外的服务能力至关重要。
###### 分布式事务
问：分布式事务
- 答：在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息,本地事务能保证这个消息一定会被写入本地消息表中。
- 答：首先需要理解分布式是什么，然后理解事务是什么，最后理解队列中分布式事务的处理实现。 分布式，概念存在于多个系统，区别于单体应用，采用分布式，分开部署应用，减小耦合程度，降低开发难度 事务，用来保持执行一致性，包括数据库的写入、查询等 在队列中，对分布式事务的处理，存在于多个消费者，消费同一条消息，如何保证，执行结果不会出现理论偏差。这就要求，当消费者消费消息时，要对处理做一定的实现。比如说，要改变数据库一个字段的值，那么当一个消费时消费消息，操作该值，时，要上一个悲观锁，操作完毕之后，发送消息给生产者，生产者及时改变状态。消费者再消费同一个消息，需要先查询一下，是否有人再消费，没有消费，有人的话，自动等待结果
- 答：分布式事务涉及到两阶段提交。分为预提交阶段和commit阶段。在commit阶段需要回去改消息的状态。RocketMq在这里没有使用KV存储来做。而是在commit阶段会拿到消息的offset，然后直接去找消息，修改其状态。这样的好处是设计更简单，速度更快。缺点是会产生过多的数据脏页。
###### MQPushConsumer
问：MQPushConsumer
- 答：Push 默认使用的是DefaultMQPushConsumer。
- 答：push方式里，consumer把轮询过程封装了，并注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉消息是被推送（push）过来的。
###### Broker
问：Broker
- 答：Broker是ActiveMQ的一个实例。我们可以将ActiveMQ看成一个服务
- 答：Broker 是 RocketMQ 系统的主要角色，其实就是前面一直说的 MQ。Broker 接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。
###### Message
问：Message
- 答：阿里云消息服务(Message Service,原 MQS)是阿里云商用的消息中间件服务。
- 答：Message 是消息的载体。一个 Message 必须指定 topic，相当于寄信的地址。Message 还有一个可选的 tag 设置，以便消费端可以基于 tag 进行过滤消息。也可以添加额外的键值对
###### 采用MQ的有什么优点？
问：采用MQ的有什么优点？
- 答：1）不需要预留buffer，上游任务执行完，下游任务总会在第一时间被执行 2）依赖多个任务，被多个任务依赖都很好处理，只需要订阅相关消息即可 3）有任务执行时间变化，下游任务都不需要调整执行时间
###### 你对 Namesrv 的了解？
问：你对 Namesrv 的了解？
- 答：Namesrv就是RMQ中的路由服务,相当于ZK在Kafka中的作用,实现了路由管理、服务注册、服务
- 答：Name Server 为 producer 和 consumer 提供路由信息
###### 请说说你对 Broker 的了解？
问：请说说你对 Broker 的了解？
- 答：Broker 接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。
###### topic是什么？
问：topic是什么？
- 答：Topic 是一种消息的逻辑分类，比如说你有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单 Topic 存放订单相关的消息，一个是库存 Topic 存储库存相关的消息。
###### RocketMQ 由哪些角色组成？
问：RocketMQ 由哪些角色组成？
- 答：生产者（Producer）：负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。 
消费者（Consumer）：负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。 
消息服务器（Broker）：是消息存储中心，主要作用是接收来自 Producer 的消息并存储， Consumer 从这里取得消息。 
名称服务器（NameServer）：用来保存 Broker 相关 Topic 等元信息并给 Producer ，提供 Consumer 查找 Broker 信息。
###### RocketMQ执行流程
问：RocketMQ执行流程？
- 答：1、启动 Namesrv，Namesrv起 来后监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心。 
2、Broker 启动，跟所有的 Namesrv 保持长连接，定时发送心跳包。 
3、收发消息前，先创建 Topic 。创建 Topic 时，需要指定该 Topic 要存储在 哪些 Broker上。也可以在发送消息时自动创建Topic。 
4、Producer 发送消息。 
5、Consumer 消费消息
###### 怎么理解 Producer 的？
问：怎么理解 Producer 的？
- 答：1、获得 Topic-Broker 的映射关系。 Producer 启动时，也需要指定 Namesrv 的地址，从 Namesrv 集群中选一台建立长连接。 生产者每 30 秒从 Namesrv 获取 Topic 跟 Broker 的映射关系，更新到本地内存中。然后再跟 Topic 涉及的所有 Broker 建立长连接，每隔 30 秒发一次心跳。 
2、生产者端的负载均衡。 生产者发送时，会自动轮询当前所有可发送的broker，一条消息发送成功，下次换另外一个broker发送，以达到消息平均落到所有的broker上。
###### 怎么理解 Consumer 的？
问：怎么理解 Consumer 的？
- 答：1、获得 Topic-Broker 的映射关系。 Consumer 启动时需要指定 Namesrv 地址，与其中一个 Namesrv 建立长连接。消费者每隔 30 秒从 Namesrv 获取所有Topic 的最新队列情况， Consumer 跟 Broker 是长连接，会每隔 30 秒发心跳信息到Broker . 
2、消费者端的负载均衡。根据消费者的消费模式不同，负载均衡方式也不同。
###### 消费者消费模式有几种？
问：消费者消费模式有几种？
- 答：消费者消费模式有两种：集群消费和广播消费。
###### 消费者获取消息有几种模式？
问：消费者获取消息有几种模式？
- 答：推送模式和拉取模式。
###### 定时消息是什么？怎样实现的？
问：定时消息是什么？怎样实现的？
- 答：如果需要发送定时DING消息，在编写钉消息的时候，发送时间选择【在指定时间发送】并设置好，DING消息会在你设定的时间点进行发送。
- 答：是指消息发到 Broker 后，不能立刻被 Consumer 消费，要到特定的时间点或者等待特定的时间后才能被消费。
###### mq消息的丢失和队列的使用策略是怎样的？
问：mq消息的丢失和队列的使用策略是怎样的？
- 答：网络不可达。只要通过网络交换数据，就无法避免这个问题。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现
###### 为什么使用MQ?
问：为什么使用MQ?
- 答：主要是解耦、异步、削峰。
###### MQ如何保证高可用的？
问：MQ如何保证高可用的？
- 答：rabbitMQ对于高可用是基于主从的方式进行实现.其有三种工作模式:单机模式、普通集群模式、镜像集群模式单机模式:生产模式不可能使用.
- 答：RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。
###### 如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？
问：如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？
- 答：假设有个系统，消费一条消息就往数据库里插入一条数据，但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。
###### 如何保证消息的可靠性传输啊？要是消息丢失了怎么办啊？
问：如何保证消息的可靠性传输啊？要是消息丢失了怎么办啊？
- 答：数据的丢失问题，可能出现在生产者、MQ、消费者中
###### 如何保证消息顺序性
问：如何保证消息顺序性
- 答：一个 queue对应一个 consumer，然后consumer做队列排序
###### 如何解决消息队列的延时以及过期失效问题？
问：如何解决消息队列的延时以及过期失效问题？
- 答：先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。
###### 消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？
问：消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？
- 答：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。
###### 怎样设计MQ会更好
问：怎样设计MQ会更好？
- 答：首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -> topic -> partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？
###### 消息队列如何选型？
问：消息队列如何选型？
- 答：RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。不考虑rocketmq和kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。不考虑rocketmq的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。
###### 如何解决高性能读写数据的问题？
问：如何解决高性能读写数据的问题？
- 答：内存和文件映射，减少数据的复制。
###### 如何解决数据重复发送的问题？
问：如何解决数据重复发送的问题？
- 答：重复消费和重复发送是同一个问题，因为数据重复发送，才导致重复消费。
###### 什么是解耦？
问：什么是解耦？
- 答：耦合是指两个或两个以上的体系或两种运动形式间通过相互作用而彼此影响以至联合起来的现象。 解耦就是用数学方法将两种运动分离开来处理问题
- 答：A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。
###### 什么是异步？
问：什么是异步？
- 答：异步：一种通讯方式，对设备需求简单。我们的PC机提供的标准通信接口都是异步的。异步双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送
- 答：如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。
###### 什么是削峰？
问：什么是削峰？
- 答：主要是还是来自于互联网的业务场景，例如，马上即将开始的春节火车票抢购，大量的用户需要同一时间去抢购；以及大家熟知的阿里双11秒杀， 短时间上亿的用户涌入，瞬间流量巨大（高并发），比如：200万人准备在凌晨12:00准备抢购一件商品，但是商品的数量缺是有限的100-500件左右。 
这样真实能购买到该件商品的用户也只有几百人左右， 但是从业务上来说，秒杀活动是希望更多的人来参与，也就是抢购之前希望有越来越多的人来看购买商品。
- 答：减少高峰时期对服务器压力。
###### 什么是spring
问：什么是spring
- 答：Spring为简化企业级开发而生，使用Spring开发可以将Bean对象，Dao组件对象，Service组件对象等交给Spring容器来管理，这样使得很多复杂的代码在Spring中开发却变得非常的优雅和简洁，有效的降低代码的耦合度，极大的方便项目的后期维护、升级和扩展。
- 答：Spring是一个开源的轻量级的企业应用级框架，包含了控制反转IOC和面向刨面编程AOP，现在已经形成了一个系列。
- 答：Spring是一套来源的轻量级框架，其特色是IOc与Aop
- 答：spring是一套为了简化开发而生的轻量级的开源框架。spring中有ioc和aop两大概念。
- 答：Spring是一个轻量级的控制反转和面向切面的容器框架
###### spring的特点
问：spring的特点
- 答：轻量、 控制反转、面向切面、容器、框架
###### Spring包括哪些内容
问：Spring包括哪些内容
- 答：核心技术 IoC 和 AOP； 数据访问 （持久层解决方案）； Web层解决方案 SpringMVC； 集成 （整合其他开源框架）；
###### 使用Spring有什么好处
问：使用Spring有什么好处
- 答：方便解耦，简化开发 （高内聚低耦合） Spring就是一个大工厂（容器），可以将所有对象创建和依赖关系维护，交给Spring管理 spring工厂是用于生成bean AOP编程的支持 Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 声明式事务的支持 只需要通过配置就可以完成对事务的管理，而无需手动编程 方便程序的测试 Spring对Junit4支持，可以通过注解方便的测试Spring程序 方便集成各种优秀框架 Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的直接支持 降低JavaEE API的使用难度 Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低
- 答：低侵入式设计，代码污染极低； 独立于各种应用服务器； Spring的DI机制降低了业务对象替换的复杂性； Spring并不完全依赖于Spring，开发者可自由选用Spring框架的部分或全部
###### spring中的核心类有那些，各有什么作用
问：spring中的核心类有那些，各有什么作用
- 答：BeanFactory：产生一个新的实例，可以实现单例模式 
BeanWrapper：提供统一的get及set方法 
ApplicationContext:提供框架的实现，包括BeanFactory的所有功能
###### spring常用的类和接口有哪些
问：spring常用的类和接口有哪些
- 答：ApplicationContextAware接口； ApplicationEvent抽象类； ApplicationListener接口； BeanNameAware接口； InitializingBean接口； DisposableBean接口； BeanPostProcessor接口； BeanFactoryPostProcessor接口
###### spring事务的原理
问：spring事务的原理
- 答：spring中的事务，使用aop切面实现声明式事务，在spring中定义了一个Transaction注解，当方法中使用了该注解时，在调用方法之前会先调用切面方法，开启事务，然后执行方法，根据方法的执行情况判断是回滚还是提交，所以如果在spring的方法中捕获了异常时，spring的事务在发生异常时将不会回滚
- 答：代码中无需关于关注事务逻辑，让Spring声明式事务管理负责事务逻辑，声明式事务管理无需与具体的事务逻辑耦合，可以方便地在不同事务逻辑之间切换
###### 什么是IOC，什么又是DI，他们有什么区别
问：什么是IOC，什么又是DI，他们有什么区别
- 答：DI：依赖注入,指的是spring创建对象的过程中，将对象依赖属性通过配置的方式进行注入 IOC:控制反转，指将对象的创建权，反转到Spring容器，不再是由调用者去new对象了，二十由spring容器去创建对象，两者之间的关系是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。di是ioc的实现方式  
- 答：DI是一个程序设计模式和架构模型，依赖注入是一个IOC的特殊实现，依赖注入是指一个对象应用另外一个对象来提供一个特殊的能力
###### Bean注入属性的几种方式
问：Bean注入属性的几种方式
- 答：接口注入；构造器注入；setter方法注入
###### 什么是aop，aop的作用是什么
问：什么是aop，aop的作用是什么
- 答：aop是提供另外一种角度来思考程序结构，通过这种方式弥补了面向对象编程（OOP）的不足，除了类（classes）以外，AOP提供了切面。切面对关注点进行模块化，例如横切多个类型和对象的事务管理 
Spring的一个关键的组件就是AOP框架，可以自由选择是否使用AOP 提供声明式企业服务，特别是为了替代EJB声明式服务。最重要的服务是声明性事务管理，这个服务建立在Spring的抽象事物管理之上。允许用户实现自定义切面，用AOP来完善OOP的使用,可以把Spring AOP看作是对Spring的一种增强
###### AOP里面重要的几个名词概念解释
问：AOP里面重要的几个名词概念解释
- 答：切面（Aspect）： 一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。 
连接点（Joinpoint）： 在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。 
通知（Advice）： 在切面的某个特定的连接点（Joinpoint）上执行的动作。 
切入点（Pointcut）： 匹配连接点（Joinpoint）的断言。 
引入（Introduction）： 声明额外的方法或者某个类型的字段。 
目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做被通知（advised）对象。 
AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。 
织入（Weaving）： 把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象。
###### Spring框架中Bean的生命周期和作用域
问：Spring框架中Bean的生命周期和作用域
- 答：(1) bean定义 
在配置文件里面用
 来进行定义。 
(2) bean初始化 
有两种方式初始化: 
A.在配置文件中通过指定init-method属性来完成 
B.实现org.springframwork.beans.factory.InitializingBean接口 
(3) bean调用 
有三种方式可以得到bean实例，并进行调用 
(4) bean销毁
###### Bean的初始化方式有哪些
问：Bean的初始化方式有哪些
- 答：在配置文档中通过指定init-method 属性来完成；实现 org.springframwork.beans.factory.InitializingBean接口
###### Bean的调用方式有哪些
问：Bean的调用方式有哪些
- 答：1、使用BeanWrapper 
2、使用BeanFactory 
3、使用ApplicationConttext
###### Bean的销毁方式有哪些
问：Bean的销毁方式有哪些
- 答：我们发现继承InitializingBean接口实现的afterPropertiesSet方法在属性设置之后执行,继承DisposableBean接口实现destroy方法在对象销毁之后执行。
- 答：1、使用配置文件中的 destory-method 属性 
2、实现 org.springframwork.bean.factory.DisposebleBean接口
###### Spring的事务管理
问：Spring的事务管理
- 答：对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之 前的所有操作。
###### Spring里面如何配置数据库驱动
问：Spring里面如何配置数据库驱动
- 答：使用”org.springframework.jdbc.datasource.DriverManagerDataSource”数据源来配置数据库驱动。
###### Spring里面applicationContext.xml文件能不能改成其他文件名
问：Spring里面applicationContext.xml文件能不能改成其他文件名
- 答：ContextLoaderListener是一个ServletContextListener, 它在web应用启动的时候初始化。缺省情况下， 它会在WEB-INF/applicationContext.xml文件找Spring的配置。 可以通过定义一个
 
  元素名字为”contextConfigLocation”来改变Spring配置文件的 位置。
###### 如何在web应用里面配置spring
问：如何在web应用里面配置spring
- 答：在web.xml中加入如下同容,在启动web服务器时加载/WEB-INF/applicationContext.xml中的内容。 

  

 
  context
  

  
org.springframework.web.context.ContextLoaderServlet 
 

 
  1
  
 
通过如下类得到ApplicationContext实例 
WebApplicationContextUtils.getWebApplicationContext
###### Spring里面如何定义hibernate mapping
问：Spring里面如何定义hibernate mapping
- 答：添加hibernate mapping 文件到web/WEB-INF目录下的applicationContext.xml文件里面。示例如下： 

  

  

 
  org/appfuse/model/User.hbm.xml
###### spring中的BeanFactory与ApplicationContext的作用有哪些
问：spring中的BeanFactory与ApplicationContext的作用有哪些
- 答：BeanFactory负责读取bean配置文档，管理bean的加载，实例化，维护bean之间的依赖关系，负责bean的声明周期。 
 ApplicationContext除了提供上述BeanFactory所能提供的功能之外，还提供了更完整的框架功能：
###### BeanFactory 接口 和 ApplicationContext 接口区别
问：BeanFactory 接口 和 ApplicationContext 接口区别
- 答：ApplicationContext 接口继承 BeanFactory 接口 ，Spring核心工厂是BeanFactory ,BeanFactory 采取延迟加载，第一次getBean时才会初始化Bean , ApplicationContext 是会在加载配置文件时初始化Bean；ApplicationContext是对BeanFactory扩展
###### 如何在web环境中配置applicationContext.xml文件
问：如何在web环境中配置applicationContext.xml文件
- 答：context
  

  
org.springframework.web.context.ContextLoaderServlet 
 

 
  1
###### 如何在spring中实现国际化
问：如何在spring中实现国际化
- 答：在applicationContext.xml加载一个bean 
<bean id=”messageSource”
class=”org.springframework.context.support.ResourceBundleMessageSource”>
<property name=”basename”>
<value>message</value>
</property>
###### Spring如何处理线程并发问题
问：Spring如何处理线程并发问题
- 答：关键词：ThreadLocal 
ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 
在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。 
而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。 
由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。
- 答：对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。
###### Spring 中BeanFactory与ApplicationContext的差别
问：Spring 中BeanFactory与ApplicationContext的差别
- 答：BeanFactory 提供了配置框架和基本的功能， 而ApplicationContext 为它增加了更强的功能，这些功能中的一些或许更加接近J2EE 并且围绕企业级应用。一般来说，ApplicationContext是 BeanFactory 的完全超集， 任何 BeanFactory 功能和行为的描述也同样被认为适用于ApplicationContext
###### 服务挂了，如何解决
问：服务挂了，如何解决
- 答：①重试机制 
②限流 
③熔断机制 
④负载均衡 
⑤降级（本地缓存）
###### 常见的设计模式和应用
问：常见的设计模式和应用
- 答：1、API Gateway 
2、服务间调用 
3、服务发现 
4、服务容错 
5、服务部署 
6、数据调用
###### 聚合器微服务设计模式
问：聚合器微服务设计模式
- 答：聚合器调用多个服务实现应用程序所需的功能。它可以是一个简单的Web页面，将检索到的数据进行处理展示。它也可以是一个更高层次的组合微服务，对检索到的数据增加业务逻辑后进一步发布成一个新的微服务，这符合DRY原则。另外，每个服务都有自己的缓存和数据库。如果聚合器是一个组合服务，那么它也有自己的缓存和数据库。聚合器可以沿X轴和Z轴独立扩展。
###### 代理微服务设计模式
问：代理微服务设计模式
- 答：客户端并不聚合数据，但会根据业务需求的差别调用不同的微服务。代理可以仅仅委派请求，也可以进行数据转换工作。
###### 链式微服务设计模式
问：链式微服务设计模式
- 答：服务A接收到请求后会与服务B进行通信，类似地，服务B会同服务C进行通信。所有服务都使用同步消息传递。在整个链式调用完成之前，客户端会一直阻塞。 因此，服务调用链不宜过长，以免客户端长时间等待。
###### 分支微服务设计模式
问：分支微服务设计模式
- 答：这种模式是聚合器模式的扩展，允许同时调用两个微服务链
###### 数据共享微服务设计模式
问：数据共享微服务设计模式
- 答：在重构现有的“单体应用（monolithic application）”时，SQL数据库反规范化可能会导致数据重复和不一致， 因此，在单体应用到微服务架构的过渡阶段，可以使用这种设计模式
###### 异步消息传递微服务设计模式
问：异步消息传递微服务设计模式
- 答：基于微服务的架构可能会选择使用消息队列代替REST请求/响应
###### 微服务架构对于部署的要求
问：微服务架构对于部署的要求
- 答：部署速率，Amazon与NetFlix都有千个服务，每个服务都有持续部署的要求，Amazon的服务每秒都会部署一次； 
部署自动化，一切都要自动化，IaaS与PaaS解决I层与P层自动化部署，微服务有自动部署与运维工具，并实现Auto-Scaling； 
部署提供基础机制，为实现分布式部署要求，部署机制一般都有资源池化、服务的生命周期来看，部署服务与服务注册是一体的；
###### 微服务部署的粒度
问：微服务部署的粒度
- 答：VM: 部署系统管理的VM的生命周期，如当前AC的iDeploy部署，把AC部署拆分为每个VM的安装、配置与启动；这种方式粒度粗，支撑不了微服务的部署(除非一个服务占用一个VM); 
App: 管理应用的生命周期及部署形态，生命周期分为部署、配置、启动、升级等，部署形态有主备、LB、Daemon等； 
Container: 相比于APP，容器有更好的隔离性和移植性； 
微服务：一般的微服务要么是APP，要么是Container，但AC就不是。受限于ONOS架构，我们的服务是一组feature；
###### MS部署的解决方案
问：MS部署的解决方案
- 答：TOSCA: 云应用拓扑标准，一种描述云化部署的DSL，我司主推一个标准，PaaS的部署系统和MANO用的都是TOSCA； 
Kubernetes:Google开源的容器管理系统，提出了Pod/Service/Labels等概念，以ETCD为中心，PaaS基于K8S开发出了我司的云化部署平台； 
Mesosphere:DCOS，数据中心操作系统，基于mesos实现资源池化，有自身的编排工具；分布式LAB基于DCOS的思想做出了一套部署与集群管理系统(HASEN)；
###### 微服务的划分
问：微服务的划分
- 答：一般使用DDD(Domain Drive Design)的思想与方法对微服务进行划分，这种方法有点类似于数据库ER图的划分，不断分解数据，保证关系型数据库符合原子性、冗余性的范式要求。
###### 微服务分布式一致性
问：微服务分布式一致性
- 答：可以通过分布式事务来保证微服务数据一致性，可以用rocketmq来实现分布式事务，也可以使用两阶段/三阶段提交的方式来实现分布式事务
- 答：全局的分布式事务；事件驱动；
###### 微服务数据隔离问题
问：微服务数据隔离问题
- 答：数据表级隔离；数据表之间独立，没有外键关系； 
数据库级隔离；不同服务有不同的数据库； 
DBMS级隔离；不同服务有不同的数据库管理系统；
###### COMB支持哪些常见的协议
问：COMB支持哪些常见的协议
- 答：支持最好的是REST（HTTP/HTTP2+JSON），还支持基于TCP+Protocol Buffers的协议
###### 如何集成Spring Boot和ActiveMQ？
问：如何集成Spring Boot和ActiveMQ？
- 答：对于集成Spring Boot和ActiveMQ，我们使用spring-boot-starter-activemq依赖关系。 它只需要很少的配置，并且不需要样板代码
###### springboot常用的starter有哪些
问：springboot常用的starter有哪些
- 答：spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持 spring-boot-starter-data-jpa 数据库支持 spring-boot-starter-data-redis redis数据库支持 spring-boot-starter-data-solr solr支持 mybatis-spring-boot-starter 第三方的mybatis集成starter
###### springboot读取配置文件的方式
问：springboot读取配置文件的方式
- 答：方式一：通过Environment中的getProperty(key)获取配置信息 方式二：通过@Value("${key}")取值 方式三：在配置文件中通过${key}引用配置信息
- 答：springboot默认读取配置文件为application.properties或者是application.yml
###### springboot集成mybatis的过程
问：springboot集成mybatis的过程
- 答：添加mybatis的starter maven依赖
###### 如何重新加载Spring Boot上的更改，而无需重新启动服务器？
问：如何重新加载Spring Boot上的更改，而无需重新启动服务器？
- 答：可以使用DEV工具来实现 可以重新加载Spring Boot上的更改，而无需重新启动服务器
###### 如何在Spring Boot中禁用Actuator端点安全性？
问：如何在Spring Boot中禁用Actuator端点安全性？
- 答：可以使用management.security.enabled = false 来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。
###### 如何在 Spring Boot 启动的时候运行一些特定的代码？
问：如何在 Spring Boot 启动的时候运行一些特定的代码？
- 答：可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法
###### Spring Boot 如何定义多套不同环境配置？
问：Spring Boot 如何定义多套不同环境配置？
- 答：applcation.properties 
application-dev.properties 
application-test.properties 
application-prod.properties
###### 保护 Spring Boot 应用有哪些方法？
问：保护 Spring Boot 应用有哪些方法？
- 答：
```
从两个方面来说吧。第一个是编码安全，第二个是网络设备安全。 
编码安全，也需要根据情况进行分析，如果非web项目： 
  如果有数据库，注意字符编码问题，防止XSS攻击，如果是用Mybatis，建议多使用#做参数的获取
注意异常的处理，不要把系统信息暴露在外面
注意接口权限的校验，永远不要相信用户传入的数据 
如果是web项目，除了上面的还应该注意下面的问题： 
  ①需要开启HTTPS
②检查pom中依赖的软件没有已知的漏洞，比如fastjson暴露的0day漏洞，apache zooker 1.0.0~3.4.13存在的ACL越权漏洞
③启动CSRF保护
④注意XSS攻击 
网络设备安全，这块儿就是说你部署的服务硬件是安全的，编码再怎么安全，如果服务器不安全，反编译啥都能拿到： 
  开启防火墙
开启白名单，如果有
开启黑名单限制访问
服务器内核漏洞不容忽视
```
- 答：在生产中使用HTTPS； 使用Snyk检查你的依赖关系； 升级到最新版本； 启用CSRF保护； 使用内容安全策略防止XSS攻击
###### Docker概念之镜像
问：Docker概念之镜像
- 答：Docker镜像类似于我们安装系统的镜像，iso
- 答：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板
###### Docker概念之容器
问：Docker概念之容器
- 答：类似于一个轻量的虚拟机
- 答：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境，以及运行在其中的应用程序
###### Docker概念之仓库
问：Docker概念之仓库
- 答：仓库是存放镜像的位置，也就是说，仓库是用来，存放docker 镜像
- 答：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方
###### Docker中镜像的基本操作
问：Docker中镜像的基本操作
- 答：docker ps -a --列出所有容器 docker images -- 列出所有镜像 docker start id -- 开启容器 docker stop id -- 关闭容器 docker rm id -- 删除容器 docker rmi id -- 删除镜像 docker exec -- 执行，进入容器内 docker run -- 运行镜像，作为容器
- 答：
```
cat /etc/group | grep docker
# 安装Docker后,docker组已经创建好了,上面的命令输出如下:
docker:x:999:
# 将当前用户添加到 docker 组
sudo gpasswd -a ${USER} docker
# 重新登录或者用以下命令切换到docker组
newgrp - docker
# 重启docker服务
sudo service docker restart
# 不加sudo直接执行docker命令检查效果
docker images
# 安装Docker的时候拉取过hello-world镜像,所以输出如下:
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              4ab4c602aa5e        8 weeks ago         1.84kB
# 删除none的镜像:
#!/bin/bash
docker ps -a | grep "Exited" | awk '{print $1}' | xargs docker stop
docker ps -a | grep "Exited" | awk '{print $1}' | xargs docker rm
docker images | grep none | awk '{print $3}' | xargs docker rmi
# 删除镜像
docker rmi -f image_ID
```
###### 利用镜像启动一个容器后进行修改
问：利用镜像启动一个容器后进行修改
- 答：有点模糊，是要修改什么，要修改其中容器内配置么，需要进入到容器中，同linux操作，修改即可，要修改容器基本配置，可以直接停掉，删除，重新创建
- 答：
```
[root@72f1a8a0e394 /]#    # 这里命令行形式变了，表示已经进入了一个新环境

[root@72f1a8a0e394 /]# git --version    # 此时的容器中没有git

bash: git: command not found

[root@72f1a8a0e394 /]# yum install git    # 利用yum安装git

......

[root@72f1a8a0e394 /]# git --version   # 此时的容器中已经装有git了

git version 1.8.3.1
```
###### 利用Dockerfile创建镜像
问：利用Dockerfile创建镜像
- 答：dockerfile就类似linux的shell脚本，实现通过处理命令，创建镜像
- 答：
```
FROM centos:latest
 
# 构建者的基本信息
MAINTAINER panjinqan
 
# 在build这个镜像时执行的操作
RUN yum update
RUN yum install -y git
 
# 拷贝本地文件到镜像中
COPY ./* /usr/share/gitdir/
```
###### docker run的参数命令
问：docker run的参数命令
- 答：docker run ：创建一个新的容器并运行一个命令
- 答：-i, --interactive=false， 打开STDIN，用于控制台交互 
-t, --tty=false， 分配tty设备，该可以支持终端登录，默认为false 
-u, --user=""， 指定容器的用户 
-a, --attach=[]， 登录容器（必须是以docker run -d启动的容器） 
-w, --workdir=""， 指定容器的工作目录 
-c, --cpu-shares=0， 设置容器CPU权重，在CPU共享场景使用 
-e, --env=[]， 指定环境变量，容器中可以使用该环境变量 
-m, --memory=""， 指定容器的内存上限 
-P, --publish-all=false， 指定容器暴露的端口 
-p, --publish=[]， 指定容器暴露的端口 
-h, --hostname=""， 指定容器的主机名 
-v, --volume=[]， 给容器挂载存储卷，挂载到容器的某个目录 
--volumes-from=[]， 给容器挂载其他容器上的卷，挂载到容器的某个目录 
--cap-add=[]， 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities 
--cap-drop=[]， 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities 
--cidfile=""， 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法 
--cpuset=""， 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU 
--device=[]， 添加主机设备给容器，相当于设备直通 
--dns=[]， 指定容器的dns服务器 
--dns-search=[]， 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件 
--entrypoint=""， 覆盖image的入口点 
--env-file=[]， 指定环境变量文件，文件格式为每行一个环境变量 
--expose=[]， 指定容器暴露的端口，即修改镜像的暴露端口 
--link=[]， 指定容器间的关联，使用其他容器的IP、env等信息 
--lxc-conf=[]， 指定容器的配置文件，只有在指定--exec-driver=lxc时使用 
--name=""， 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字 
--net="bridge"， 容器网络设置:bridge 使用docker daemon指定的网桥 
host //容器使用主机的网络 
container:NAME_or_ID >//使用其他容器的网路，共享IP和PORT等网络资源 
none 容器使用自己的网络（类似--net=bridge），但是不进行配置 
--privileged=false， 指定容器是否为特权容器，特权容器拥有所有的capabilities 
--restart="no"， 指定容器停止后的重启策略:no：容器退出时不重启 
on-failure：容器故障退出（返回值非零）时重启 
always：容器退出时总是重启 
--rm=false， 指定容器停止后自动删除容器(不支持以docker run -d启动的容器) 
--sig-proxy=true， 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理
- 答：-i, --interactive=false， 打开STDIN，用于控制台交互

-t, --tty=false， 分配tty设备，该可以支持终端登录，默认为false

-u, --user=""， 指定容器的用户

-a, --attach=[]， 登录容器（必须是以docker run -d启动的容器）

-w, --workdir=""， 指定容器的工作目录

-c, --cpu-shares=0， 设置容器CPU权重，在CPU共享场景使用

-e, --env=[]， 指定环境变量，容器中可以使用该环境变量

-m, --memory=""， 指定容器的内存上限

-P, --publish-all=false， 指定容器暴露的端口

-p, --publish=[]， 指定容器暴露的端口

-h, --hostname=""， 指定容器的主机名

-v, --volume=[]， 给容器挂载存储卷，挂载到容器的某个目录

--volumes-from=[]， 给容器挂载其他容器上的卷，挂载到容器的某个目录

--cap-add=[]， 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities

--cap-drop=[]， 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities

--cidfile=""， 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法

--cpuset=""， 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU

--device=[]， 添加主机设备给容器，相当于设备直通

--dns=[]， 指定容器的dns服务器

--dns-search=[]， 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件

--entrypoint=""， 覆盖image的入口点

--env-file=[]， 指定环境变量文件，文件格式为每行一个环境变量

--expose=[]， 指定容器暴露的端口，即修改镜像的暴露端口

--link=[]， 指定容器间的关联，使用其他容器的IP、env等信息

--lxc-conf=[]， 指定容器的配置文件，只有在指定--exec-driver=lxc时使用

--name=""， 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字

--net="bridge"， 容器网络设置:bridge 使用docker daemon指定的网桥

host //容器使用主机的网络

container:NAME_or_ID >//使用其他容器的网路，共享IP和PORT等网络资源

none 容器使用自己的网络（类似--net=bridge），但是不进行配置

--privileged=false， 指定容器是否为特权容器，特权容器拥有所有的capabilities

--restart="no"， 指定容器停止后的重启策略:no：容器退出时不重启

on-failure：容器故障退出（返回值非零）时重启

always：容器退出时总是重启

--rm=false， 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)

--sig-proxy=true， 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理
###### Docker中仓库的基本操作
问：Docker中仓库的基本操作
- 答：可以对仓库，pull 下载镜像， push 推本地镜像到镜像仓库
- 答：
```
[root@xxx ~]# docker push xxx/centos:git    # 失败

The push refers to a repository [docker.io/xxx/centos]

unauthorized: authentication required
```
###### 配置docker仓库
问：配置docker仓库
- 答：仓库（Repository）是集中存放镜像的地方。以下介绍一下 Docker Hub。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。 Docker Hub 
目前 Docker 官方维护了一个公共仓库 Docker Hub。 
大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。 注册 
在 https://hub.docker.com 免费注册一个 Docker 账号。 登录和退出 
登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。 
$ docker login
- 答：使用公共仓库，可以使用阿里云、网易国内仓库，也可以使用docker hub 官方仓库，国内库也是完成对官方库的同步。使用私有库，可以自己创建
- 答：        "auths": {

                "panjinqan@docker.pjq.cn": {

                        "auth": "emhlbmd3ZW55b25nOlp3eTE1OTU5NA=="

                },

                "https://index.docker.io/v1/": {

                        "auth": "emhlbmd3ZW55b25nOnp3eTE1OTU5NDk2NjI4"

                }

        },

        "HttpHeaders": {

                "User-Agent": "Docker-Client/18.09.6 (linux)"

        }

}
###### 利用Docker创建一个用于Flask开发的Python环境
问：利用Docker创建一个用于Flask开发的Python环境
- 答：写个dockerfile
- 答：
```
[root@xxx ~]# docker run -it centos:latest /bin/bash 
此时进入容器，安装Python3、Git、Flask及其依赖包等，安装完成后exit退出 
[root@xxx ~]# docker commit -m "Flask" -a "panjinqan" container_id panjinqan/flask:v1 
[root@xxx ~]# docker push panjinqan/flask:v1
```
- 答：
```
[root@xxx ~]# docker run -it centos:latest /bin/bash

# 此时进入容器，安装Python3、Git、Flask及其依赖包等，安装完成后exit退出

[root@xxx ~]# docker commit -m "Flask" -a "panjinqan" container_id panjinqan/flask:v1

[root@xxx ~]# docker push panjinqan/flask:v1
```
###### 容器备份之导出镜像到文件
问：容器备份之导出镜像到文件
- 答：docker save -o 本地路径 镜像名称
- 答：docker save -o /home/bdqn/leon/tomcat.tar tomcat
###### 容器备份之从文件导入成镜像
问：容器备份之从文件导入成镜像
- 答：进入镜像所在目录 docker load --input 镜像
- 答：docker load --input tomcat.tar
###### 容器备份之可以通过docker --help 查看
问：容器备份之可以通过docker --help 查看
- 答：docker --help查看所用命令，查看注释 使用export 导出， import 导入
- 答：docker export 
docker import
###### 容器备份之启动成容器测试
问：容器备份之启动成容器测试
- 答：docker run -it 参数
- 答：docker run -d -it -p 8888:8080 --name dm-tomcat tomcat
###### 搭建私服仓库
问：搭建私服仓库
- 答：首先搞定自己私服仓库服务器，然后，可以进行创建，通过docker run -d -p 5000:5000 --restart=always --name registry-dm registry
- 答：docker run -d -p 5000:5000 --restart=always --name registry-dm registry
###### 查看仓库
问：查看仓库
- 答：基本上通过docker，默认生成端口5000，访问即可
- 答：IP：5000/v2/_catalog
###### 提交镜像到仓库
问：提交镜像到仓库
- 答：docker tag 标签 镜像 docker push 镜像
- 答：docker tag tomcat 192.168.9.107:5000/tomcat docker push 192.168.9.107:5000/tomcat
###### 从仓库拉取镜像
问：从仓库拉取镜像
- 答：docker pull 镜像
- 答：docker pull IP:5000/tomcat
###### 外部挂载
问：外部挂载
- 答：docker volume ls docker volume inspect 镜像
- 答：docker volume ls docker volume inspect mysql
###### JVM分区有哪些
问：JVM分区有哪些
- 答：jvm是java 虚拟机，包括几个部分组成，大致上，堆、栈、计数器、方法区等
- 答：方法区、虚拟机栈、本地方法栈、堆、程序计数器
###### GC 的两种判定方法
问：GC 的两种判定方法
- 答：引用计数法 通过计数，判断是否有人在引用，当数值不在，就代表要回收 引用链法 基本相同道理
- 答：引用计数法、引用链法
###### SafePoint 是什么
问：SafePoint 是什么
- 答：垃圾回收处理，需要有个节点，safepoint
- 答：GC 的时候必须要等到 Java 线程都进入到 safepoint 的时候 VMThread 才能开始执行 GC
###### GC 的三种收集方法及用途
问：GC 的三种收集方法及用途
- 答：标记清除、 用在解决，对象的引用上，如果不引用，就要标记清楚 复制算法、 复制对象 标记整理
- 答：标记清除、复制算法、标记整理
###### GC 收集器有哪些？CMS 收集器与 G1 收集器的特点
问：GC 收集器有哪些？CMS 收集器与 G1 收集器的特点
- 答：并行收集器：串行收集器使用一个单独的线程进行收集，GC 时服务有停顿时间 
串行收集器：次要回收中使用多线程来执行
###### Minor GC 与 Full GC 分别在什么时候发生？
问：Minor GC 与 Full GC 分别在什么时候发生？
- 答：新生代内存回收Minor GC,老年代内存回收Full GC
- 答：新生代内存不够用时候发生 MGC 也叫 YGC，JVM 内存不够的时候发生 FGC
###### 几种常用的内存调试工具：jmap、jstack、jconsole、jhat
问：几种常用的内存调试工具：jmap、jstack、jconsole、jhat
- 答：jstack 可以看当前栈的情况，jmap 查看内存，jhat 进行 dump 堆的信息mat
###### 类加载的几个过程
问：类加载的几个过程
- 答：类在虚拟机中加载流程：加载、验证语法正确是否，准备使用，调用解析，初始化，使用，回收处理
- 答：加载、验证、准备、解析、初始化、使用、卸载
###### GC 对象的判定方法
问：GC 对象的判定方法
- 答：引用计数法、可达性算法、虚拟机栈中引用的对象、方法区类静态属性引用的对象、方法区常量池引用的对象、本地方法栈 JNI 引用的对象
###### java 垃圾回收机制?
问：java 垃圾回收机制?
- 答：在JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行
###### java 类加载过程?
问：java 类加载过程?
- 答：加载、验证、准备、解析、初始化
###### java 类加载机制?
问：java 类加载机制?
- 答：虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 java 类型。
###### 类加载器双亲委派模型机制？
问：类加载器双亲委派模型机制？
- 答：当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。
###### 什么是类加载器，类加载器有哪些?
问：什么是类加载器，类加载器有哪些?
- 答：实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。 
启动类加载器、 扩展类加载器、 系统类加载器、 用户自定义类加载器
###### java 内存分配与回收策率以及 Minor GC 和Major GC
问：java 内存分配与回收策率以及 Minor GC 和Major GC
- 答：当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC.Minor Gc 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代 GC的时候不会触发 Minor GC,但是通过配置，可以在 Full GC 之前进行一次 MinorGC 这样可以加快老年代的回收速度。
###### JVM内存模型，GC机制和原理
问：JVM内存模型，GC机制和原理
- 答：JVM = 类加载器+ 执行引擎 + 运行时数据区域
###### JVM里的有几种classloader，为什么会有多种？
问：JVM里的有几种classloader，为什么会有多种？
- 答：BootStrap ClassLoader，负责加载<JAVA_HOME>/lib或被-Xbootclasspath指定路径下的类库，开发者不可以直接使用 
Extension ClassLoader,负责加载<JAVA_HOME>/lib/ext或被java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用 
App ClassLoader，这个类加载器是ClassLoader.getSystemClassLoader()的返回值，负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序没有自定义过类加载器，那么系统默认使用这个类加载器。
###### 什么情况下我们需要破坏双亲委派模型？
问：什么情况下我们需要破坏双亲委派模型？
- 答：OSGI模块化热部署的关键是它自定义的类加载器。每一个模块都有一个自己的类加载器，当需要更换一个 Bundle(包) 时，Bundle连同类加载器一同替换实现代码热部署。
###### 服务启动或执行过程中出现ClassNotFoundException，NoClassDefFound
问：服务启动或执行过程中出现ClassNotFoundException，NoClassDefFoundError
- 答：找不到class对象
- 答：gradle dependencies > /tmp/dpe.text 或者 mvn dependency:tree -dverbose > /tmp/dpe.text 查看依赖数，exclude掉冲突的依赖包。 利用arthas sc命令，查看线上具体执行的方法是从哪个jar包加载的，然后exclude掉多余的依赖, 参考: https://alibaba.github.io/arthas/sc.html。 shaded plugin，package relocation改变包名，
###### java.lang.OutOfMemoryError:Java heap space
问：java.lang.OutOfMemoryError:Java heap space
- 答：原因就是应用程序需要的堆空间是XXL号的，但是JVM提供的却是S号。解决方法也很简单， 通过设置-Xmx参数提供更大的堆空间即可。
###### java.lang.OutOfMemoryError:GC overhead limit excee
问：java.lang.OutOfMemoryError:GC overhead limit exceeded
- 答：内存溢出了。看下你那个GC是什么，超出了
- 答：示意应用程序在垃圾收集上花费了太多时间但却没有什么卵用。默认超过98%的时间用来做GC却回收了不到2%的内存时将会抛出此错误。 
可以通过-XX:-UserGCOverheadLimit参数关闭这个功能
###### java.lang.OutOfMemoryError:Permgen space
问：java.lang.OutOfMemoryError:Permgen space
- 答：PermGen的大小取决于被加载类的数量以及类的大小，可以 通过-XX:MaxPermSize=5m或者Metaspace（JDK1.8）来配置
###### java.lang.OutOfMemoryError:Unable to create new na
问：java.lang.OutOfMemoryError:Unable to create new native thread
- 答：Java应用程序已达到其可以启动线程数量的极限了, 当JVM向OS请求创建一个新线程时，而OS却无法创建新的native线程时就会抛出Unable to create new native thread错误.
###### java.lang.OutOfMemoryError:Out of swap space
问：java.lang.OutOfMemoryError:Out of swap space
- 答：交换空间不足
- 答：操作系统配置的交换空间不足。 系统上的另一个进程消耗所有内存资源
###### java.lang.StackOverflowError
问：java.lang.StackOverflowError
- 答：栈满，由于程序发生的
- 答：线程栈满，从循环那里找问题。
###### Fatal: Stack size too small
问：Fatal: Stack size too small
- 答：栈内存不够，通过运行设计参数调优
- 答：涉及到的参数：-Xss2m 调大吧
###### 碰到网络问题，无法 pull 镜像，命令行指定 http_proxy 无效？
问：碰到网络问题，无法 pull 镜像，命令行指定 http_proxy 无效？
- 答：如果因为网络访问出现问题，这个参数，需要设置仔细，proxy需要好几个参数，根据不通协议
- 答：碰到网络问题，无法 pull 镜像，命令行指定 http_proxy 无效？
###### 容器退出后，通过 docker container ls 命令查看不到，数据会丢失么？
问：容器退出后，通过 docker container ls 命令查看不到，数据会丢失么？
- 答：容器退出，等同于虚拟机关机，所以是不会有数据丢失的，只有当docker rm之后，才会删掉，所以需要挂载数据到服务器
- 答：容器退出后会处于终止（exited）状态，此时可以通过 docker container ls -a 查看。其中的数据也不会丢失，还可以通过 docker start 命令来启动它。只有删除掉容器才会清除所有数据
###### 如何停止所有正在运行的容器？
问：如何停止所有正在运行的容器？
- 答：通过命令 docker stop $(docker container ls -q) 命令。
- 答：docker stop $(docker ps -a -q)
- 答：可以使用 docker stop $(docker container ls -q) 命令。
###### 如何给容器指定一个固定 IP 地址，而不是每次重启容器 IP 地址都会变？
问：如何给容器指定一个固定 IP 地址，而不是每次重启容器 IP 地址都会变？
- 答：通过在运行时，指定参数，设置ip docker run --network=my-net --ip=172.25.3.3 -itd --name=my-container busybox
- 答：$ docker run --network=my-net --ip=172.25.3.3 -itd --name=my-container busybox
###### 什么是微服务中的反应性扩展？
问：什么是微服务中的反应性扩展？
- 答：一种设计方法，通过调用多个服务来收集结果，然后编译组合响应。这些调用可以是同步或异步，阻塞或非阻塞
###### 可以用微服务创建状态机吗？
问：可以用微服务创建状态机吗？
- 答：可以为特定的微服务指定不同的状态和事件，因为数据库的每个微服务都是一个可独立部署的程序单元
###### 架构师在微服务架构中的角色是什么？
问：架构师在微服务架构中的角色是什么？
- 答：决定整个软件系统的布局。 帮助确定组件的分区。 为开发微服务的团队提供某些工具和技术的建议。 提供技术治理，以便技术开发团队遵循微服务原则。
###### 什么是持续监测？
问：什么是持续监测？
- 答：从浏览器内前端性能指标，到应用程序性能，再到主机虚拟化基础架构进行检测。
###### 什么是持续集成（CI）？
问：什么是持续集成（CI）？
- 答：每次团队成员提交版本控制更改时自动构建和测试代码的过程
###### 什么是Canary Releasing？
问：什么是Canary Releasing？
- 答：一种降低在生产中引入新软件版本的风险的技术，通过将变更缓慢地推广到一小部分用户，然后将其发布到整个基础架构
###### 使用Docker的目的是什么？
问：使用Docker的目的是什么？
- 答：docker 本身解决的问题是一个单点部署的问题。但是只有docker和调度器结合之后才真正展示出效率。单点故障的自动恢复，从此不再依赖外围的脚本
- 答：可用于托管任何应用程序的容器环境
###### 对Mike Cohn的测试金字塔了解多少？
问：对Mike Cohn的测试金字塔了解多少？
- 答：第一层的测试数量应该最高。在服务层，测试次数应小于单元测试级别，但应大于端到端级别。
###### Mock或Stub有什么区别？
问：Mock或Stub有什么区别？
- 答：一个有助于运行测试的虚拟对象。一个是虚拟对象。 一个对象的行为取决于set属性。 另一个可以测试对象的行为。
###### 如何在测试中消除非决定论？
问：如何在测试中消除非决定论？
- 答：隔离 异步 远程服务 隔离 时间 资源泄漏
###### 如何进行跨功能测试？
问：如何进行跨功能测试？
- 答：对非功能性需求的验证。性能测试，也是很有必要的。你可以借助市面上的压测工具，去评估性能。
- 答：对非功能性需求的验证，那些无法像普通功能那样实现的需求。
###### 对微服务架构中的语义监控有何了解？
问：对微服务架构中的语义监控有何了解？
- 答：将自动化测试与监控应用程序相结合，以检测业务失败因素。
###### Web，RESTful API在微服务中的作用是什么？
问：Web，RESTful API在微服务中的作用是什么？
- 答：所有服务应该能够彼此交互以构建业务功能，要实现这一点，每个微服务必须具有接口。这使得Web API成为微服务的一个非常重要的推动者。RESTful API基于Web的开放网络原则，为构建微服务架构的各个组件之间的接口提供了最合理的模型。
###### 什么是消费者驱动的合同（CDC）？
问：什么是消费者驱动的合同（CDC）？
- 答：处理微服务时，有一个特定的提供者构建它，并且有一个或多个使用微服务的消费者。
###### 什么是微服务架构中的DRY？
问：什么是微服务架构中的DRY？
- 答：不要重复自己，基本上促进了重用代码的概念
###### Container在微服务中的用途是什么？
问：Container在微服务中的用途是什么？
- 答：可以将微服务封装在容器映像及其依赖项中，然后使用它来滚动按需实例的微服务，而无需任何额外的工作
###### 什么是端到端微服务测试？
问：什么是端到端微服务测试？
- 答：验证工作流中的每个流程都正常运行，确保系统作为一个整体协同工作并满足所有要求。
###### 合同测试主要做什么？
问：合同测试主要做什么？
- 答：在外部服务边界进行的测试，用于验证其是否符合消费服务预期的合同。
###### 什么是康威定律？
问：什么是康威定律？
- 答：为了使软件模块起作用，整个团队应该进行良好的沟通，系统的结构反映了产生它的组织的社会边界
###### 什么是OAuth？
问：什么是OAuth？
- 答：开放授权协议，允许通过在HTTP服务上启用客户端应用程序来访问资源所有者的资源
###### PACT在微服务架构中的用途？
问：PACT在微服务架构中的用途？
- 答：允许测试服务提供者和消费者之间的交互，与合同隔离，从而提高微服务集成的可靠性。
###### 什么是客户证书？
问：什么是客户证书？
- 答：用于向远程服务器发出经过身份验证的请求的一种数字证书
###### 双因素身份验证的凭据类型有哪些？
问：双因素身份验证的凭据类型有哪些？
- 答：PIN ATM
###### 什么是双因素身份验证？
问：什么是双因素身份验证？
- 答：帐户登录过程启用第二级身份验证
###### 什么是有界上下文？
问：什么是有界上下文？
- 答：过将大型模型划分为不同的有界上下文并明确其相互关系来处理大型模型
###### 什么是Idempotence以及它在哪里使用？
问：什么是Idempotence以及它在哪里使用？
- 答：在远程服务或数据源中使用 Idempotence，这样当它多次接收指令时，它只处理指令一次
###### 怎么理解Distributed Transaction？
问：怎么理解Distributed Transaction？
- 答：单个事件导致两个或多个不能以原子方式提交的单独数据源的突变的任何情况
###### 什么是不同类型的微服务测试？
问：什么是不同类型的微服务测试？
- 答：底层，面向技术的测试。 中间层面，压力测试和可用性测试之类的探索性测试。 顶层，验收测试数量很少
###### 休息和微服务的要点有哪些？
问：休息和微服务的要点有哪些？
- 答：休息 可以通过多种方式实现微服务，但REST over HTTP是实现微服务的一种方式。REST还可用于其他应用程序，如Web应用程序，API设计和MVC应用程序，以提供业务数据。 
微服务 微服务是一种体系结构，其中系统的所有组件都被放入单独的组件中，这些组件可以单独构建，部署和扩展。微服务的某些原则和最佳实践有助于构建弹性应用程序。
###### 在Spring MVC应用程序中使用WebMvcTest注释有什么用处？
问：在Spring MVC应用程序中使用WebMvcTest注释有什么用处？
- 答：用于单元测试Spring MVC应用程序，执行此单元测试时，不会启动所有其他控制器和映射。
###### Spring Cloud解决了哪些问题？
问：Spring Cloud解决了哪些问题？
- 答：包括网络问题，延迟开销，带宽问题，安全问题，冗余问题等
###### 什么是Spring Cloud？
问：什么是Spring Cloud？
- 答：快速构建分布式系统的工具
###### 什么是Spring引导的执行器？
问：什么是Spring引导的执行器？
- 答：以访问生产环境中运行应用程序的当前状态。在执行器的帮助下，可以检查各种指标并监控您的应用程序
###### 什么是Spring Boot？
问：什么是Spring Boot？
- 答：spring boot可以避免所有样板代码和配置
###### 什么是REST / RESTful以及它的用途是什么？
问：什么是REST / RESTful以及它的用途是什么？
- 答：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作.简单来说就是通过URL就可以定位到资源，然后对资源进行操作，不需要您在去通过服务器或者进行后台进行资源的更改操作。
- 答：RESTful服务是一种帮助计算机系统通过Internet进行通信的架构风格，可以使用或不使用RESTful API实现，但使用RESTful API构建松散耦合的微服务总是更容易。
###### 什么是耦合？
问：什么是耦合？
- 答：组件之间依赖关系强度的度量
###### 什么是凝聚力？
问：什么是凝聚力？
- 答：模块内部元素所属的程度
###### 什么是无所不在的语言？
问：什么是无所不在的语言？
- 答：将所有团队成员放在同一页面上，并以机器可以理解的方式进行翻译。
###### 为什么需要域驱动设计（DDD）？
问：为什么需要域驱动设计（DDD）？
- 答：从DDD落地上说，因为DDD更偏向于业务，更希望从业务的角度去看，所以，DDD能更好地和开发者所掌握的一些最基本设计原则匹配起来。
###### 什么是领域驱动设计？
问：什么是领域驱动设计？
- 答：是一种应对业务或事件复杂性的思考方式。
###### 微服务有什么特点？
问：微服务有什么特点？
- 答：足够内聚，足够小，代码容易理解、开发效率提高
###### SOA和微服务架构之间的主要区别是什么？
问：SOA和微服务架构之间的主要区别是什么？
- 答：<img src="https://ucc.alicdn.com/pic/developer-ecology/f1689a2c1be44a109733a47f8547e822.png" alt="image.png" />
###### 在使用微服务架构时，哪些觉得比较困难？
问：在使用微服务架构时，哪些觉得比较困难？
- 答：难以自动化，因为有许多较小的组件，对于每个组件，我们必须遵循Build，Deploy和Monitor的各个阶段。将大量组件维护在一起变得难以部署，维护，监控和识别问题。
###### 单片，SOA和微服务架构有什么区别？
问：单片，SOA和微服务架构有什么区别？
- 答：单片架构类似于大容器，其中应用程序的所有软件组件组装在一起并紧密封装。一个面向服务的架构是一种相互通信服务的集合。通信可以涉及简单的数据传递，也可以涉及两个或多个协调某些活动的服务。 微服务架构是一种架构风格，它将应用程序构建为以业务域为模型的小型自治服务集合。
###### 微服务架构的优缺点是什么？
问：微服务架构的优缺点是什么？
- 答：优点： 
1.每个微服务都很小，这样能聚焦一个指定的业务功能或业务需求。 
2.微服务能够被小团队单独开发。 
3.微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。 
4.微服务能使用不同的语言开发。 
5.微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。 
6.微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合。 
缺点 
1.运维要求较高 
2.分布式的复杂性 
3.接口调整成本高
###### 微服务架构如何运作？
问：微服务架构如何运作？
- 答：客户端 – 来自不同设备的不同用户发送请求。 身份提供商 – 验证用户或客户身份并颁发安全令牌。 API网关 – 处理客户端请求。 静态内容 – 容纳系统的所有内容。 管理 – 在节点上平衡服务并识别故障。 服务发现 – 查找微服务之间通信路径的指南。 内容交付网络 – 代理服务器及其数据中心的分布式网络。 远程服务 – 启用驻留在IT设备网络上的远程访问信息。
###### 微服务之间是如何独立通讯的？
问：微服务之间是如何独立通讯的？
- 答：通过使用HTTP/REST，数据格式使用JSON 或 Protobuf(Binary protocol)，通讯协议是自由的。
###### 哪个公司或产品使用微服务架构?
问：哪个公司或产品使用微服务架构?
- 答：大部分大型网站系统如Twitter, Netflix, Amazon 和 eBay都已经从传统整体型架构monolithic architecture迁移到微服务架构
###### 为什么现在每个人都在谈论微服务？
问：为什么现在每个人都在谈论微服务？
- 答：随着RESTful web服务和JSON数据交换格式流行，简单快速建立一个可连接的服务已经越来越方便了。
###### 微服务适合哪种情况?
问：微服务适合哪种情况?
- 答：需要支持桌面 web 移动 智能电视 可穿戴时都是可以的，甚至将来你可能不知道但需要支持的某种环境。
###### Java 13 处于创新者阶段，Java 11 处于早期采用者阶段，Java 8 处于晚期大众阶段
问：Java 13 处于创新者阶段，Java 11 处于早期采用者阶段，Java 8 处于晚期大众阶段
- 答：Java 11 将是未来 Java 用户的最可能选项； 
如果一个公司对大堆栈 GC 能力、延迟 SLA 等方面要求没有那么高，就没有足够动力去做相关升级，也未必有技术力量解决版本评估、兼容性修正等现实问题； 
Java 新版本升级在中国的宣传还是不够，如果很多企业看不到技术升级的红利，势必也影响升级的积极性。
###### OpenJDK 处于创新者阶段
问：OpenJDK 处于创新者阶段
- 答：虽然国内很多头部厂商都在定制 OpenJDK，但是目前定制 OpenJDK 被采用范围还都有限，主体使用还是 Oracle JDK（根据《JVM 生态系统报告 2018》调查显示，70% 的开发者选择使用 Oracle JDK，21% 的开发者选择使用 OpenJDK）； 
厂商是否转向 OpenJDK，还有一个重要考量因素就是看他们是否愿意付费使用 OracleJDK，如果不是的话，未来 OpenJDK 可能会逐渐取代 Oracle JDK，目前国内头部厂商都在 OpenJDK 上有所动作；（对于参与 OpenJDK 的国内头部厂商来说，可能他们的看法更加积极，他们把 OpenJDK 定义在早期大众阶段） 
大家在公有云、私有云等方面的竞争格局，深刻影响着在 OpenJDK 上的竞争格局； 
OpenJDK 很可能被认为是一种退⽽求其次的选择。
###### 非 Hotspot JDK 生产实践——Graal VM、IBM OpenJ9 处于早期采用者阶段
问：非 Hotspot JDK 生产实践——Graal VM、IBM OpenJ9 处于早期采用者阶段
- 答：Graal VM 目前还尚不可知其兼容性情况以及明确的商业化条款； 
Graal VM 的部分技术，例如，基于 Java 语言开发的 JIT 引擎，可能会成为未来 OpenJDK 的基础技术； 
在国内，怀疑 Graal VM、IBM OpenJ9 进入普遍生产实践的可能性会比较低。
###### Lambda /Stream 处于晚期大众阶段、Vector API 处于创新者阶段
问：Lambda /Stream 处于晚期大众阶段、Vector API 处于创新者阶段
- 答：Lambda 语法以及 Stream API 也在开发人员的⽇常⼯作中⼴泛地运用，并且没有看到语法回退的趋势； 
Vector API 等前沿特性，有能力的公司有限，抑制了对其有需求的公司或者场景。
###### Kotlin 处于早期大众阶段，Scala 和 Groovy 处于晚期大众阶段
问：Kotlin 处于早期大众阶段，Scala 和 Groovy 处于晚期大众阶段
- 答：Groovy 已快成为明日黄花，往昔的光芒逐渐地被后起之秀 Kotlin 替代； 
Scala 在适合的领域做王者就够了，主流不主流没那么重要； 
Kotlin 被谷歌强推，谷歌支持的基本上都成功了，但是对 Kotlin 未来发展空间还是表示怀疑； 
网上很多文章都在鼓吹，说 Kotlin 最终会取代 Java 成为新一代 JVM 主流语言， 但是从诞生到现在，好像依然没有语言能取代 Java。
###### 微服务框架：Spring Boot 和 Spring Cloud 进入晚期大众阶段；ServiceC
问：微服务框架：Spring Boot 和 Spring Cloud 进入晚期大众阶段；ServiceComb 处于早期采用者阶段；Apache Dubbo 处于晚期大众阶段；Tars 处于早期大众阶段
- 答：微服务技术处于早期大众与晚期大众之间，新的微服务开发框架需要技术突破和创新，不然已经难有一席之地； 
Java 不再是微服务唯一的选择； 
在技术多元化的今天，支持多语言的微服务开发框架是个必须品。
###### Java/JVM
问：Java/JVM
- 答：杨晓峰认为这一情况也正常：Java8 在可预见的将来依然会是生产的主体，放在晚期大众阶段是合理的。但是对于很多头部厂商来说，Java11 或者再后续版本，有可能陆续出现一定规模的生产化部署。他认为这样的趋势只会在头部公司发生，如果一个公司对大堆栈 GC 能力、延迟 SLA 等方面要求没有那么高，就没有足够动力去做相关升级，也未必有技术力量解决版本评估、兼容性修正等现实问题。所以结论就是：Java11 处于早期采用者阶段。 
对此黄飞补充：也正是因为 Java11 处于早期采用者阶段，因此相关的资料较少，遇到问题会有比较高的学习成本，例如 JFR 对 11 的支持，JMC 对 Java11 的分析能力较弱。 
而对于 Java 13，小马哥认为该版本在新 GC 算法的提升以及 Socket 实现上的变化还是非常令⼈期待的，因此 Java 13 排在创新者之列。 
对于 Java 的升级，Oracle 宣布从 Java 9 开始每半年将更新一个 Java 大版本——Java 11 是长期支持（Long-Term -Support, LTS）版本，Java 9、10 则成了过渡版本（non‑LTS），因此，陈楚晖不建议用户在生产中使用 Java 9、10。在他看来，小版本升级相对风险是比较小的，而大版本变更则会有可能需要更改大量的代码，这也是为什么这么多人还在坚持用 Java8，而不去更新 Java 11、12、或者 13 的原因。 
对于开发者升级 Java 动力不足的原因，李三红的解释更为详细，他认为有两个原因： 
敏捷的基础底层架构对软件升级的支持，企业对底层架构的重视程度也是 Java 升级的一个很关键原因。中国的企业业务发展都很快，但是其实很多对底层架构的支持和重视是不足够的。底层架构是否在企业内部被统一强管控，是否很容易支持不同软件版本的灰度，并能通过有效的预发测试，覆盖软件升级不兼容等带来的不确定性，这都考验着软件升级的难度。 另外一点，如果企业享受不到技术升级带来的红利，包括性能、编程效率等多方面提升，势必也影响升级的积极性。
###### 70% 的开发者选择使用 Oracle JDK，21% 的开发者选择使用 OpenJDK。
问：70% 的开发者选择使用 Oracle JDK，21% 的开发者选择使用 OpenJDK。
- 答：陈楚晖也介绍了国内的情况：目前国内开发者使用最多的依旧是 Oracle JDK，其次是 IBM JDK，也有部分企业采用 OpenJDK。 
杨晓峰认为虽然国内很多头部厂商都在定制 OpenJDK，但是目前定制 OpenJDK 被采用范围还都有限，这也跟上文数据结果吻合，所以他会把 OpenJDK 归在创新者阶段。 
但是对于参与 OpenJDK 的国内厂商来说，可能看法更加积极。在李三红看来：厂商是否转向 OpenJDK，还有一个重要考量因素就是看他们是否愿意付费使用 OracleJDK，如果不是的话，未来 OpenJDK 可能会逐渐取代 Oracle JDK，目前国内头部厂商都在 OpenJDK 上有所动作，所以他把 OpenJDK 定义在早期大众阶段。阿里巴巴使用并开源了 OpenJDK 长期支持版本 Dragonwell，目前阿里巴巴大部分的应用运行在 Dragonwell 8, 有些已经运行在 Dragonwell 11。 
据来自美团的吴革介绍：美团现阶段正在测试基于 OpenJDK 的 MtJDK，作为美团 JDK 基础服务。此外，美团主要会关注 Redhat 和 Amazon 的升级。由于 Azul 没有公开 OpenJDK 源代码，所以美团没有基于 Azul 进行研发。 
来自小米的黄飞也介绍了小米对于 OpenJDK 的应用情况：小米主要使用 OpenJDK8 以及 11 版本，目前对 OpenJDK 主要还是以使用为主。
###### 非 Hotspot JDK 生产实践——Graal VM、IBM OpenJ9
问：非 Hotspot JDK 生产实践——Graal VM、IBM OpenJ9
- 答：李三红表示：Graal VM 已经在 Oracle Cloud 生产环境大规模使用，TCK 兼容。值得一提的是，Graal VM 下的静态编译 SVM 造成了 Java 语言一些方面的不兼容， 这个也是整个社区担心的地方。如何让 SVM/ 静态编译能纳入到 Java Language/JVM Specification 里来？值得关注。 
杨晓峰的看法更加极端：在国内，怀疑 Graal VM、IBM OpenJ9 进入普遍生产实践的可能性会比较低。怀疑它们可能不会再走到下个阶段，很难跨越技术鸿沟。提及原因，他认为主要是国内公司大都在强调业务创新的速度，没有做如此深度的底层更新的耐心和业务必要性。而且从技术上来看，在动态特性支持等需求没有平滑解决方案之前，迁移难度很高，会带来很高的开发和运维成本。
###### Lambda /Stream、Vector API 等语法与特性
问：Lambda /Stream、Vector API 等语法与特性
- 答：对于 Lambda /Stream 等语法与特性，采访调研专家认为应该归类在晚期大众阶段。小马哥认为这些语法与特性在开发人员的⽇常⼯作中⼴泛地运用，并且没有看到语法回退的趋势。吴革表示：在美团内部，目前已经大量使用 Lambda 和 Stream 表达式。 
而对于 Vector API 等前沿版本特性，杨晓峰认为还只在个别头部公司处于原型阶段，应该被归在创新者阶段。
###### Spring Boot/Cloud、Apache Dubbo、TARS、ServiceComb
问：Spring Boot/Cloud、Apache Dubbo、TARS、ServiceComb 等微服务框架
- 答：田晓亮表示：Spring Cloud 社区依然在蓬勃发展，也开始为云厂商创造商业机会，如何与 Spring Cloud 结合，成为了云厂商要解决的关键问题之一。 
虽然越来越多的企业选择了 ServiceComb 进行微服务转型，并获得了成功，但并未普及到早期大众阶段。ServiceComb 中微服务框架与 Service Mesh 可以融合使用，让用户有了灵活的选择。 
Java 依然是最流行的语言，但企业也终于能够选择其他语言进行微服务开发了。同时提供 Spring Cloud 的组件可以使其接入到 ServiceComb 中，帮助 Spring Cloud 用户平滑向多语言转型，Java 不再是微服务唯一的选择。 
Apache Dubbo 一开始并不叫这个名字，Dubbo 一开始只是阿里内部的一个系统，2010 年 Dubbo 项目进行重构，2018 年初，Dubbo 项目正式进入 Apache 孵化器。在小马哥看来，Apache Dubbo 属于晚期大众阶段，不过最新的 Apache Dubbo ECO System（生态系统）则是一个基于 Apache Dubbo 衍进的 Cloud Native 解决方案，目前尚未枝叶茂盛，处于创新者阵营。 
对于 Apache Dubbo，黄飞表示：它在 RPC 中间件这个领域可以算得上引领者之一。Apache Dubbo 的服务注册与发现、服务治理相对完善，支持灰度发布，智能的负载均衡策略、可视化的服务治理与运维工具便于开发人员上手。可以说 Dubbo/Dubbox 在 RPC 框架 / 微服务领域已经展露头脚甚至在某些方面已经形成优势。 
TARS 在腾讯内部叫 TAF(Tencent Application Framework)，是腾讯应用产品最多、最广泛的微服务开发框架，并且已经在腾讯大规模应用了超过十年。2017 年中旬，腾讯正式将 TARS 开源，开源后一年便成为 Linux 基金会开源项目。由于相对其他微服务项目开源晚，错过了很多社区发展红利。 
对于 TARS，据单致豪介绍，不同的微服务主流框架可以满足不同的应用痛点，TARS 则原生专注多语言和高性能。他认为 TARS 已经有大型互联网公司广泛使用，已经从早期采用者阶段迈过了鸿沟，进入了早期大众阶段。
###### 您的企业使用的 JDK 版本情况，是否采用了某个 OpenJDK 发行版？
问：您的企业使用的 JDK 版本情况，是否采用了某个 OpenJDK 发行版？您如何看待 OpenJDK 在国内的发展？（如果没有采用，原因以及后续计划？）
- 答：阿里巴巴李三红：目前阿里巴巴大部分的应用运行在 Dragonwell 8，有些已经运行在了 Dragonwell 11， 我们正在逐步推动从 Java8 到 Java11 的升级，充分享受技术红利。 
美团吴革：美团现阶段主要使用 Java8，很少一部分是 Java7。部分核心团队正在尝试 Java 11。在美团内部采用的开发版本 JDK 主要还是 Oracle JDK。我们在服务器上的 JDK 版本主要是美团自己的 MtJDK 和 Oracle JDK。美团现阶段正在测试基于 OpenJDK 的 MtJDK，作为美团 JDK 基础服务。 
MtJDK 主要基于 OpenJDK 构建，现阶段主要针对补丁和安全性进行维护。现阶段在特定业务线内部进行测试和应用。未来配合 Serverless 等基础服务升级，MtJDK 会在 JDK 启动性能和增强应用之间的隔离进行深度定制。 
小米黄飞：小米主要使用 OpenJDK8 以及 11 版本。目前对 OpenJDK 主要还是以使用为主，主要的业务关注点在于这个版本是否为长期支持；是否有更加高效易用的特征，例如 GC 算法由 CMS、G1 升级到 ZGC 等；开源社区是否活跃；以及对遇到的问题是否有足够丰富的资料与讨论等。 Java 作为使用最为广泛的语言，最近几年还是有比较大进步的，无论从语法的易用性上还是性能上都有很大程度的提升。吸收了函数式编程的思想，lambda 表达式、Parallem stream、Var 变量等提升了开发人员的效率与代码的简洁性。ZGC 无疑是一项重大的改进，在一定程度上解决了 Java 天生的 GC 问题。
###### 您的企业目前在支持 Java 技术栈方面的策略是什么？计划和目标是什么？
问：您的企业目前在支持 Java 技术栈方面的策略是什么？计划和目标是什么？相关的核心痛点或者业务需求是什么？
- 答：
```
腾讯单致豪：腾讯内部占领导地位的开发者是 C++，同时有大量的 Node.Js、Golang、Java、PHP、Python 开发者，当然也有少量的 Rust、C# 的开发者。我们在海量用户的后端大部分采用 C++ 和 Golang，Java 在前端和大数据方面有广泛使用，在对外 ToB 的交付中也大量采用。 
由于腾讯的开发者使用了多种开发语言，而且不同开发语言在不同领域有不同优势，所以当前要解决的问题是多语言开发的服务互通问题，一套支持多语言的微服务开发框架是必需品，TARS 也是在这样的多语言背景下诞生。 
美团吴革：美团的 Java 技术栈策略偏向稳定，在稳定的基础之上推动技术升级。Java 核心痛点就是依赖升级，当一个 jar 包升级，必须一个服务一个服务升级，不能自动化整体升级，所以对于美团来说，正在解决相关依赖升级的问题。 
红帽陈楚晖：红帽主要采用市场流行的 Java 技术栈。大部分的项目都会采用 Java 进行开发，主要是因为 Java 比较成熟，有很多成熟的技术框架可以直接使用，同时也有很多类似的代码可以重用，也比较容易找到熟悉 Java 的技术人员。这样开发的速度和效率会比较高，以及成本会比较低。
```
###### 请介绍您的企业是否进行了微服务实践？如果是，在整体系统架构中的比例是多少？如果不是，是否有相关计划？
问：请介绍您的企业是否进行了微服务实践？如果是，在整体系统架构中的比例是多少？如果不是，是否有相关计划？
- 答：阿里巴巴小马哥：大多数应用已实施微服务架构，微服务应用的比重达 80% 以上。 
腾讯单致豪：早在 2008 年以前，腾讯已经开始实践“大系统小做”的海量服务之道理念，大量的服务已经是遵循微服务理念开发。因为腾讯要支持快速迭代和敏捷研发，所以微服务比例占比在 95% 以上。核心业务模块因为要支持海量用户的巨大流量，100% 都是微服务。腾讯内部使用 TARS 开发的微服务已经超数十万个节点，在规模上来看，是全球最大的微服务集群之一。 
美团吴革：美团在 2015 年开始微服务架构演进，核心系统已经 100% 微服务化。 
红帽陈楚晖：已经进行了微服务实践，在整体系统架构中占比不超过 30%。 
华为田晓亮：华为云的所有服务都采用微服务架构，但并非所有服务都用了某种微服务解决方案——比如 ServiceComb，Istio 或者 Spring cloud，各服务主要是自行实践微服务设计模式。但几乎所有应用服务都采用了华为云容器服务 CCE(Cloud Container Engine) 的 kubernetes 集群。
###### 您所采用的主要微服务框架是什么？如何判断国内该领域的技术发展情况？
问：您所采用的主要微服务框架是什么？如何判断国内该领域的技术发展情况？您认为微服务主流框架的争夺是否尘埃落定？
- 答：阿里巴巴小马哥：2015 年初开始，阿里巴巴集团的应用架构逐渐由 SOA 衍生至微服务，所使用的微服务框架主要以 Spring Boot / Spring Cloud 和 Apache Dubbo（HSF）为主，涵盖所有 Java 中间件核心基础设施、九成以上的内部系统，以及阿里云商户应用等。 
同时，基于 Spring Cloud API，阿里巴巴衍生并开源出一套全新的微服务框架 - Spring Cloud Alibaba，并且正走向下一代 “云原生” 架构，越来越多的应用开始尝试 Serverless 以及 Service Mesh 等前沿技术。相信未来微服务在不同语言和平台上将会提供更多的选择，至于那时谁是王者或主流框架，这个问题的答案已经不再重要。 
腾讯单致豪：不同的微服务主流框架可以满足不用的应用痛点，比如 SpringCloud、Dubbo 专注 Java 领域，TARS 则专注于多语言和高性能，充分发挥 C++ 的高性能、Go 的性能与高效兼顾、Java 的全能、Python 丰富基础库尤其是 AI 方面、Node.Js 和 PHP 便捷全面为 Web 而生等等优势。 
目前中国和美国大厂开源的微服务框架（腾讯的 TARS、阿里的 Dubbo、百度的 brpc、谷歌的 gRPC、Facebook 的 Thrift、Pivotal 的 SpringCloud）基本能覆盖所有用户的痛点，企业直接从开源社区选型能解决自己痛点的开发框架即可。 
美团吴革：主要采用自研 OCTO 和 Pigeon，现在正在开发 Service Mesh 服务。现在国内主要是基于 Dubbo、Spring Cloud、Google gRPC 作为基础进行二次封装，主流框架选型已经相对成熟。 
红帽陈楚晖：主要采用 Spring Cloud 的微服务框架，也对 Service Mesh（Istio）有研究。由于现有的微服务框架需要开发人员过多的介入，需要有大量的开发，所以目前大家比较看好 Istio。但是由于 Istio 还不够成熟，因此大家都还处于预研阶段。 
华为田晓亮：华为许多的云服务和内部项目采用了 ServiceComb 的微服务解决方案，比如消费者云，在全世界运行着数千微服务实例来为手机用户提供服务。此外，华为云的音视频服务也运行着数千的微服务实例，来提供视频通话、音视频解码等服务。并且我们也向社区（通过 ServiceComb）和商业用户（通过 ServiceStage）提供解决方案。
###### 您如何看待 Service Mesh 在国内的发展现状和发展前景？
问：您如何看待 Service Mesh 在国内的发展现状和发展前景？
- 答：阿里巴巴小马哥：个⼈对 Service Mesh 的看法是乐观偏谨慎的，一⽅⾯，作为从业人员，对于技术总有猎奇的心态。另外一⽅⾯，这个技术在设计上存在一些理想主义，比如，性能损耗以及稳定性，并且分布式场景中的典型问题并没有得到解决和改善，比如数据一致性、分布式事务等。 据我所知，国内不少的互联⽹公司，如阿⾥巴巴、蚂蚁⾦服以及美团等已经开始在生产环境试点 Service Mesh，听起来这是一件好事。前沿的技术总需要有⼈去探险，如果成功，前人栽树，后人乘凉。至于它能否成功，主要看市场是否愿意买单。 
美团吴革：未来 Service Mesh 会在跨语言场景下大放异彩。Service Mesh 主要是基于云平台和多技术栈场景下的痛点进行的开发，短时间内不会有爆发性的增长。但是基于原生云架构系统的增多，未来 Service Mesh 会不断演进，最终变为云原生架构下的网络基础服务。 
腾讯单致豪：Service Mesh 目前还处在早期发展阶段，其理念设计已经决定了性能及维护性上会是它最突出的短板。但有部分企业包括腾讯已经尝鲜，也有小量周边不重要非核心业务在上面跑。Service Mesh 有着优美的架构理念，但性能确实让人担忧，社区生态也至少需要三年以上的发展时间。 
华为田晓亮：大环境来看，传统企业面临的挑战依然是业务系统如何向微服务转型，以构建自己的业务平台，在这其中微服务框架是一种手段。为了寻求更快速地微服务化，开发人员就会避免学习陡峭的开发框架，而转向使用 Service Mesh。开发者将结合轻量的 SDK（例如对接监控系统、配置管理、AI 平台，而不是微服务框架）与 Service Mesh 来实现自己的业务系统，从繁重的架构工作中解放出来。这个发展历程在我看来大概需要 2-3 年的时间。 
而且，在我看来，最终站上舞台的并不是 Service Mesh，而是底层由 Service Mesh 提供支持的 Serverless 平台，用户感知不到 Service Mesh 技术的复杂性，否则将面临比开发框架更繁重的基础设施运维挑战。所以 Service Mesh 其实和 Serverless 的发展是绑定在一起的。Serverless 的普及和使用必然会帮助 Service Mesh 进行发展。
###### 对于当前 Java 的整体发展情况，您有什么感想？
问：对于当前 Java 的整体发展情况，您有什么感想？
- 答：杨晓峰：在可预见的将来，Java 依旧是企业软件、大数据、电商等等最核心的技术栈。但是目前 Java/JVM 能力在云时代有一定局限性，比如云里强调的无服务器、微服务等场景，Java/JVM 都有一定短板。 另外 Java 新版本采用速度这么慢，本身就说明，Java 创新和实际需求存在某种程度的脱节——一方面大量创新会带来兼容性和版本混乱的问题；另外创新带来的优点却需要极大增大开发运维成本，这也让部分创新的价值被抵消了。 但是 Java 会被取代吗？应该也不会，目前在社区、工具、类库等等方面，Java 还没有真正意义的对手，但是最大的威胁是新的需求浪潮是否与你有关。我们可以看下 GitHub 上 Java 新项目的趋势，一定程度上可以佐证 Java 坚实的基本面和不可忽视的隐忧。 
阿里巴巴李三红：从技术角度来看，Java（JDK）这二十几年的发展一直试图在 Productivity 以及 Performance 之间做最好的平衡。Java 是静态类型语言，但是为了生产效率提供了大量动态的特性比如 Bytecode Instrument、Dynamic Class Loading、Metaprogramming(Annotation、Reflection 等 ，这些形成了 Java 在运维、生产监控等领域的基石技术。 同时由于 Java 大量的动态特性存在，使得它在面向云原生、Serverless 计算时 Memory Footprint、Startup 方面被人所诟病。这也是整个 Java 社区，当然包括 Alibaba Dragonwell 所试图解决的问题。 
阿里巴巴小马哥：Java 目前仍具在编程语言排⾏榜上夺魁的能力，不过在整体比重上微幅下滑。个⼈看来，未来这个趋势还将持续。究其原因，一⽅⾯是由于新语种出现的中短期效应，一方面是 Java 的编程复杂度并没有明显的降低，比如 I/O 处理、并发 / 并⾏计算，以及类加载等等。再者是 Java 与操作系统之间的交互仍不够充分，尽管 Java 9 开始提供了不少的 API，然⽽了解和使用的群体不⾜。Java 在这方面明显不及 GO 语言。 
从语⾔层⾯来看，Java 正在向主流非 Java 语⾔融合，解决其中鸿沟的关键是语法的变化，比如 Java 8 的 Lambda 表达式 和 Java 10 的局部变量类型（ var ）等。个人认为这是一件好事，未来前后端不分家，相互渗透，对于彼此语言都是良性发展。 
除此之外，个人比较期待的是 GraalVM 对 Java 的改变，传统 Java 应用必须依赖 JVM 进程加载字节码后解释执行，无法保证所有的代码能够在运行期编程完成，不免有运⾏时编译所带来的性能开销，从而影响 JVM 的启停时间。简单地说，这种方式不够 Native，对于云原生或许不够友好。如果未来 GraalVM 的社区版也能够像 OpenJDK 那般“亲民”，那么，Java 的变化将是颠覆性的。 
美团吴革：当前 Java 已经发展成为一个庞然大物，语言上基本不会有太多突破，更多是借鉴和兼容。随着 GC 算法的升级和编译器换代，面对 Go 等新一代语言挑战，还有一战之力。 
腾讯单致豪：毋庸置疑，Java 语言依然活力十足，但在某些方面已经失去优势，如云原生领域现在出现了更具活力的 Go 语言。纷繁的世界必定会出现多语言并存、不断替代的现象。回顾历史发展进程，一种语言要从出现到早期大众使用基本都需要十年时间，能历经十年磨砺生存下来的开发语言，必定是有很强的生命力，而且都会有不同的企业构筑其生态。正如上文所说：不同语言也会在自己优势之处持续发展，形成很强的竞争壁垒。 
字节跳动王石冲：Scala 语言目前有两个大的目标运行平台——JVM 和 js，所以 Scala 作为一个语言和生态并不敢完全投资在单一目标平台上。虽然 JVM 本身在不断进步，但是 Java 已经被同平台的多种语言赶超，比如 Kotlin、Clojure、Groovy。
###### springcloud如何实现服务的注册和发现
问：springcloud如何实现服务的注册和发现
- 答：SpringCloud作为微服务的架构，是支持自定义组件的。下面，从套装组件说明 SpringCloud 套装组件 -- > 服务注册与发现中心： Eureka 使用，服务端，在启动类Application，添加@EnableEurekaServer注解，并且在配置文件，配置相关ServiceUrl等，可根据环境、所需，定制化配置，详情，可以参考官方使用API，当然也可以使用@DiscoveryServer，之前区别，可以自己去弥补下，本篇不再赘述 客户端，在启动类Application，添加@EnableEurekaClient，同样的做相关配置。 以上为服务注册发现大致实现，详细参照官方介绍，很简单
- 答：服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper） 这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient 同一个服务修改端口就可以启动多个实例 调用方法：传递服务名称通过注册中心获取所有的可用实例 通过负载均衡策略调用（ribbon和feign）对应的服务
###### 什么情况会造成dubbo链接中断？
问：什么情况会造成dubbo链接中断？ 
本问题来自阿里云开发者社区的【11大垂直技术领域开发者社群】。 <a href="https://developer.aliyun.com/article/713951"> 点击链接</a>欢迎加入感兴趣的技术领域群。
- 答：（1）同步调用，服务端超时 （2）服务端意外停止服务 （3）worker线程池爆池了 （4）服务端限流，导致有些请求无法完成 （5）服务端执行过程中遇到死锁，尤其是数据库死锁。 （6）如果是远程服务，网络波动的概率还是很大的。
###### 调用dubbo调用其他工程的服务接口 , 打上@Autowired注解启动时报下面的错
问：调用dubbo调用其他工程的服务接口 , 打上@Autowired注解启动时报下面的错 ,求大神们帮忙?
- 答：dubbo 用的动态字节码技术生成动态代理，就是Javassist。No such extension ，有几种种情况吧，（1）服务端有配置Service .(2)客户端dubbo配置有问题
###### 关于dubbo跟zk中a服务访问b集群的问题
问：关于dubbo跟zk中a服务访问b集群的问题？
- 答：dubbo注册中心返回服务提供者的列表给消费者，消费者从服务提供者列表中，按照软负载均衡算法，选择一台发起请求。 dubbo::reference里可以负载均衡。 zookeeper本身是不提供负载均衡的策略，但是可以在代理层做，如果你前端是dubbo，那么就不需要，dubbo就能做。
###### swagger怎么生成dubbo接口的文档,求指教
问：swagger怎么生成dubbo接口的文档,求指教
- 答：可以实现，你要先确定Dobbo的服务接口和访问请求映射，然后用swagger扫描dubbo的服务接口。swagger是个工具化的东西，工具的使用需要注意两点，一是应用的场景要swagger可以实现，这点事没什么问题，另一个工具的配置要正确，这个参考具体技术文档就可以了。
###### dubbo发布服务失败的问题
问：dubbo发布服务失败的问题 
本问题来自阿里云开发者社区的【11大垂直技术领域开发者社群】。 https://developer.aliyun.com/article/713951 点击链接欢迎加入感兴趣的技术领域群。
- 答：zk好像有问题
###### dubbo-admin启动时连接zookeeper失败
问：dubbo-admin启动时连接zookeeper失败
- 答：连接不上，超时，检查下端口有没有开，防火墙，还有服务器那里的绑定
###### 关于在tomcat中启动dubbo
问：关于在tomcat中启动dubbo
- 答：是jdk问题 版本太高 导致无法解析 dubbo中的xml文件
###### spring发布dubbo时报错For input string
问：spring发布dubbo时报错For input string
- 答：数字转换错误，看下是不是不支持多个ip，或者你的格式，分割符不对。
###### dubbo + zookeeper ？
问：dubbo + zookeeper ？
- 答：需要先注册服务端接口，然后调用，有xml方式和注解方式暴露服务，需要写好服务端代码，然后将服务提供端打包成jar包导入消费方，即可以实现调用
###### dubbo包动态部署服务平台如何搭建
问：dubbo包动态部署服务平台如何搭建 ？
- 答：那最好是搭建个jenkins,代码提交了就可以自动打包，然后部署到服务端，不过都要自己配置好才行
###### dubbo服务已启动，作为消费者的我调用服务端的接口，一直报错
问：dubbo服务已启动，作为消费者的我调用服务端的接口，一直报错
- 答：缺少正确的kryo序列化包，导致加载这个类的时候报错。请确认jar版本或jar文件是否下载完整
###### dubbo 消费方,如何将接口dubbo,注入到service或者dao层
问：dubbo 消费方,如何将接口dubbo,注入到service或者dao层？
- 答：跟什么层无关的，只要你正确配置了消费端该有的配置项，就可以访问，既然你controller层可以成功访问，那你把controller有关dubbo消费端的配置都copy就可以了
###### dubbo启动服务端报错？
问：dubbo启动服务端报错，什么原因？
- 答：DemoPurchaseService 你这个类的注解的@Service 应该是alibaba的而不是spring的；这个在spring启动的时候不会实例化；所以会报这个错误
###### Dubbo 消费者如果数据校验了，那么服务提供者还需要数据校验吗？
问：Dubbo 消费者如果数据校验了，那么服务提供者还需要数据校验吗？
- 答：像这种情况我们公司都是统一在dubbo做的处理，API只提供接口，其他的内容一致在dubbo做
###### 配置dubbo，启动消费端服务器出现问题
问：配置dubbo，启动消费端服务器出现问题
- 答：服务端没有找到可以用的 demoPurchaseService dubbo对象 你看看服务端是不是没配置好
###### dubbo调用提供者接口报错
问：dubbo调用提供者接口报错？
- 答：service的executes设置大些
###### zookeeper,dubbo服务注册，消费者调用为null
问：zookeeper,dubbo服务注册，消费者调用为null？
- 答：在服务提供端的配置文件中，在<dubbo:registry />标签中添加register="false"，并且在<dubbo:protocol />标签中将port属性的值修改为20880
###### maven项目配置dubbo报错,能找到相应的jar
问：maven项目配置dubbo报错,能找到相应的jar？
- 答：把这个文件找到下载，在eclipse/myeclipse中手动添加
###### dubbo和spring mvc 和spring的区别是什么 各自的作用是什么
问：dubbo和spring mvc 和spring的区别是什么 各自的作用是什么？
- 答：springmvc是spring的表现层的一个框架，引入模型、控制、视图的概念，从而使控制流程更加清晰，耦合更低。 dubbo是服务框架，用于服务调用。
###### dubbo框架是什么和spring啊spring mvc什么的 有什么区别和共同点
问：dubbo框架是什么和spring啊spring mvc什么的 有什么区别和共同点
- 答：Spring是MVC中的C层框架，负责各个组件的耦合 SpringMvc是V层的框架，负责页面跳转、返回值 dubbo框架是SOA架构的核心组件，有了dubbo你就能像调本地方法一样调用远程的方法了 
有些时候，Spring/SpringMvc/dubbo是结合在一起使用的
###### dubbo 如何获取一个服务的所有节点
问：dubbo 如何获取一个服务的所有节点？
- 答：List<节点> list referred相当于add destroyed 相当于remove,然后遍历就可以
###### DUBBO demo 启动一直会自动 shutdown
问：DUBBO demo 启动一直会自动 shutdown
- 答：将怀疑定位在服务启动自动关闭
- 答：因为zookeeper没有起来导致的问题，所以遇到此类问题可以先检查 20880端口。然后看下两边注册中心的地址是否一致
###### 关于Dubbo配置的问题~ spring整合Dubbo出现问题。
问：关于Dubbo配置的问题~ spring整合Dubbo出现问题。
- 答：1：dubbo依赖的spring版本和你的ssm框架的版本不一致， 如果jvm加载spring类的时候先加载的是dubbo依赖的版本，那你的ssm就不会再加载一次了 2：192.168.2.129:2181 protocol="zookeeper" 指的是你必须启动一个zookeeper服务，而zookeeper的端口是2181 这是dubbo会去连接zookeeper服务
###### dubbo无法序列化HttpServletRequest问题
问：dubbo无法序列化HttpServletRequest问题？
- 答：应该是要换一个参数，比如用HashMap,把request中需要用到的值存入map 
public Map uploadIdImage(HashMap map)
###### dubbo服务端有返回，客户端接收到null的问题
问：dubbo服务端有返回，客户端接收到null的问题？
- 答：出现问题时，并发量可能并不高，不超过100，而且并发量最高的业务，并没有出现异常，反而是一个并发并不高的业务请求查询时，出错概率奇高，发生3次批量调用，20笔调用，3笔出现问题 调用关系：该出问题业务模块为C，功能服务为B和A，调用次序是，C->B->A，均是dubbo通信调用。 出问题时，A返回结果，B拿到null，B封装一个结构返回至C,C拿到null。
###### bubbo消费端在工具中启动报错打包后tomcat下正常
问：bubbo消费端在工具中启动报错打包后tomcat下正常
- 答：关机重启？
###### dubbo分布式事务怎么处理
问：dubbo分布式事务怎么处理
- 答：①结合MQ消息中间件，实现消息最终一致性 ②TCC补偿性事务
- 答：目前比较多的解决方案有几个： 一、结合MQ消息中间件实现的可靠消息最终一致性 二、TCC补偿性事务解决方案 三、最大努力通知型方案 第一种方案：可靠消息最终一致性，需要业务系统结合MQ消息中间件实现，在实现过程中需要保证消息的成功发送及成功消费。即需要通过业务系统控制MQ的消息状态 第二种方案：TCC补偿性，分为三个阶段TRYING-CONFIRMING-CANCELING。每个阶段做不同的处理。 TRYING阶段主要是对业务系统进行检测及资源预留 CONFIRMING阶段是做业务提交，通过TRYING阶段执行成功后，再执行该阶段。默认如果TRYING阶段执行成功，CONFIRMING就一定能成功。 CANCELING阶段是回对业务做回滚，在TRYING阶段中，如果存在分支事务TRYING失败，则需要调用CANCELING将已预留的资源进行释放。 第三种方案：最大努力通知xing型，这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合MQ进行实现，例如：通过MQ发送http请求，设置最大通知次数。达到通知次数后即不再通知。 具体的案例你也可以参考下这篇博客，它上面有完整的电商系统分布式事务实现案例：http://www.roncoo.com/article/detail/124243
- 答：目前比较多的解决方案有几个： 一、结合MQ消息中间件实现的可靠消息最终一致性 二、TCC补偿性事务解决方案 三、最大努力通知型方案 第一种方案：可靠消息最终一致性，需要业务系统结合MQ消息中间件实现，在实现过程中需要保证消息的成功发送及成功消费。即需要通过业务系统控制MQ的消息状态 第二种方案：TCC补偿性，分为三个阶段TRYING-CONFIRMING-CANCELING。每个阶段做不同的处理。 TRYING阶段主要是对业务系统进行检测及资源预留 CONFIRMING阶段是做业务提交，通过TRYING阶段执行成功后，再执行该阶段。默认如果TRYING阶段执行成功，CONFIRMING就一定能成功。 CANCELING阶段是回对业务做回滚，在TRYING阶段中，如果存在分支事务TRYING失败，则需要调用CANCELING将已预留的资源进行释放。 第三种方案：最大努力通知xing型，这种方案主要用在与第三方系统通讯时，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合MQ进行实现，例如：通过MQ发送http请求，设置最大通知次数。达到通知次数后即不再通知。
###### dubbo分布式调用传参数
问：dubbo分布式调用传参数？
- 答：通过dubbo的RpcContext的attachment(map存储keyvalue)，可以隐式传参
###### Dubbo启动的时候支持几种配置方式？
问：Dubbo启动的时候支持几种配置方式？
- 答：根据 DUBBO 官方文档，配置 DUBBO 有 4 种方式，分别是： 
 XML 配置文件方式 
 properties 配置文件方式 
 annotation 配置方式 
 API 配置方式
- 答：XML 配置文件方式 properties 配置文件方式 annotation 配置方式 API 配置方式
###### 启动tomcat 报dubbo端口号冲突
问：启动tomcat 报dubbo端口号冲突?
- 答：21889 这个端口被占用了 如果是linux系统，可以用netstat -anp |grep 21889 查看 windows也可以用netstat查看
###### 出现RpcException: No provider available for remote s
问：出现RpcException: No provider available for remote service异常怎么办？
- 答：1). 检查连接的注册中心是否正确 
2). 到注册中心查看相应的服务提供者是否存在 
3). 检查服务提供者是否正常运行
###### 出现"消息发送失败"异常怎么办？
问：出现"消息发送失败"异常怎么办？
- 答：通常是接口方法的传入传出参数未实现Serializable接口。
###### 为什么消费者比提供者个数多？
问：为什么消费者比提供者个数多？
- 答：dubbo采用单一长连接，根据测算经验数据，每条连接最多只能压满7M，理论上1个服务提供者需要20个消费者才能压满网卡。
###### 为什么采用单一长连接
问：为什么采用单一长连接？
- 答：既然是长连接，就是用来做长久，持续的连接方式，所以，没有必要搞几个
- 答：服务大多数服务提供者少，服务的消费者多，单一连接保证单一消费者不会压死提供者，长连接减少连接握手频率，节省资源。
###### 测试和生产公用一套zookeeper，怎么保证消费不冲突
问：测试和生产公用一套zookeeper，怎么保证消费不冲突？
- 答：可以通过自定义filter实现filter接口来实现dubbo接口的ip白名单，限制访问权限。
###### 如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？
问：如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？
- 答：可以通信，启动dubbo时，消费者会从zk拉去注册的生产者的地址接口作为数据，缓存在本地，每次调用安装本地的缓存地址进行调用。
###### dubbo在安全机制方面如何解决的？
问：dubbo在安全机制方面如何解决的？
- 答：dubbo通过token令牌防止用户绕过注册中心直连，然后在注册中心管理授权，dubbo提供了黑白名单，控制服务所允许的调用方
###### hession序列化失败hessionruntimeexception
问：hession序列化失败hessionruntimeexception？
- 答：检查服务方法传入传出参数是否实现serializable接口
###### rejectedExecutionexception异常
问：rejectedExecutionexception异常？
- 答：线程池到达最大值，在dubbo.properties中增加线程池最大值和最小值大小
###### RpcLocalExceptionIoTargetIsNotConnected
问：RpcLocalExceptionIoTargetIsNotConnected错误？
- 答：检查注册中心是否开启白名单功能，如果开启了，当ip不在白名单列表中，注册中心拒绝连接。 检查端口是否正确，注册中心有2个端口，一个为控制台http端口，用于管理员查看数据，一个为程序注册服务用的tcp端口。
###### 服务注册不上
问：服务注册不上？
- 答：检查dubbo的jar包有没有在classpath中，以及有没有重复的jar包 检查暴露服务的spring配置有没有加载 在服务提供者机器上测试与注册中心的网络是否通
###### 为了方便开发测试，线下有一个所有服务可用的注册中心，这时，如果有一个正在开发中的服务提供者注册，可能
问：为了方便开发测试，线下有一个所有服务可用的注册中心，这时，如果有一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行？
- 答：让服务提供者开发方，只订阅服务，而不注册正在开发的服务，通过直连测试正在开发的服务。设置dubbo:registry标签的register属性为false
###### dubbo缺省会在启动时检查依赖是否可用
问：dubbo缺省会在启动时检查依赖是否可用？
- 答：不可用就抛出异常，阻止spring初始化完成，check属性默认为true。测试时有些服务不关心或者出现了循环依赖，将check设置为false
###### spring 2.x初始化死锁问题。
问：spring 2.x初始化死锁问题。在spring解析到dubbo:service时，就已经向外暴露了服务，而spring还在接着初始化其他bean，如果这时有请求进来，并且服务的实现类里有调用applicationContext.getBean()的用法。getBean线程和spring初始化线程的锁的顺序不一样，导致了线程死锁，不能提供服务，启动不了。
- 答：延迟暴露 
http://dubbo.apache.org/zh-cn/docs/user/demos/delay-publish.html
- 答：不要在服务的实现类中使用applicationContext.getBean();如果不想依赖配置顺序，可以将dubbo:provider的deplay属性设置为-1，使dubbo在容器初始化完成后再暴露服务。
###### dubbo中什么是本地暴露和远程暴露？
问：dubbo中什么是本地暴露和远程暴露？
- 答：本地暴露：一个服务可能既是provider，又是consumer，自己调用自己的服务，暴露在jvm中，不需要网络通信。url是以injvm开头 
远程暴露：将ip，端口等信息暴露给远程客户端，调用时需要网络通信。
###### Dubbo是什么？
问：Dubbo是什么？
- 答：Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架
- 答：Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。
###### 为什么要用Dubbo？
问：为什么要用Dubbo？
- 答：因为是阿里开源项目，高性能高可用性。
- 答：因为是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了 Netty、Zookeeper，保证了高性能高可用性。 
使用 Dubbo 可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。
###### Dubbo 和 Spring Cloud 有什么区别？
问：Dubbo 和 Spring Cloud 有什么区别？
- 答：spring-cloud的服务注册中心为spring-cloud netflix enruka，服务监控中心为spring-boot admin,有消息总线，数据流、服务跟踪、批量任务等组件；
- 答：1）通信方式不同 Dubbo 使用的是 RPC 通信，而 Spring Cloud 使用的是 HTTP RESTFul 方式。 2）组成部分不同
###### dubbo都支持什么协议，推荐用哪种？
问：dubbo都支持什么协议，推荐用哪种？
- 答：dubbo,webservice,http
###### Dubbo默认使用什么注册中心，还有别的选择吗？
问：Dubbo默认使用什么注册中心，还有别的选择吗？
- 答：ZooKeeper,还可以使用redis等,但不推荐使用
